import "./utils/vue3.3.polyfill";
import type { __ExtractPublicPropTypes } from "vue";
import { AllowedComponentProps } from "vue";
import { App } from "vue";
import type { AppContext } from "vue";
import { Component } from "vue";
import { ComponentCustomProperties } from "vue";
import { ComponentCustomProps } from "vue";
import { ComponentInternalInstance } from "vue";
import { ComponentOptionsBase } from "vue";
import { ComponentOptionsMixin } from "vue";
import { ComponentProvideOptions } from "vue";
import { ComponentPublicInstance } from "vue";
import { ComputedRef } from "vue";
import { CreateComponentPublicInstance } from "vue";
import { CSSProperties } from "vue";
import { Dayjs } from "dayjs";
import { default as dayjs } from "dayjs";
import { default as dayjs_2 } from "dayjs";
import { DebouncedFunc } from "lodash";
import { DebuggerEvent } from "vue";
import { DefineComponent } from "vue";
import { DeprecationTypes } from "vue";
import { Directive } from "vue";
import { EmitsOptions } from "vue";
import { ExtractPropTypes } from "vue";
import type { h } from "vue";
import { InjectionKey } from "vue";
import { Instance as Instance_2 } from "@popperjs/core";
import { InternalRuleItem } from "async-validator";
import { MaybeRef } from "@vueuse/core";
import { MemoizedFn } from "memoize-one";
import { MemoizedFunction } from "lodash";
import { MethodOptions } from "vue";
import type { Middleware } from "@floating-ui/dom";
import type { Modifier } from "@popperjs/core";
import type { NavigationFailure } from "vue-router";
import { NavigationGuard } from "vue-router";
import { NavigationGuardWithThis } from "vue-router";
import { nextTick } from "vue";
import { Numberify } from "@ctrl/tinycolor";
import { ObjectDirective } from "vue";
import { ObjectFitProperty } from "csstype";
import { Offsets } from "@popperjs/core";
import { Options } from "@popperjs/core";
import { OptionsGeneric } from "@popperjs/core";
import { Placement } from "@popperjs/core";
import { Placement as Placement_2 } from "@floating-ui/core";
import type { Placement as Placement_3 } from "@floating-ui/dom";
import type { Plugin as Plugin_2 } from "vue";
import { PositioningStrategy } from "@popperjs/core";
import { PropType } from "vue";
import { Ref } from "vue";
import { RendererElement } from "vue";
import { RendererNode } from "vue";
import { RGBA } from "@ctrl/tinycolor";
import { RouteLocationRaw } from "vue-router";
import { Rule } from "async-validator";
import type { RuleItem } from "async-validator";
import { RuleType } from "async-validator";
import { RuntimeCompilerOptions } from "vue";
import { SetupContext } from "vue";
import { ShallowRef } from "vue";
import { ShallowUnwrapRef } from "vue";
import { SideObject } from "@popperjs/core";
import type { SideObject as SideObject_2 } from "@floating-ui/dom";
import type { Slot } from "vue";
import { Slots } from "vue";
import type { State } from "@popperjs/core";
import { StateRects } from "@popperjs/core";
import type { Strategy } from "@floating-ui/dom";
import { StyleValue } from "vue";
import { SyncValidateResult } from "async-validator";
import type { ToRefs } from "vue";
import { TransitionProps } from "vue";
import type { UnwrapNestedRefs } from "vue";
import type { UnwrapRef } from "vue";
import { ValidateError } from "async-validator";
import type { ValidateFieldsError } from "async-validator";
import { ValidateOption } from "async-validator";
import { Value as Value_2 } from "async-validator";
import { Values } from "async-validator";
import type { VirtualElement } from "@floating-ui/dom";
import type { VirtualElement as VirtualElement_2 } from "@popperjs/core";
import { VisualViewport as VisualViewport_2 } from "@popperjs/core";
import { VNode } from "vue";
import type { VNodeChild } from "vue";
import { VNodeProps } from "vue";
import { VNodeRef } from "vue";
import { WatchCallback } from "vue";
import { WatchOptions } from "vue";
import { WatchStopHandle } from "vue";
import { Window as Window_2 } from "@popperjs/core";
import { WritableComputedRef } from "vue";
import { ZIndexProperty } from "csstype";
declare const __VLS_component: DefineComponent<{
    readonly zIndex: EpPropFinalized<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown, 100, boolean>;
    readonly target: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly position: EpPropFinalized<StringConstructor, "top" | "bottom", unknown, "top", boolean>;
}, {
    /** @description update affix status */
    update: () => void;
    /** @description update rootRect info */
    updateRoot: () => Promise<void>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    scroll: (args_0: {
        scrollTop: number;
        fixed: boolean;
    }) => void;
    change: (fixed: boolean) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly zIndex: EpPropFinalized<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown, 100, boolean>;
    readonly target: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly position: EpPropFinalized<StringConstructor, "top" | "bottom", unknown, "top", boolean>;
}>> & {
    onScroll?: ((args_0: {
        scrollTop: number;
        fixed: boolean;
    }) => any) | undefined;
    onChange?: ((fixed: boolean) => any) | undefined;
}, {
    readonly position: EpPropMergeType<StringConstructor, "top" | "bottom", unknown>;
    readonly zIndex: EpPropMergeType<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown>;
    readonly offset: number;
    readonly target: string;
}>;
declare const __VLS_component_10: DefineComponent<{
    readonly visibilityHeight: {
        readonly type: NumberConstructor;
        readonly default: 200;
    };
    readonly target: {
        readonly type: StringConstructor;
        readonly default: "";
    };
    readonly right: {
        readonly type: NumberConstructor;
        readonly default: 40;
    };
    readonly bottom: {
        readonly type: NumberConstructor;
        readonly default: 40;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (evt: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly visibilityHeight: {
        readonly type: NumberConstructor;
        readonly default: 200;
    };
    readonly target: {
        readonly type: StringConstructor;
        readonly default: "";
    };
    readonly right: {
        readonly type: NumberConstructor;
        readonly default: 40;
    };
    readonly bottom: {
        readonly type: NumberConstructor;
        readonly default: 40;
    };
}>> & {
    onClick?: ((evt: MouseEvent) => any) | undefined;
}, {
    readonly bottom: number;
    readonly right: number;
    readonly target: string;
    readonly visibilityHeight: number;
}>;
declare const __VLS_component_11: DefineComponent<{
    readonly value: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 99, boolean>;
    readonly isDot: BooleanConstructor;
    readonly hidden: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "danger", boolean>;
    readonly showZero: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly color: StringConstructor;
    readonly badgeStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly offset: EpPropFinalized<(new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]) | ((new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]))[], unknown, unknown, readonly [
        0,
        0
    ], boolean>;
    readonly badgeClass: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description badge content */
    content: ComputedRef<string>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly value: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 99, boolean>;
    readonly isDot: BooleanConstructor;
    readonly hidden: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "danger", boolean>;
    readonly showZero: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly color: StringConstructor;
    readonly badgeStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly offset: EpPropFinalized<(new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]) | ((new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]))[], unknown, unknown, readonly [
        0,
        0
    ], boolean>;
    readonly badgeClass: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly hidden: boolean;
    readonly offset: [
        number,
        number
    ];
    readonly value: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly type: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly max: number;
    readonly showZero: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly isDot: boolean;
}>;
declare const __VLS_component_12: DefineComponent<{
    readonly separator: EpPropFinalized<StringConstructor, unknown, unknown, "/", boolean>;
    readonly separatorIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly separator: EpPropFinalized<StringConstructor, unknown, unknown, "/", boolean>;
    readonly separatorIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly separator: string;
}>;
declare const __VLS_component_13: DefineComponent<{
    readonly to: EpPropFinalized<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown, "", boolean>;
    readonly replace: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly to: EpPropFinalized<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown, "", boolean>;
    readonly replace: BooleanConstructor;
}>>, {
    readonly to: EpPropMergeType<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown>;
    readonly replace: boolean;
}>;
declare const __VLS_component_14: DefineComponent<{
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly nativeType: EpPropFinalized<StringConstructor, "button" | "reset" | "submit", unknown, "button", boolean>;
    readonly loading: BooleanConstructor;
    readonly loadingIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly plain: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly text: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly link: BooleanConstructor;
    readonly bg: BooleanConstructor;
    readonly autofocus: BooleanConstructor;
    readonly round: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly circle: BooleanConstructor;
    readonly color: StringConstructor;
    readonly dark: BooleanConstructor;
    readonly autoInsertSpace: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly tag: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "button", boolean>;
}, {
    /** @description button html element */
    ref: Ref<HTMLButtonElement | undefined>;
    /** @description button size */
    size: ComputedRef<"" | "small" | "default" | "large">;
    /** @description button type */
    type: ComputedRef<string>;
    /** @description button disabled */
    disabled: ComputedRef<boolean>;
    /** @description whether adding space */
    shouldAddSpace: ComputedRef<boolean>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (evt: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly nativeType: EpPropFinalized<StringConstructor, "button" | "reset" | "submit", unknown, "button", boolean>;
    readonly loading: BooleanConstructor;
    readonly loadingIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly plain: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly text: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly link: BooleanConstructor;
    readonly bg: BooleanConstructor;
    readonly autofocus: BooleanConstructor;
    readonly round: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly circle: BooleanConstructor;
    readonly color: StringConstructor;
    readonly dark: BooleanConstructor;
    readonly autoInsertSpace: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly tag: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "button", boolean>;
}>> & {
    onClick?: ((evt: MouseEvent) => any) | undefined;
}, {
    readonly link: boolean;
    readonly circle: boolean;
    readonly text: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly disabled: boolean;
    readonly round: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly dark: boolean;
    readonly type: EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly bg: boolean;
    readonly loading: boolean;
    readonly autofocus: boolean;
    readonly tag: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly plain: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly autoInsertSpace: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly nativeType: EpPropMergeType<StringConstructor, "button" | "reset" | "submit", unknown>;
    readonly loadingIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
}>;
declare const __VLS_component_15: DefineComponent<{
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
}>>, {
    readonly type: EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>;
}>;
declare const __VLS_component_16: DefineComponent<{
    readonly modelValue: {
        readonly type: PropType<Date>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly range: {
        readonly type: PropType<[
            Date,
            Date
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description currently selected date */
    selectedDay: WritableComputedRef<Dayjs | undefined>;
    /** @description select a specific date */
    pickDay: (day: Dayjs) => void;
    /** @description select date */
    selectDate: (type: CalendarDateType) => void;
    /** @description Calculate the validate date range according to the start and end dates */
    calculateValidatedDateRange: (startDayjs: Dayjs, endDayjs: Dayjs) => [
        Dayjs,
        Dayjs
    ][];
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: Date) => void;
    input: (value: Date) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly modelValue: {
        readonly type: PropType<Date>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly range: {
        readonly type: PropType<[
            Date,
            Date
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:modelValue"?: ((value: Date) => any) | undefined;
    onInput?: ((value: Date) => any) | undefined;
}, {}>;
declare const __VLS_component_17: DefineComponent<{
    readonly selectedDay: {
        readonly type: PropType<Dayjs>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly range: {
        readonly type: PropType<[
            Dayjs,
            Dayjs
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly date: {
        readonly type: PropType<Dayjs>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hideHeader: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description toggle date panel */
    getFormattedDate: (day: number, type: CalendarDateCellType) => Dayjs;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    pick: (value: Dayjs) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly selectedDay: {
        readonly type: PropType<Dayjs>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly range: {
        readonly type: PropType<[
            Dayjs,
            Dayjs
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly date: {
        readonly type: PropType<Dayjs>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hideHeader: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onPick?: ((value: Dayjs) => any) | undefined;
}, {}>;
declare const __VLS_component_18: DefineComponent<{
    readonly header: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly footer: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly bodyStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly shadow: EpPropFinalized<StringConstructor, "always" | "never" | "hover", unknown, undefined, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly header: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly footer: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly bodyStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly shadow: EpPropFinalized<StringConstructor, "always" | "never" | "hover", unknown, undefined, boolean>;
}>>, {
    readonly footer: string;
    readonly header: string;
    readonly bodyStyle: StyleValue;
    readonly shadow: EpPropMergeType<StringConstructor, "always" | "never" | "hover", unknown>;
}>;
declare const __VLS_component_19: DefineComponent<{
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly height: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly trigger: EpPropFinalized<StringConstructor, "click" | "hover", unknown, "hover", boolean>;
    readonly autoplay: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly interval: EpPropFinalized<NumberConstructor, unknown, unknown, 3000, boolean>;
    readonly indicatorPosition: EpPropFinalized<StringConstructor, "" | "none" | "outside", unknown, "", boolean>;
    readonly arrow: EpPropFinalized<StringConstructor, "always" | "never" | "hover", unknown, "hover", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "" | "card", unknown, "", boolean>;
    readonly cardScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.83, boolean>;
    readonly loop: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly pauseOnHover: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly motionBlur: BooleanConstructor;
}, {
    /** @description active slide index */
    activeIndex: WritableComputedRef<number>;
    /** @description manually switch slide, index of the slide to be switched to, starting from 0; or the `name` of corresponding `el-carousel-item` */
    setActiveItem: (index: number | string) => void;
    /** @description switch to the previous slide */
    prev: () => void;
    /** @description switch to the next slide */
    next: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    change: (current: number, prev: number) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly height: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly trigger: EpPropFinalized<StringConstructor, "click" | "hover", unknown, "hover", boolean>;
    readonly autoplay: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly interval: EpPropFinalized<NumberConstructor, unknown, unknown, 3000, boolean>;
    readonly indicatorPosition: EpPropFinalized<StringConstructor, "" | "none" | "outside", unknown, "", boolean>;
    readonly arrow: EpPropFinalized<StringConstructor, "always" | "never" | "hover", unknown, "hover", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "" | "card", unknown, "", boolean>;
    readonly cardScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.83, boolean>;
    readonly loop: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly pauseOnHover: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly motionBlur: BooleanConstructor;
}>> & {
    onChange?: ((current: number, prev: number) => any) | undefined;
}, {
    readonly height: string;
    readonly direction: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly type: EpPropMergeType<StringConstructor, "" | "card", unknown>;
    readonly arrow: EpPropMergeType<StringConstructor, "always" | "never" | "hover", unknown>;
    readonly trigger: EpPropMergeType<StringConstructor, "click" | "hover", unknown>;
    readonly loop: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly interval: number;
    readonly initialIndex: number;
    readonly autoplay: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly indicatorPosition: EpPropMergeType<StringConstructor, "" | "none" | "outside", unknown>;
    readonly cardScale: number;
    readonly pauseOnHover: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly motionBlur: boolean;
}>;
declare const __VLS_component_2: DefineComponent<{
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
    readonly closable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly showIcon: BooleanConstructor;
    readonly center: BooleanConstructor;
    readonly effect: EpPropFinalized<StringConstructor, "dark" | "light", unknown, "light", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    open: () => void;
    close: (evt?: Event | undefined) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
    readonly closable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly showIcon: BooleanConstructor;
    readonly center: BooleanConstructor;
    readonly effect: EpPropFinalized<StringConstructor, "dark" | "light", unknown, "light", boolean>;
}>> & {
    onOpen?: (() => any) | undefined;
    onClose?: ((evt?: Event | undefined) => any) | undefined;
}, {
    readonly title: string;
    readonly center: boolean;
    readonly type: EpPropMergeType<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown>;
    readonly description: string;
    readonly effect: EpPropMergeType<StringConstructor, "dark" | "light", unknown>;
    readonly showAfter: number;
    readonly hideAfter: number;
    readonly autoClose: number;
    readonly closable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly closeText: string;
    readonly showIcon: boolean;
}>;
declare const __VLS_component_20: DefineComponent<{
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly label: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly label: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
}>>, {
    readonly label: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly name: string;
}>;
declare const __VLS_component_21: DefineComponent<{
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placeholder: StringConstructor;
    disabled: BooleanConstructor;
    clearable: BooleanConstructor;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    filterable: BooleanConstructor;
    filterMethod: EpPropFinalized<(new (...args: any[]) => (node: CascaderNode, keyword: string) => boolean) | (() => (node: CascaderNode, keyword: string) => boolean) | {
        (): (node: CascaderNode, keyword: string) => boolean;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (node: CascaderNode, keyword: string) => boolean) | (() => (node: CascaderNode, keyword: string) => boolean) | {
        (): (node: CascaderNode, keyword: string) => boolean;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, (node: CascaderNode, keyword: string) => boolean, boolean>;
    separator: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    showAllLevels: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    collapseTags: BooleanConstructor;
    maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    collapseTagsTooltip: BooleanConstructor;
    maxCollapseTagsTooltipHeight: {
        readonly type: PropType<EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    debounce: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    beforeFilter: EpPropFinalized<(new (...args: any[]) => (value: string) => boolean | Promise<any>) | (() => (value: string) => boolean | Promise<any>) | {
        (): (value: string) => boolean | Promise<any>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (value: string) => boolean | Promise<any>) | (() => (value: string) => boolean | Promise<any>) | {
        (): (value: string) => boolean | Promise<any>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, string, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, string[], boolean>;
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, string, boolean>;
    tagType: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagEffect: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    showCheckedStrategy: EpPropFinalized<StringConstructor, string, unknown, string, boolean>;
    checkOnClickNode: BooleanConstructor;
    showPrefix: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
}, {
    /**
    * @description get an array of currently selected node,(leafOnly) whether only return the leaf checked nodes, default is `false`
    */
    getCheckedNodes: (leafOnly: boolean) => CascaderNode[] | undefined;
    /**
    * @description cascader panel ref
    */
    cascaderPanelRef: Ref<CascaderPanelInstance | null>;
    /**
    * @description toggle the visible of popper
    */
    togglePopperVisible: (visible?: boolean) => void;
    /**
    * @description cascader content ref
    */
    contentRef: ComputedRef<HTMLElement | undefined>;
    /**
    * @description selected content text
    */
    presentText: ComputedRef<string>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    clear: () => void;
    "update:modelValue": (value: CascaderValue | null | undefined) => void;
    change: (value: CascaderValue | null | undefined) => void;
    blur: (evt: FocusEvent) => void;
    focus: (evt: FocusEvent) => void;
    visibleChange: (val: boolean) => void;
    expandChange: (val: CascaderValue) => void;
    removeTag: (val: CascaderNodeValue_2 | CascaderNodePathValue_2) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placeholder: StringConstructor;
    disabled: BooleanConstructor;
    clearable: BooleanConstructor;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    filterable: BooleanConstructor;
    filterMethod: EpPropFinalized<(new (...args: any[]) => (node: CascaderNode, keyword: string) => boolean) | (() => (node: CascaderNode, keyword: string) => boolean) | {
        (): (node: CascaderNode, keyword: string) => boolean;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (node: CascaderNode, keyword: string) => boolean) | (() => (node: CascaderNode, keyword: string) => boolean) | {
        (): (node: CascaderNode, keyword: string) => boolean;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, (node: CascaderNode, keyword: string) => boolean, boolean>;
    separator: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    showAllLevels: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    collapseTags: BooleanConstructor;
    maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    collapseTagsTooltip: BooleanConstructor;
    maxCollapseTagsTooltipHeight: {
        readonly type: PropType<EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    debounce: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    beforeFilter: EpPropFinalized<(new (...args: any[]) => (value: string) => boolean | Promise<any>) | (() => (value: string) => boolean | Promise<any>) | {
        (): (value: string) => boolean | Promise<any>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (value: string) => boolean | Promise<any>) | (() => (value: string) => boolean | Promise<any>) | {
        (): (value: string) => boolean | Promise<any>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, string, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, string[], boolean>;
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, string, boolean>;
    tagType: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagEffect: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    showCheckedStrategy: EpPropFinalized<StringConstructor, string, unknown, string, boolean>;
    checkOnClickNode: BooleanConstructor;
    showPrefix: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: CascaderValue | null | undefined) => any) | undefined;
    onChange?: ((value: CascaderValue | null | undefined) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onClear?: (() => any) | undefined;
    onVisibleChange?: ((val: boolean) => any) | undefined;
    onExpandChange?: ((val: CascaderValue) => any) | undefined;
    onRemoveTag?: ((val: CascaderNodeValue_2 | CascaderNodePathValue_2) => any) | undefined;
}, {
    disabled: boolean;
    separator: string;
    props: CascaderProps;
    placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown>;
    options: CascaderOption[];
    effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    clearable: boolean;
    fallbackPlacements: Placement[];
    teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    debounce: number;
    checkOnClickNode: boolean;
    showPrefix: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    filterable: boolean;
    filterMethod: (node: CascaderNode, keyword: string) => boolean;
    showAllLevels: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    collapseTags: boolean;
    maxCollapseTags: number;
    collapseTagsTooltip: boolean;
    beforeFilter: (value: string) => boolean | Promise<any>;
    tagType: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    tagEffect: EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>;
    showCheckedStrategy: string;
}>;
declare const __VLS_component_22: DefineComponent<{
    border: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    renderLabel: {
        readonly type: PropType<RenderLabel_2>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
}, {
    menuList: Ref<CascaderMenuInstance[]>;
    menus: Ref<{
        readonly uid: number;
        readonly level: number;
        readonly value: CascaderNodeValue_2;
        readonly label: string;
        readonly pathNodes: any[];
        readonly pathValues: CascaderNodeValue_2[];
        readonly pathLabels: string[];
        childrenData: {
            [x: string]: unknown;
            label?: string | undefined;
            value?: CascaderNodeValue_2 | undefined;
            children?: any[] | undefined;
            disabled?: boolean | undefined;
            leaf?: boolean | undefined;
        }[] | undefined;
        children: any[];
        text: string;
        loaded: boolean;
        checked: boolean;
        indeterminate: boolean;
        loading: boolean;
        readonly data: {
            [x: string]: unknown;
            label?: string | undefined;
            value?: CascaderNodeValue_2 | undefined;
            children?: any[] | undefined;
            disabled?: boolean | undefined;
            leaf?: boolean | undefined;
        };
        readonly config: {
            expandTrigger: ExpandTrigger;
            multiple: boolean;
            checkStrictly: boolean;
            emitPath: boolean;
            lazy: boolean;
            lazyLoad: LazyLoad_2;
            value: string;
            label: string;
            children: string;
            disabled: string | isDisabled_2;
            leaf: string | isLeaf_2;
            hoverThreshold: number;
            checkOnClickNode: boolean;
            checkOnClickLeaf: boolean;
            showPrefix: boolean;
        };
        readonly parent?: any | undefined;
        readonly root: boolean;
        readonly isDisabled: boolean;
        readonly isLeaf: boolean;
        readonly valueByOption: CascaderNodeValue_2 | CascaderNodeValue_2[];
        appendChild: (childData: CascaderOption) => CascaderNode;
        calcText: (allLevels: boolean, separator: string) => string;
        broadcast: (checked: boolean) => void;
        emit: () => void;
        onParentCheck: (checked: boolean) => void;
        onChildCheck: () => void;
        setCheckState: (checked: boolean) => void;
        doCheck: (checked: boolean) => void;
    }[][]>;
    checkedNodes: Ref<{
        readonly uid: number;
        readonly level: number;
        readonly value: CascaderNodeValue_2;
        readonly label: string;
        readonly pathNodes: any[];
        readonly pathValues: CascaderNodeValue_2[];
        readonly pathLabels: string[];
        childrenData: {
            [x: string]: unknown;
            label?: string | undefined;
            value?: CascaderNodeValue_2 | undefined;
            children?: any[] | undefined;
            disabled?: boolean | undefined;
            leaf?: boolean | undefined;
        }[] | undefined;
        children: any[];
        text: string;
        loaded: boolean;
        checked: boolean;
        indeterminate: boolean;
        loading: boolean;
        readonly data: {
            [x: string]: unknown;
            label?: string | undefined;
            value?: CascaderNodeValue_2 | undefined;
            children?: any[] | undefined;
            disabled?: boolean | undefined;
            leaf?: boolean | undefined;
        };
        readonly config: {
            expandTrigger: ExpandTrigger;
            multiple: boolean;
            checkStrictly: boolean;
            emitPath: boolean;
            lazy: boolean;
            lazyLoad: LazyLoad_2;
            value: string;
            label: string;
            children: string;
            disabled: string | isDisabled_2;
            leaf: string | isLeaf_2;
            hoverThreshold: number;
            checkOnClickNode: boolean;
            checkOnClickLeaf: boolean;
            showPrefix: boolean;
        };
        readonly parent?: any | undefined;
        readonly root: boolean;
        readonly isDisabled: boolean;
        readonly isLeaf: boolean;
        readonly valueByOption: CascaderNodeValue_2 | CascaderNodeValue_2[];
        appendChild: (childData: CascaderOption) => CascaderNode;
        calcText: (allLevels: boolean, separator: string) => string;
        broadcast: (checked: boolean) => void;
        emit: () => void;
        onParentCheck: (checked: boolean) => void;
        onChildCheck: () => void;
        setCheckState: (checked: boolean) => void;
        doCheck: (checked: boolean) => void;
    }[]>;
    handleKeyDown: (e: KeyboardEvent) => void;
    handleCheckChange: (node: CascaderNode, checked: boolean, emitClose?: boolean) => void;
    getFlattedNodes: (leafOnly: boolean) => CascaderNode[];
    /**
    * @description get an array of currently selected node,(leafOnly) whether only return the leaf checked nodes, default is `false`
    */
    getCheckedNodes: (leafOnly: boolean) => CascaderNode[];
    /**
    * @description clear checked nodes
    */
    clearCheckedNodes: () => void;
    calculateCheckedValue: () => void;
    scrollToExpandingNode: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: CascaderValue_2 | null | undefined) => void;
    change: (value: CascaderValue_2 | null | undefined) => void;
    close: () => void;
    "expand-change": (value: CascaderNodePathValue_2) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    border: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    renderLabel: {
        readonly type: PropType<RenderLabel_2>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: CascaderValue_2 | null | undefined) => any) | undefined;
    onChange?: ((value: CascaderValue_2 | null | undefined) => any) | undefined;
    onClose?: (() => any) | undefined;
    "onExpand-change"?: ((value: CascaderNodePathValue_2) => any) | undefined;
}, {
    border: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    props: CascaderProps;
    options: CascaderOption[];
}>;
declare const __VLS_component_23: DefineComponent<{
    nodes: {
        type: PropType<CascaderNode[]>;
        required: true;
    };
    index: {
        type: NumberConstructor;
        required: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    nodes: {
        type: PropType<CascaderNode[]>;
        required: true;
    };
    index: {
        type: NumberConstructor;
        required: true;
    };
}>>, {}>;
declare const __VLS_component_24: DefineComponent<{
    readonly checked: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    change: (value: boolean) => void;
    "update:checked": (value: boolean) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly checked: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
}>> & {
    onChange?: ((value: boolean) => any) | undefined;
    "onUpdate:checked"?: ((value: boolean) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly type: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly checked: boolean;
}>;
declare const __VLS_component_25: DefineComponent<{
    ariaControls: StringConstructor;
    modelValue: {
        type: (BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    label: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    value: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    indeterminate: BooleanConstructor;
    disabled: BooleanConstructor;
    checked: BooleanConstructor;
    name: {
        type: StringConstructor;
        default: undefined;
    };
    trueValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    trueLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    id: {
        type: StringConstructor;
        default: undefined;
    };
    border: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tabindex: (NumberConstructor | StringConstructor)[];
    validateEvent: {
        type: BooleanConstructor;
        default: boolean;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: CheckboxValueType) => void;
    change: (val: CheckboxValueType) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    ariaControls: StringConstructor;
    modelValue: {
        type: (BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    label: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    value: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    indeterminate: BooleanConstructor;
    disabled: BooleanConstructor;
    checked: BooleanConstructor;
    name: {
        type: StringConstructor;
        default: undefined;
    };
    trueValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    trueLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    id: {
        type: StringConstructor;
        default: undefined;
    };
    border: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tabindex: (NumberConstructor | StringConstructor)[];
    validateEvent: {
        type: BooleanConstructor;
        default: boolean;
    };
}>> & {
    "onUpdate:modelValue"?: ((val: CheckboxValueType) => any) | undefined;
    onChange?: ((val: CheckboxValueType) => any) | undefined;
}, {
    label: string | number | boolean | Record<string, any>;
    disabled: boolean;
    border: boolean;
    value: string | number | boolean | Record<string, any>;
    id: string;
    name: string;
    modelValue: string | number | boolean;
    validateEvent: boolean;
    indeterminate: boolean;
    checked: boolean;
    trueValue: string | number;
    falseValue: string | number;
    trueLabel: string | number;
    falseLabel: string | number;
}>;
declare const __VLS_component_26: DefineComponent<{
    ariaControls: StringConstructor;
    modelValue: {
        type: (BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    label: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    value: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    indeterminate: BooleanConstructor;
    disabled: BooleanConstructor;
    checked: BooleanConstructor;
    name: {
        type: StringConstructor;
        default: undefined;
    };
    trueValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    trueLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    id: {
        type: StringConstructor;
        default: undefined;
    };
    border: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tabindex: (NumberConstructor | StringConstructor)[];
    validateEvent: {
        type: BooleanConstructor;
        default: boolean;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: CheckboxValueType) => void;
    change: (val: CheckboxValueType) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    ariaControls: StringConstructor;
    modelValue: {
        type: (BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    label: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    value: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    indeterminate: BooleanConstructor;
    disabled: BooleanConstructor;
    checked: BooleanConstructor;
    name: {
        type: StringConstructor;
        default: undefined;
    };
    trueValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    trueLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    falseLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    id: {
        type: StringConstructor;
        default: undefined;
    };
    border: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tabindex: (NumberConstructor | StringConstructor)[];
    validateEvent: {
        type: BooleanConstructor;
        default: boolean;
    };
}>> & {
    "onUpdate:modelValue"?: ((val: CheckboxValueType) => any) | undefined;
    onChange?: ((val: CheckboxValueType) => any) | undefined;
}, {
    label: string | number | boolean | Record<string, any>;
    disabled: boolean;
    border: boolean;
    value: string | number | boolean | Record<string, any>;
    id: string;
    name: string;
    modelValue: string | number | boolean;
    validateEvent: boolean;
    indeterminate: boolean;
    checked: boolean;
    trueValue: string | number;
    falseValue: string | number;
    trueLabel: string | number;
    falseLabel: string | number;
}>;
declare const __VLS_component_27: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => CheckboxGroupValueType) | (() => CheckboxGroupValueType) | ((new (...args: any[]) => CheckboxGroupValueType) | (() => CheckboxGroupValueType))[], unknown, unknown, () => never[], boolean>;
    readonly disabled: BooleanConstructor;
    readonly min: NumberConstructor;
    readonly max: NumberConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fill: StringConstructor;
    readonly textColor: StringConstructor;
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: CheckboxGroupValueType) => void;
    change: (val: CheckboxValueType[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => CheckboxGroupValueType) | (() => CheckboxGroupValueType) | ((new (...args: any[]) => CheckboxGroupValueType) | (() => CheckboxGroupValueType))[], unknown, unknown, () => never[], boolean>;
    readonly disabled: BooleanConstructor;
    readonly min: NumberConstructor;
    readonly max: NumberConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fill: StringConstructor;
    readonly textColor: StringConstructor;
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((val: CheckboxGroupValueType) => any) | undefined;
    onChange?: ((val: CheckboxValueType[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly modelValue: CheckboxGroupValueType;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly tag: string;
}>;
declare const __VLS_component_28: DefineComponent<{
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly span: EpPropFinalized<NumberConstructor, unknown, unknown, 24, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly pull: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly push: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly xs: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly sm: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly md: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly lg: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly xl: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly span: EpPropFinalized<NumberConstructor, unknown, unknown, 24, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly pull: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly push: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly xs: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly sm: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly md: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly lg: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly xl: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
}>>, {
    readonly span: number;
    readonly push: number;
    readonly offset: number;
    readonly tag: string;
    readonly pull: number;
    readonly xs: EpPropMergeType<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown>;
    readonly sm: EpPropMergeType<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown>;
    readonly md: EpPropMergeType<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown>;
    readonly lg: EpPropMergeType<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown>;
    readonly xl: EpPropMergeType<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown>;
}>;
declare const __VLS_component_29: DefineComponent<{
    readonly accordion: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue) | ((new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue))[], unknown, unknown, () => [
    ], boolean>;
    readonly expandIconPosition: EpPropFinalized<(new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType) | ((new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType))[], unknown, unknown, "right", boolean>;
    readonly beforeCollapse: {
        readonly type: PropType<(name: CollapseActiveName) => Awaitable<boolean>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description active names */
    activeNames: Ref<(string | number)[]>;
    /** @description set active names */
    setActiveNames: (_activeNames: CollapseActiveName[]) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: CollapseModelValue) => void;
    change: (value: CollapseModelValue) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly accordion: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue) | ((new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue))[], unknown, unknown, () => [
    ], boolean>;
    readonly expandIconPosition: EpPropFinalized<(new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType) | ((new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType))[], unknown, unknown, "right", boolean>;
    readonly beforeCollapse: {
        readonly type: PropType<(name: CollapseActiveName) => Awaitable<boolean>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:modelValue"?: ((value: CollapseModelValue) => any) | undefined;
    onChange?: ((value: CollapseModelValue) => any) | undefined;
}, {
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue) | ((new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue))[], unknown, unknown>;
    readonly expandIconPosition: EpPropMergeType<(new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType) | ((new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType))[], unknown, unknown>;
    readonly accordion: boolean;
}>;
declare const __VLS_component_3: DefineComponent<{
    readonly valueKey: EpPropFinalized<StringConstructor, unknown, unknown, "value", boolean>;
    readonly modelValue: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly debounce: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], "top" | "bottom" | "top-start" | "top-end" | "bottom-start" | "bottom-end", unknown, "bottom-start", boolean>;
    readonly fetchSuggestions: EpPropFinalized<(new (...args: any[]) => AutocompleteData | ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void)) | (() => AutocompleteFetchSuggestions) | ((new (...args: any[]) => AutocompleteData | ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void)) | (() => AutocompleteFetchSuggestions))[], unknown, unknown, () => void, boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly triggerOnFocus: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly selectWhenUnmatched: BooleanConstructor;
    readonly hideLoading: BooleanConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly highlightFirstItem: BooleanConstructor;
    readonly fitInputWidth: BooleanConstructor;
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly name: StringConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    readonly resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showPassword: BooleanConstructor;
    readonly showWordLimit: BooleanConstructor;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly autofocus: BooleanConstructor;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
}, {
    /** @description the index of the currently highlighted item */
    highlightedIndex: Ref<number>;
    /** @description autocomplete whether activated */
    activated: Ref<boolean>;
    /** @description remote search loading status */
    loading: Ref<boolean>;
    /** @description el-input component instance */
    inputRef: Ref<InputInstance | undefined>;
    /** @description el-tooltip component instance */
    popperRef: Ref<TooltipInstance | undefined>;
    /** @description fetch suggestions result */
    suggestions: Ref<Record<string, any>[]>;
    /** @description triggers when a suggestion is clicked */
    handleSelect: (item: any) => Promise<void>;
    /** @description handle keyboard enter event */
    handleKeyEnter: () => Promise<void>;
    /** @description focus the input element */
    focus: () => void;
    /** @description blur the input element */
    blur: () => void;
    /** @description close suggestion */
    close: () => void;
    /** @description highlight an item in a suggestion */
    highlight: (index: number) => void;
    /** @description loading suggestion list */
    getData: (queryString: string) => Promise<void>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    select: (item: Record<string, any>) => void;
    clear: () => void;
    "update:modelValue": (value: string) => void;
    change: (value: string) => void;
    input: (value: string) => void;
    blur: (evt: FocusEvent) => void;
    focus: (evt: FocusEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly valueKey: EpPropFinalized<StringConstructor, unknown, unknown, "value", boolean>;
    readonly modelValue: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly debounce: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], "top" | "bottom" | "top-start" | "top-end" | "bottom-start" | "bottom-end", unknown, "bottom-start", boolean>;
    readonly fetchSuggestions: EpPropFinalized<(new (...args: any[]) => AutocompleteData | ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void)) | (() => AutocompleteFetchSuggestions) | ((new (...args: any[]) => AutocompleteData | ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void)) | (() => AutocompleteFetchSuggestions))[], unknown, unknown, () => void, boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly triggerOnFocus: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly selectWhenUnmatched: BooleanConstructor;
    readonly hideLoading: BooleanConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly highlightFirstItem: BooleanConstructor;
    readonly fitInputWidth: BooleanConstructor;
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly name: StringConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    readonly resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showPassword: BooleanConstructor;
    readonly showWordLimit: BooleanConstructor;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly autofocus: BooleanConstructor;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: string) => any) | undefined;
    onChange?: ((value: string) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onInput?: ((value: string) => any) | undefined;
    onSelect?: ((item: Record<string, any>) => any) | undefined;
    onClear?: (() => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly id: string;
    readonly type: string;
    readonly modelValue: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], "top" | "bottom" | "top-start" | "top-end" | "bottom-start" | "bottom-end", unknown>;
    readonly tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly readonly: boolean;
    readonly autosize: InputAutoSize;
    readonly autocomplete: string;
    readonly containerRole: string;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly inputStyle: StyleValue;
    readonly rows: number;
    readonly inputmode: EpPropMergeType<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown>;
    readonly clearable: boolean;
    readonly showPassword: boolean;
    readonly showWordLimit: boolean;
    readonly autofocus: boolean;
    readonly popperClass: string;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly valueKey: string;
    readonly debounce: number;
    readonly fetchSuggestions: AutocompleteFetchSuggestions;
    readonly triggerOnFocus: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly selectWhenUnmatched: boolean;
    readonly hideLoading: boolean;
    readonly highlightFirstItem: boolean;
    readonly fitInputWidth: boolean;
}>;
declare const __VLS_component_30: DefineComponent<{
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: EpPropFinalized<(new (...args: any[]) => string | number) | (() => CollapseActiveName) | ((new (...args: any[]) => string | number) | (() => CollapseActiveName))[], unknown, unknown, undefined, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
}, {
    /** @description current collapse-item whether active */
    isActive: ComputedRef<boolean | undefined>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: EpPropFinalized<(new (...args: any[]) => string | number) | (() => CollapseActiveName) | ((new (...args: any[]) => string | number) | (() => CollapseActiveName))[], unknown, unknown, undefined, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
}>>, {
    readonly title: string;
    readonly disabled: boolean;
    readonly name: EpPropMergeType<(new (...args: any[]) => string | number) | (() => CollapseActiveName) | ((new (...args: any[]) => string | number) | (() => CollapseActiveName))[], unknown, unknown>;
}>;
declare const __VLS_component_31: DefineComponent<{}, {}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
declare const __VLS_component_32: DefineComponent<{
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, undefined, boolean>;
    readonly border: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showAlpha: BooleanConstructor;
    readonly colorFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly predefine: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /**
    * @description current color object
    */
    color: Color;
    /**
    * @description custom input ref
    */
    inputRef: Ref<InputInstance | undefined>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: string | null) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, undefined, boolean>;
    readonly border: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showAlpha: BooleanConstructor;
    readonly colorFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly predefine: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:modelValue"?: ((val: string | null) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly border: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>;
    readonly showAlpha: boolean;
}>;
declare const __VLS_component_33: DefineComponent<{
    /**
    * @description layout direction for child elements
    */
    direction: {
        type: StringConstructor;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    /**
    * @description layout direction for child elements
    */
    direction: {
        type: StringConstructor;
    };
}>>, {}>;
declare const __VLS_component_34: DefineComponent<{
    /**
    * @description width of the side section
    */
    width: {
        type: StringConstructor;
        default: null;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    /**
    * @description width of the side section
    */
    width: {
        type: StringConstructor;
        default: null;
    };
}>>, {
    width: string;
}>;
declare const __VLS_component_35: DefineComponent<{
    /**
    * @description height of the footer
    */
    height: {
        type: StringConstructor;
        default: null;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    /**
    * @description height of the footer
    */
    height: {
        type: StringConstructor;
        default: null;
    };
}>>, {
    height: string;
}>;
declare const __VLS_component_36: DefineComponent<{
    /**
    * @description height of the header
    */
    height: {
        type: StringConstructor;
        default: null;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    /**
    * @description height of the header
    */
    height: {
        type: StringConstructor;
        default: null;
    };
}>>, {
    height: string;
}>;
declare const __VLS_component_37: DefineComponent<{}, {}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
declare const __VLS_component_38: DefineComponent<{
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "HH:mm:ss", boolean>;
    readonly prefix: StringConstructor;
    readonly suffix: StringConstructor;
    readonly title: StringConstructor;
    readonly value: EpPropFinalized<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown, 0, boolean>;
    readonly valueStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /**
    * @description current display value
    */
    displayValue: ComputedRef<string>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    change: (value: number) => void;
    finish: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "HH:mm:ss", boolean>;
    readonly prefix: StringConstructor;
    readonly suffix: StringConstructor;
    readonly title: StringConstructor;
    readonly value: EpPropFinalized<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown, 0, boolean>;
    readonly valueStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onChange?: ((value: number) => any) | undefined;
    onFinish?: (() => any) | undefined;
}, {
    readonly value: EpPropMergeType<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown>;
    readonly format: string;
}>;
declare const __VLS_component_39: DefineComponent<{
    readonly border: BooleanConstructor;
    readonly column: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly extra: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly border: BooleanConstructor;
    readonly column: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly extra: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
}>>, {
    readonly title: string;
    readonly direction: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly border: boolean;
    readonly column: number;
    readonly labelWidth: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly extra: string;
}>;
declare const __VLS_component_4: DefineComponent<{
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly name: StringConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number | null | undefined) | ((new (...args: any[]) => string | number) | (() => string | number | null | undefined))[], unknown, unknown, "", boolean>;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    readonly resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showPassword: BooleanConstructor;
    readonly showWordLimit: BooleanConstructor;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly autofocus: BooleanConstructor;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
}, {
    /** @description HTML input element */
    input: ShallowRef<HTMLInputElement | undefined>;
    /** @description HTML textarea element */
    textarea: ShallowRef<HTMLTextAreaElement | undefined>;
    /** @description HTML element, input or textarea */
    ref: ComputedRef<HTMLInputElement | HTMLTextAreaElement | undefined>;
    /** @description style of textarea. */
    textareaStyle: ComputedRef<StyleValue>;
    /** @description from props (used on unit test) */
    autosize: Ref<InputAutoSize>;
    /** @description is input composing */
    isComposing: Ref<boolean>;
    /** @description HTML input element native method */
    focus: () => void | undefined;
    /** @description HTML input element native method */
    blur: () => void | undefined;
    /** @description HTML input element native method */
    select: () => void;
    /** @description clear input value */
    clear: () => void;
    /** @description resize textarea. */
    resizeTextarea: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    input: (value: string) => void;
    clear: () => void;
    "update:modelValue": (value: string) => void;
    change: (value: string) => void;
    blur: (evt: FocusEvent) => void;
    compositionend: (evt: CompositionEvent) => void;
    compositionstart: (evt: CompositionEvent) => void;
    compositionupdate: (evt: CompositionEvent) => void;
    focus: (evt: FocusEvent) => void;
    keydown: (evt: Event | KeyboardEvent) => void;
    mouseenter: (evt: MouseEvent) => void;
    mouseleave: (evt: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly name: StringConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number | null | undefined) | ((new (...args: any[]) => string | number) | (() => string | number | null | undefined))[], unknown, unknown, "", boolean>;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    readonly resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showPassword: BooleanConstructor;
    readonly showWordLimit: BooleanConstructor;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly autofocus: BooleanConstructor;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: string) => any) | undefined;
    onChange?: ((value: string) => any) | undefined;
    onCompositionend?: ((evt: CompositionEvent) => any) | undefined;
    onCompositionstart?: ((evt: CompositionEvent) => any) | undefined;
    onCompositionupdate?: ((evt: CompositionEvent) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onInput?: ((value: string) => any) | undefined;
    onKeydown?: ((evt: Event | KeyboardEvent) => any) | undefined;
    onMouseenter?: ((evt: MouseEvent) => any) | undefined;
    onMouseleave?: ((evt: MouseEvent) => any) | undefined;
    onClear?: (() => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly id: string;
    readonly type: string;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number | null | undefined) | ((new (...args: any[]) => string | number) | (() => string | number | null | undefined))[], unknown, unknown>;
    readonly tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly readonly: boolean;
    readonly autosize: InputAutoSize;
    readonly autocomplete: string;
    readonly containerRole: string;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly inputStyle: StyleValue;
    readonly rows: number;
    readonly inputmode: EpPropMergeType<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown>;
    readonly clearable: boolean;
    readonly showPassword: boolean;
    readonly showWordLimit: boolean;
    readonly autofocus: boolean;
}>;
declare const __VLS_component_40: DefineComponent<{
    readonly appendToBody: BooleanConstructor;
    readonly appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, "body", boolean>;
    readonly beforeClose: {
        readonly type: PropType<DialogBeforeCloseFn>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly destroyOnClose: BooleanConstructor;
    readonly closeOnClickModal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly lockScroll: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalPenetrable: BooleanConstructor;
    readonly openDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly closeDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly top: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: BooleanConstructor;
    readonly modalClass: StringConstructor;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly trapFocus: BooleanConstructor;
    readonly headerAriaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
    readonly transition: EpPropFinalized<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown, undefined, boolean>;
    readonly center: BooleanConstructor;
    readonly alignCenter: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly draggable: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly overflow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly fullscreen: BooleanConstructor;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly ariaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
}, {
    /** @description whether the dialog is visible */
    visible: Ref<boolean>;
    dialogContentRef: Ref<any>;
    resetPosition: () => void;
    handleClose: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    open: () => void;
    "update:modelValue": (value: boolean) => void;
    close: () => void;
    opened: () => void;
    closed: () => void;
    openAutoFocus: () => void;
    closeAutoFocus: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly appendToBody: BooleanConstructor;
    readonly appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, "body", boolean>;
    readonly beforeClose: {
        readonly type: PropType<DialogBeforeCloseFn>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly destroyOnClose: BooleanConstructor;
    readonly closeOnClickModal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly lockScroll: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalPenetrable: BooleanConstructor;
    readonly openDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly closeDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly top: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: BooleanConstructor;
    readonly modalClass: StringConstructor;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly trapFocus: BooleanConstructor;
    readonly headerAriaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
    readonly transition: EpPropFinalized<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown, undefined, boolean>;
    readonly center: BooleanConstructor;
    readonly alignCenter: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly draggable: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly overflow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly fullscreen: BooleanConstructor;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly ariaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: boolean) => any) | undefined;
    onOpen?: (() => any) | undefined;
    onClose?: (() => any) | undefined;
    onOpened?: (() => any) | undefined;
    onClosed?: (() => any) | undefined;
    onOpenAutoFocus?: (() => any) | undefined;
    onCloseAutoFocus?: (() => any) | undefined;
}, {
    readonly title: string;
    readonly center: boolean;
    readonly overflow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly transition: EpPropMergeType<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown>;
    readonly modelValue: boolean;
    readonly ariaLevel: string;
    readonly appendTo: EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>;
    readonly alignCenter: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly draggable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showClose: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly fullscreen: boolean;
    readonly closeOnClickModal: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly closeOnPressEscape: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly lockScroll: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly modal: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly openDelay: number;
    readonly closeDelay: number;
    readonly headerAriaLevel: string;
    readonly appendToBody: boolean;
    readonly destroyOnClose: boolean;
    readonly modalPenetrable: boolean;
    readonly trapFocus: boolean;
}>;
declare const __VLS_component_41: DefineComponent<{
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly contentPosition: EpPropFinalized<StringConstructor, "center" | "left" | "right", unknown, "center", boolean>;
    readonly borderStyle: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "solid", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly contentPosition: EpPropFinalized<StringConstructor, "center" | "left" | "right", unknown, "center", boolean>;
    readonly borderStyle: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "solid", boolean>;
}>>, {
    readonly direction: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly borderStyle: string;
    readonly contentPosition: EpPropMergeType<StringConstructor, "center" | "left" | "right", unknown>;
}>;
declare const __VLS_component_42: DefineComponent<{
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl" | "ttb" | "btt", unknown, "rtl", boolean>;
    readonly resizable: BooleanConstructor;
    readonly size: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "30%", boolean>;
    readonly withHeader: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalFade: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly headerAriaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
    readonly appendToBody: BooleanConstructor;
    readonly appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, "body", boolean>;
    readonly beforeClose: {
        readonly type: PropType<DialogBeforeCloseFn>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly destroyOnClose: BooleanConstructor;
    readonly closeOnClickModal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly lockScroll: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalPenetrable: BooleanConstructor;
    readonly openDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly closeDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly top: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: BooleanConstructor;
    readonly modalClass: StringConstructor;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly trapFocus: BooleanConstructor;
    readonly transition: EpPropFinalized<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown, undefined, boolean>;
    readonly center: BooleanConstructor;
    readonly alignCenter: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly draggable: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly overflow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly fullscreen: BooleanConstructor;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly ariaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
}, {
    handleClose: () => void;
    afterEnter: () => void;
    afterLeave: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    open: () => void;
    "update:modelValue": (value: boolean) => void;
    close: () => void;
    opened: () => void;
    closed: () => void;
    openAutoFocus: () => void;
    closeAutoFocus: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl" | "ttb" | "btt", unknown, "rtl", boolean>;
    readonly resizable: BooleanConstructor;
    readonly size: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "30%", boolean>;
    readonly withHeader: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalFade: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly headerAriaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
    readonly appendToBody: BooleanConstructor;
    readonly appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, "body", boolean>;
    readonly beforeClose: {
        readonly type: PropType<DialogBeforeCloseFn>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly destroyOnClose: BooleanConstructor;
    readonly closeOnClickModal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly lockScroll: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalPenetrable: BooleanConstructor;
    readonly openDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly closeDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly top: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: BooleanConstructor;
    readonly modalClass: StringConstructor;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly trapFocus: BooleanConstructor;
    readonly transition: EpPropFinalized<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown, undefined, boolean>;
    readonly center: BooleanConstructor;
    readonly alignCenter: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly draggable: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly overflow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly fullscreen: BooleanConstructor;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly ariaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: boolean) => any) | undefined;
    onOpen?: (() => any) | undefined;
    onClose?: (() => any) | undefined;
    onOpened?: (() => any) | undefined;
    onClosed?: (() => any) | undefined;
    onOpenAutoFocus?: (() => any) | undefined;
    onCloseAutoFocus?: (() => any) | undefined;
}, {
    readonly title: string;
    readonly center: boolean;
    readonly direction: EpPropMergeType<StringConstructor, "ltr" | "rtl" | "ttb" | "btt", unknown>;
    readonly overflow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly transition: EpPropMergeType<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown>;
    readonly size: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly modelValue: boolean;
    readonly ariaLevel: string;
    readonly appendTo: EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>;
    readonly alignCenter: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly draggable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showClose: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly fullscreen: boolean;
    readonly closeOnClickModal: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly closeOnPressEscape: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly lockScroll: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly modal: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly openDelay: number;
    readonly closeDelay: number;
    readonly headerAriaLevel: string;
    readonly appendToBody: boolean;
    readonly destroyOnClose: boolean;
    readonly modalPenetrable: boolean;
    readonly trapFocus: boolean;
    readonly resizable: boolean;
    readonly withHeader: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly modalFade: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_43: DefineComponent<{
    readonly image: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly imageSize: NumberConstructor;
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly image: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly imageSize: NumberConstructor;
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
}>>, {
    readonly image: string;
    readonly description: string;
}>;
declare const __VLS_component_44: DefineComponent<{
    readonly model: ObjectConstructor;
    readonly rules: {
        readonly type: PropType<Partial<Record<string, Arrayable<FormItemRule>>>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly labelPosition: EpPropFinalized<StringConstructor, "top" | "left" | "right", unknown, "right", boolean>;
    readonly requireAsteriskPosition: EpPropFinalized<StringConstructor, "left" | "right", unknown, "left", boolean>;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly labelSuffix: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly inline: BooleanConstructor;
    readonly inlineMessage: BooleanConstructor;
    readonly statusIcon: BooleanConstructor;
    readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly validateOnRuleChange: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly hideRequiredAsterisk: BooleanConstructor;
    readonly scrollToError: BooleanConstructor;
    readonly scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
}, {
    /**
    * @description Validate the whole form. Receives a callback or returns `Promise`.
    */
    validate: (callback?: FormValidateCallback) => FormValidationResult;
    /**
    * @description Validate specified fields.
    */
    validateField: (props?: Arrayable<FormItemProp>, callback?: FormValidateCallback) => FormValidationResult;
    /**
    * @description Reset specified fields and remove validation result.
    */
    resetFields: (props?: Arrayable<FormItemProp>) => void;
    /**
    * @description Clear validation message for specified fields.
    */
    clearValidate: (props?: Arrayable<FormItemProp>) => void;
    /**
    * @description Scroll to the specified fields.
    */
    scrollToField: (prop: FormItemProp) => void;
    /**
    * @description Get a field context.
    */
    getField: (prop: FormItemProp) => FormItemContext | undefined;
    /**
    * @description All fields context.
    */
    fields: {
        $el: HTMLDivElement | undefined;
        size: ComponentSize;
        validateMessage: string;
        validateState: FormItemValidateState;
        isGroup: boolean;
        labelId: string;
        inputIds: string[];
        hasLabel: boolean;
        fieldValue: any;
        propString: string;
        addInputId: (id: string) => void;
        removeInputId: (id: string) => void;
        validate: (trigger: string, callback?: FormValidateCallback) => FormValidationResult;
        resetField: () => void;
        clearValidate: () => void;
        readonly labelWidth: EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>;
        readonly labelPosition: EpPropMergeType<StringConstructor, "" | "top" | "left" | "right", unknown>;
        readonly inlineMessage: EpPropMergeType<readonly [
            StringConstructor,
            BooleanConstructor
        ], unknown, unknown>;
        readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly label?: string | undefined;
        readonly prop?: EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown> | undefined;
        readonly required?: EpPropMergeType<BooleanConstructor, unknown, unknown> | undefined;
        readonly error?: string | undefined;
        readonly rules?: {
            trigger?: Arrayable<string> | undefined;
            type?: RuleType | undefined;
            required?: boolean | undefined;
            pattern?: string | {
                exec: (string: string) => RegExpExecArray | null;
                test: (string: string) => boolean;
                readonly source: string;
                readonly global: boolean;
                readonly ignoreCase: boolean;
                readonly multiline: boolean;
                lastIndex: number;
                compile: (pattern: string, flags?: string) => RegExp;
                readonly flags: string;
                readonly sticky: boolean;
                readonly unicode: boolean;
                readonly dotAll: boolean;
                [Symbol.match]: (string: string) => RegExpMatchArray | null;
                [Symbol.replace]: {
                    (string: string, replaceValue: string): string;
                    (string: string, replacer: (substring: string, ...args: any[]) => string): string;
                };
                [Symbol.search]: (string: string) => number;
                [Symbol.split]: (string: string, limit?: number) => string[];
            } | undefined;
            min?: number | undefined;
            max?: number | undefined;
            len?: number | undefined;
            enum?: Array<string | number | boolean | null | undefined> | undefined;
            whitespace?: boolean | undefined;
            fields?: Record<string, Rule> | undefined;
            options?: {
                suppressWarning?: boolean | undefined;
                suppressValidatorError?: boolean | undefined;
                first?: boolean | undefined;
                firstFields?: (boolean | string[]) | undefined;
                messages?: {
                    default?: (string | ((...args: unknown[]) => string)) | undefined;
                    required?: (string | ((args_0: string | undefined) => string)) | undefined;
                    enum?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                    whitespace?: (string | ((args_0: string | undefined) => string)) | undefined;
                    date?: {
                        format?: (string | ((...args: unknown[]) => string)) | undefined;
                        parse?: (string | ((...args: unknown[]) => string)) | undefined;
                        invalid?: (string | ((...args: unknown[]) => string)) | undefined;
                    } | undefined;
                    types?: {
                        string?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        method?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        array?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        object?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        number?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        date?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        boolean?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        integer?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        float?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        regexp?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        email?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        url?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        hex?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                    } | undefined;
                    string?: {
                        len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                    } | undefined;
                    number?: {
                        len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                    } | undefined;
                    array?: {
                        len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                    } | undefined;
                    pattern?: {
                        mismatch?: (string | ((args_0: string | undefined, args_1: any, args_2: string | RegExp | undefined) => string)) | undefined;
                    } | undefined;
                } | undefined;
                keys?: string[] | undefined;
                error?: ((rule: InternalRuleItem, message: string) => ValidateError) | undefined;
            } | undefined;
            defaultField?: {
                type?: RuleType | undefined;
                required?: boolean | undefined;
                pattern?: string | {
                    exec: (string: string) => RegExpExecArray | null;
                    test: (string: string) => boolean;
                    readonly source: string;
                    readonly global: boolean;
                    readonly ignoreCase: boolean;
                    readonly multiline: boolean;
                    lastIndex: number;
                    compile: (pattern: string, flags?: string) => RegExp;
                    readonly flags: string;
                    readonly sticky: boolean;
                    readonly unicode: boolean;
                    readonly dotAll: boolean;
                    [Symbol.match]: (string: string) => RegExpMatchArray | null;
                    [Symbol.replace]: {
                        (string: string, replaceValue: string): string;
                        (string: string, replacer: (substring: string, ...args: any[]) => string): string;
                    };
                    [Symbol.search]: (string: string) => number;
                    [Symbol.split]: (string: string, limit?: number) => string[];
                } | undefined;
                min?: number | undefined;
                max?: number | undefined;
                len?: number | undefined;
                enum?: Array<string | number | boolean | null | undefined> | undefined;
                whitespace?: boolean | undefined;
                fields?: Record<string, Rule> | undefined;
                options?: {
                    suppressWarning?: boolean | undefined;
                    suppressValidatorError?: boolean | undefined;
                    first?: boolean | undefined;
                    firstFields?: (boolean | string[]) | undefined;
                    messages?: {
                        default?: (string | ((...args: unknown[]) => string)) | undefined;
                        required?: (string | ((args_0: string | undefined) => string)) | undefined;
                        enum?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        whitespace?: (string | ((args_0: string | undefined) => string)) | undefined;
                        date?: {
                            format?: (string | ((...args: unknown[]) => string)) | undefined;
                            parse?: (string | ((...args: unknown[]) => string)) | undefined;
                            invalid?: (string | ((...args: unknown[]) => string)) | undefined;
                        } | undefined;
                        types?: {
                            string?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            method?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            array?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            object?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            number?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            date?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            boolean?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            integer?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            float?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            regexp?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            email?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            url?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            hex?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        } | undefined;
                        string?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        number?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        array?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        pattern?: {
                            mismatch?: (string | ((args_0: string | undefined, args_1: any, args_2: string | RegExp | undefined) => string)) | undefined;
                        } | undefined;
                    } | undefined;
                    keys?: string[] | undefined;
                    error?: ((rule: InternalRuleItem, message: string) => ValidateError) | undefined;
                } | undefined;
                defaultField?: any | any[] | undefined;
                transform?: ((value: Value_2) => Value_2) | undefined;
                message?: (string | ((a?: string) => string)) | undefined;
                asyncValidator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => void | Promise<void>) | undefined;
                validator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => SyncValidateResult | void) | undefined;
            } | {
                type?: RuleType | undefined;
                required?: boolean | undefined;
                pattern?: string | {
                    exec: (string: string) => RegExpExecArray | null;
                    test: (string: string) => boolean;
                    readonly source: string;
                    readonly global: boolean;
                    readonly ignoreCase: boolean;
                    readonly multiline: boolean;
                    lastIndex: number;
                    compile: (pattern: string, flags?: string) => RegExp;
                    readonly flags: string;
                    readonly sticky: boolean;
                    readonly unicode: boolean;
                    readonly dotAll: boolean;
                    [Symbol.match]: (string: string) => RegExpMatchArray | null;
                    [Symbol.replace]: {
                        (string: string, replaceValue: string): string;
                        (string: string, replacer: (substring: string, ...args: any[]) => string): string;
                    };
                    [Symbol.search]: (string: string) => number;
                    [Symbol.split]: (string: string, limit?: number) => string[];
                } | undefined;
                min?: number | undefined;
                max?: number | undefined;
                len?: number | undefined;
                enum?: Array<string | number | boolean | null | undefined> | undefined;
                whitespace?: boolean | undefined;
                fields?: Record<string, Rule> | undefined;
                options?: {
                    suppressWarning?: boolean | undefined;
                    suppressValidatorError?: boolean | undefined;
                    first?: boolean | undefined;
                    firstFields?: (boolean | string[]) | undefined;
                    messages?: {
                        default?: (string | ((...args: unknown[]) => string)) | undefined;
                        required?: (string | ((args_0: string | undefined) => string)) | undefined;
                        enum?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        whitespace?: (string | ((args_0: string | undefined) => string)) | undefined;
                        date?: {
                            format?: (string | ((...args: unknown[]) => string)) | undefined;
                            parse?: (string | ((...args: unknown[]) => string)) | undefined;
                            invalid?: (string | ((...args: unknown[]) => string)) | undefined;
                        } | undefined;
                        types?: {
                            string?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            method?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            array?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            object?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            number?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            date?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            boolean?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            integer?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            float?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            regexp?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            email?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            url?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            hex?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        } | undefined;
                        string?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        number?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        array?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        pattern?: {
                            mismatch?: (string | ((args_0: string | undefined, args_1: any, args_2: string | RegExp | undefined) => string)) | undefined;
                        } | undefined;
                    } | undefined;
                    keys?: string[] | undefined;
                    error?: ((rule: InternalRuleItem, message: string) => ValidateError) | undefined;
                } | undefined;
                defaultField?: any | any[] | undefined;
                transform?: ((value: Value_2) => Value_2) | undefined;
                message?: (string | ((a?: string) => string)) | undefined;
                asyncValidator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => void | Promise<void>) | undefined;
                validator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => SyncValidateResult | void) | undefined;
            }[] | undefined;
            transform?: ((value: Value_2) => Value_2) | undefined;
            message?: (string | ((a?: string) => string)) | undefined;
            asyncValidator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => void | Promise<void>) | undefined;
            validator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => SyncValidateResult | void) | undefined;
        } | {
            trigger?: Arrayable<string> | undefined;
            type?: RuleType | undefined;
            required?: boolean | undefined;
            pattern?: string | {
                exec: (string: string) => RegExpExecArray | null;
                test: (string: string) => boolean;
                readonly source: string;
                readonly global: boolean;
                readonly ignoreCase: boolean;
                readonly multiline: boolean;
                lastIndex: number;
                compile: (pattern: string, flags?: string) => RegExp;
                readonly flags: string;
                readonly sticky: boolean;
                readonly unicode: boolean;
                readonly dotAll: boolean;
                [Symbol.match]: (string: string) => RegExpMatchArray | null;
                [Symbol.replace]: {
                    (string: string, replaceValue: string): string;
                    (string: string, replacer: (substring: string, ...args: any[]) => string): string;
                };
                [Symbol.search]: (string: string) => number;
                [Symbol.split]: (string: string, limit?: number) => string[];
            } | undefined;
            min?: number | undefined;
            max?: number | undefined;
            len?: number | undefined;
            enum?: Array<string | number | boolean | null | undefined> | undefined;
            whitespace?: boolean | undefined;
            fields?: Record<string, Rule> | undefined;
            options?: {
                suppressWarning?: boolean | undefined;
                suppressValidatorError?: boolean | undefined;
                first?: boolean | undefined;
                firstFields?: (boolean | string[]) | undefined;
                messages?: {
                    default?: (string | ((...args: unknown[]) => string)) | undefined;
                    required?: (string | ((args_0: string | undefined) => string)) | undefined;
                    enum?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                    whitespace?: (string | ((args_0: string | undefined) => string)) | undefined;
                    date?: {
                        format?: (string | ((...args: unknown[]) => string)) | undefined;
                        parse?: (string | ((...args: unknown[]) => string)) | undefined;
                        invalid?: (string | ((...args: unknown[]) => string)) | undefined;
                    } | undefined;
                    types?: {
                        string?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        method?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        array?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        object?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        number?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        date?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        boolean?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        integer?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        float?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        regexp?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        email?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        url?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        hex?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                    } | undefined;
                    string?: {
                        len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                    } | undefined;
                    number?: {
                        len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                    } | undefined;
                    array?: {
                        len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                        range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                    } | undefined;
                    pattern?: {
                        mismatch?: (string | ((args_0: string | undefined, args_1: any, args_2: string | RegExp | undefined) => string)) | undefined;
                    } | undefined;
                } | undefined;
                keys?: string[] | undefined;
                error?: ((rule: InternalRuleItem, message: string) => ValidateError) | undefined;
            } | undefined;
            defaultField?: {
                type?: RuleType | undefined;
                required?: boolean | undefined;
                pattern?: string | {
                    exec: (string: string) => RegExpExecArray | null;
                    test: (string: string) => boolean;
                    readonly source: string;
                    readonly global: boolean;
                    readonly ignoreCase: boolean;
                    readonly multiline: boolean;
                    lastIndex: number;
                    compile: (pattern: string, flags?: string) => RegExp;
                    readonly flags: string;
                    readonly sticky: boolean;
                    readonly unicode: boolean;
                    readonly dotAll: boolean;
                    [Symbol.match]: (string: string) => RegExpMatchArray | null;
                    [Symbol.replace]: {
                        (string: string, replaceValue: string): string;
                        (string: string, replacer: (substring: string, ...args: any[]) => string): string;
                    };
                    [Symbol.search]: (string: string) => number;
                    [Symbol.split]: (string: string, limit?: number) => string[];
                } | undefined;
                min?: number | undefined;
                max?: number | undefined;
                len?: number | undefined;
                enum?: Array<string | number | boolean | null | undefined> | undefined;
                whitespace?: boolean | undefined;
                fields?: Record<string, Rule> | undefined;
                options?: {
                    suppressWarning?: boolean | undefined;
                    suppressValidatorError?: boolean | undefined;
                    first?: boolean | undefined;
                    firstFields?: (boolean | string[]) | undefined;
                    messages?: {
                        default?: (string | ((...args: unknown[]) => string)) | undefined;
                        required?: (string | ((args_0: string | undefined) => string)) | undefined;
                        enum?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        whitespace?: (string | ((args_0: string | undefined) => string)) | undefined;
                        date?: {
                            format?: (string | ((...args: unknown[]) => string)) | undefined;
                            parse?: (string | ((...args: unknown[]) => string)) | undefined;
                            invalid?: (string | ((...args: unknown[]) => string)) | undefined;
                        } | undefined;
                        types?: {
                            string?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            method?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            array?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            object?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            number?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            date?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            boolean?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            integer?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            float?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            regexp?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            email?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            url?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            hex?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        } | undefined;
                        string?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        number?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        array?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        pattern?: {
                            mismatch?: (string | ((args_0: string | undefined, args_1: any, args_2: string | RegExp | undefined) => string)) | undefined;
                        } | undefined;
                    } | undefined;
                    keys?: string[] | undefined;
                    error?: ((rule: InternalRuleItem, message: string) => ValidateError) | undefined;
                } | undefined;
                defaultField?: any | any[] | undefined;
                transform?: ((value: Value_2) => Value_2) | undefined;
                message?: (string | ((a?: string) => string)) | undefined;
                asyncValidator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => void | Promise<void>) | undefined;
                validator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => SyncValidateResult | void) | undefined;
            } | {
                type?: RuleType | undefined;
                required?: boolean | undefined;
                pattern?: string | {
                    exec: (string: string) => RegExpExecArray | null;
                    test: (string: string) => boolean;
                    readonly source: string;
                    readonly global: boolean;
                    readonly ignoreCase: boolean;
                    readonly multiline: boolean;
                    lastIndex: number;
                    compile: (pattern: string, flags?: string) => RegExp;
                    readonly flags: string;
                    readonly sticky: boolean;
                    readonly unicode: boolean;
                    readonly dotAll: boolean;
                    [Symbol.match]: (string: string) => RegExpMatchArray | null;
                    [Symbol.replace]: {
                        (string: string, replaceValue: string): string;
                        (string: string, replacer: (substring: string, ...args: any[]) => string): string;
                    };
                    [Symbol.search]: (string: string) => number;
                    [Symbol.split]: (string: string, limit?: number) => string[];
                } | undefined;
                min?: number | undefined;
                max?: number | undefined;
                len?: number | undefined;
                enum?: Array<string | number | boolean | null | undefined> | undefined;
                whitespace?: boolean | undefined;
                fields?: Record<string, Rule> | undefined;
                options?: {
                    suppressWarning?: boolean | undefined;
                    suppressValidatorError?: boolean | undefined;
                    first?: boolean | undefined;
                    firstFields?: (boolean | string[]) | undefined;
                    messages?: {
                        default?: (string | ((...args: unknown[]) => string)) | undefined;
                        required?: (string | ((args_0: string | undefined) => string)) | undefined;
                        enum?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        whitespace?: (string | ((args_0: string | undefined) => string)) | undefined;
                        date?: {
                            format?: (string | ((...args: unknown[]) => string)) | undefined;
                            parse?: (string | ((...args: unknown[]) => string)) | undefined;
                            invalid?: (string | ((...args: unknown[]) => string)) | undefined;
                        } | undefined;
                        types?: {
                            string?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            method?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            array?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            object?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            number?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            date?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            boolean?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            integer?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            float?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            regexp?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            email?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            url?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                            hex?: (string | ((args_0: string | undefined, args_1: string | undefined) => string)) | undefined;
                        } | undefined;
                        string?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        number?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        array?: {
                            len?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            min?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            max?: (string | ((args_0: string | undefined, args_1: number | undefined) => string)) | undefined;
                            range?: (string | ((args_0: string | undefined, args_1: number | undefined, args_2: number | undefined) => string)) | undefined;
                        } | undefined;
                        pattern?: {
                            mismatch?: (string | ((args_0: string | undefined, args_1: any, args_2: string | RegExp | undefined) => string)) | undefined;
                        } | undefined;
                    } | undefined;
                    keys?: string[] | undefined;
                    error?: ((rule: InternalRuleItem, message: string) => ValidateError) | undefined;
                } | undefined;
                defaultField?: any | any[] | undefined;
                transform?: ((value: Value_2) => Value_2) | undefined;
                message?: (string | ((a?: string) => string)) | undefined;
                asyncValidator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => void | Promise<void>) | undefined;
                validator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => SyncValidateResult | void) | undefined;
            }[] | undefined;
            transform?: ((value: Value_2) => Value_2) | undefined;
            message?: (string | ((a?: string) => string)) | undefined;
            asyncValidator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => void | Promise<void>) | undefined;
            validator?: ((rule: InternalRuleItem, value: Value_2, callback: (error?: string | Error) => void, source: Values, options: ValidateOption) => SyncValidateResult | void) | undefined;
        }[] | undefined;
        readonly validateStatus?: EpPropMergeType<StringConstructor, "" | "error" | "success" | "validating", unknown> | undefined;
        readonly for?: string | undefined;
    }[];
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    validate: (prop: FormItemProp, isValid: boolean, message: string) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly model: ObjectConstructor;
    readonly rules: {
        readonly type: PropType<Partial<Record<string, Arrayable<FormItemRule>>>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly labelPosition: EpPropFinalized<StringConstructor, "top" | "left" | "right", unknown, "right", boolean>;
    readonly requireAsteriskPosition: EpPropFinalized<StringConstructor, "left" | "right", unknown, "left", boolean>;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly labelSuffix: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly inline: BooleanConstructor;
    readonly inlineMessage: BooleanConstructor;
    readonly statusIcon: BooleanConstructor;
    readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly validateOnRuleChange: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly hideRequiredAsterisk: BooleanConstructor;
    readonly scrollToError: BooleanConstructor;
    readonly scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
}>> & {
    onValidate?: ((prop: FormItemProp, isValid: boolean, message: string) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly inline: boolean;
    readonly labelWidth: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly labelPosition: EpPropMergeType<StringConstructor, "top" | "left" | "right", unknown>;
    readonly inlineMessage: boolean;
    readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly requireAsteriskPosition: EpPropMergeType<StringConstructor, "left" | "right", unknown>;
    readonly labelSuffix: string;
    readonly validateOnRuleChange: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly scrollIntoViewOptions: EpPropMergeType<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown>;
    readonly statusIcon: boolean;
    readonly hideRequiredAsterisk: boolean;
    readonly scrollToError: boolean;
}>;
declare const __VLS_component_45: DefineComponent<{
    readonly label: StringConstructor;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly labelPosition: EpPropFinalized<StringConstructor, "" | "top" | "left" | "right", unknown, "", boolean>;
    readonly prop: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly rules: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly error: StringConstructor;
    readonly validateStatus: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "error" | "success" | "validating", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly for: StringConstructor;
    readonly inlineMessage: EpPropFinalized<readonly [
        StringConstructor,
        BooleanConstructor
    ], unknown, unknown, "", boolean>;
    readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /**
    * @description Form item size.
    */
    size: ComputedRef<"" | "small" | "default" | "large">;
    /**
    * @description Validation message.
    */
    validateMessage: Ref<string>;
    /**
    * @description Validation state.
    */
    validateState: Ref<"" | "error" | "success" | "validating">;
    /**
    * @description Validate form item.
    */
    validate: (trigger: string, callback?: FormValidateCallback) => FormValidationResult;
    /**
    * @description Remove validation status of the field.
    */
    clearValidate: () => void;
    /**
    * @description Reset current field and remove validation result.
    */
    resetField: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly label: StringConstructor;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly labelPosition: EpPropFinalized<StringConstructor, "" | "top" | "left" | "right", unknown, "", boolean>;
    readonly prop: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly rules: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly error: StringConstructor;
    readonly validateStatus: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "error" | "success" | "validating", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly for: StringConstructor;
    readonly inlineMessage: EpPropFinalized<readonly [
        StringConstructor,
        BooleanConstructor
    ], unknown, unknown, "", boolean>;
    readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly labelWidth: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly labelPosition: EpPropMergeType<StringConstructor, "" | "top" | "left" | "right", unknown>;
    readonly inlineMessage: EpPropMergeType<readonly [
        StringConstructor,
        BooleanConstructor
    ], unknown, unknown>;
    readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_46: DefineComponent<{
    readonly size: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly color: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly size: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly color: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {}>;
declare const __VLS_component_47: DefineComponent<{
    readonly hideOnClickModal: BooleanConstructor;
    readonly src: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fit: EpPropFinalized<StringConstructor, "" | "fill" | "contain" | "none" | "cover" | "scale-down", unknown, "", boolean>;
    readonly loading: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "lazy" | "eager", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly lazy: BooleanConstructor;
    readonly scrollContainer: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement | undefined) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement | undefined))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly previewSrcList: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly previewTeleported: BooleanConstructor;
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly infinite: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly zoomRate: EpPropFinalized<NumberConstructor, unknown, unknown, 1.2, boolean>;
    readonly minScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.2, boolean>;
    readonly maxScale: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly showProgress: BooleanConstructor;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description manually open preview */
    showPreview: typeof clickHandler;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    switch: (val: number) => void;
    show: () => void;
    close: () => void;
    error: (evt: Event) => void;
    load: (evt: Event) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly hideOnClickModal: BooleanConstructor;
    readonly src: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fit: EpPropFinalized<StringConstructor, "" | "fill" | "contain" | "none" | "cover" | "scale-down", unknown, "", boolean>;
    readonly loading: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "lazy" | "eager", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly lazy: BooleanConstructor;
    readonly scrollContainer: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement | undefined) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement | undefined))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly previewSrcList: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly previewTeleported: BooleanConstructor;
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly infinite: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly zoomRate: EpPropFinalized<NumberConstructor, unknown, unknown, 1.2, boolean>;
    readonly minScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.2, boolean>;
    readonly maxScale: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly showProgress: BooleanConstructor;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onShow?: (() => any) | undefined;
    onLoad?: ((evt: Event) => any) | undefined;
    onError?: ((evt: Event) => any) | undefined;
    onClose?: (() => any) | undefined;
    onSwitch?: ((val: number) => any) | undefined;
}, {
    readonly infinite: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly src: string;
    readonly fit: EpPropMergeType<StringConstructor, "" | "fill" | "contain" | "none" | "cover" | "scale-down", unknown>;
    readonly closeOnPressEscape: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly initialIndex: number;
    readonly lazy: boolean;
    readonly zoomRate: number;
    readonly minScale: number;
    readonly maxScale: number;
    readonly hideOnClickModal: boolean;
    readonly showProgress: boolean;
    readonly previewSrcList: string[];
    readonly previewTeleported: boolean;
}>;
declare const __VLS_component_48: DefineComponent<{
    readonly urlList: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly infinite: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly hideOnClickModal: BooleanConstructor;
    readonly teleported: BooleanConstructor;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly zoomRate: EpPropFinalized<NumberConstructor, unknown, unknown, 1.2, boolean>;
    readonly minScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.2, boolean>;
    readonly maxScale: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly showProgress: BooleanConstructor;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /**
    * @description manually switch image
    */
    setActiveItem: typeof setActiveItem;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    switch: (index: number) => void;
    rotate: (deg: number) => void;
    close: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly urlList: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly infinite: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly hideOnClickModal: BooleanConstructor;
    readonly teleported: BooleanConstructor;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly zoomRate: EpPropFinalized<NumberConstructor, unknown, unknown, 1.2, boolean>;
    readonly minScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.2, boolean>;
    readonly maxScale: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly showProgress: BooleanConstructor;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onClose?: (() => any) | undefined;
    onSwitch?: ((index: number) => any) | undefined;
    onRotate?: ((deg: number) => any) | undefined;
}, {
    readonly infinite: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly teleported: boolean;
    readonly closeOnPressEscape: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly initialIndex: number;
    readonly urlList: string[];
    readonly zoomRate: number;
    readonly minScale: number;
    readonly maxScale: number;
    readonly hideOnClickModal: boolean;
    readonly showProgress: boolean;
}>;
declare const __VLS_component_49: DefineComponent<{
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly align: EpPropFinalized<(new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right") | ((new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right"))[], unknown, unknown, "center", boolean>;
    readonly disabledScientific: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly step: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly stepStrictly: BooleanConstructor;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly min: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly modelValue: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly controls: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly controlsPosition: EpPropFinalized<StringConstructor, "" | "right", unknown, "", boolean>;
    readonly valueOnClear: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor,
        null
    ], unknown, unknown, null, boolean>;
    readonly name: StringConstructor;
    readonly placeholder: StringConstructor;
    readonly precision: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {
    /** @description get focus the input component */
    focus: () => void;
    /** @description remove focus the input component */
    blur: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: number | undefined) => void;
    change: (cur: number | undefined, prev: number | undefined) => void;
    input: (val: number | null | undefined) => void;
    blur: (e: FocusEvent) => void;
    focus: (e: FocusEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly align: EpPropFinalized<(new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right") | ((new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right"))[], unknown, unknown, "center", boolean>;
    readonly disabledScientific: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly step: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly stepStrictly: BooleanConstructor;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly min: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly modelValue: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly controls: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly controlsPosition: EpPropFinalized<StringConstructor, "" | "right", unknown, "", boolean>;
    readonly valueOnClear: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor,
        null
    ], unknown, unknown, null, boolean>;
    readonly name: StringConstructor;
    readonly placeholder: StringConstructor;
    readonly precision: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((val: number | undefined) => any) | undefined;
    onChange?: ((cur: number | undefined, prev: number | undefined) => any) | undefined;
    onFocus?: ((e: FocusEvent) => any) | undefined;
    onBlur?: ((e: FocusEvent) => any) | undefined;
    onInput?: ((val: number | null | undefined) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly id: string;
    readonly valueOnClear: any;
    readonly readonly: boolean;
    readonly min: number;
    readonly max: number;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly inputmode: EpPropMergeType<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown>;
    readonly align: EpPropMergeType<(new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right") | ((new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right"))[], unknown, unknown>;
    readonly step: number;
    readonly controls: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly controlsPosition: EpPropMergeType<StringConstructor, "" | "right", unknown>;
    readonly disabledScientific: boolean;
    readonly stepStrictly: boolean;
}>;
declare const __VLS_component_5: DefineComponent<{
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    disabled: BooleanConstructor;
    trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    virtualTriggering: BooleanConstructor;
    onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    id: StringConstructor;
    open: BooleanConstructor;
    ariaLabel: StringConstructor;
    appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    rawContent: BooleanConstructor;
    persistent: BooleanConstructor;
    visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    transition: StringConstructor;
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    pure: BooleanConstructor;
    focusOnShow: BooleanConstructor;
    trapping: BooleanConstructor;
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    zIndex: NumberConstructor;
    boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
    showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    "onUpdate:visible": {
        readonly type: PropType<(val: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
}, {
    /**
    * @description el-popper component instance
    */
    popperRef: Ref<PopperInstance | undefined>;
    /**
    * @description el-tooltip-content component instance
    */
    contentRef: Ref<TooltipContentInstance | undefined>;
    /**
    * @description validate current focus event is trigger inside el-tooltip-content
    */
    isFocusInsideContent: (event?: FocusEvent) => boolean | undefined;
    /**
    * @description update el-popper component instance
    */
    updatePopper: () => void;
    /**
    * @description expose onOpen function to mange el-tooltip open state
    */
    onOpen: (event?: Event) => void;
    /**
    * @description expose onClose function to manage el-tooltip close state
    */
    onClose: (event?: Event) => void;
    /**
    * @description expose hide function
    */
    hide: (event?: Event) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    [x: string]: (...args: any[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    disabled: BooleanConstructor;
    trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    virtualTriggering: BooleanConstructor;
    onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    id: StringConstructor;
    open: BooleanConstructor;
    ariaLabel: StringConstructor;
    appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    rawContent: BooleanConstructor;
    persistent: BooleanConstructor;
    visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    transition: StringConstructor;
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    pure: BooleanConstructor;
    focusOnShow: BooleanConstructor;
    trapping: BooleanConstructor;
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    zIndex: NumberConstructor;
    boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
    showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    "onUpdate:visible": {
        readonly type: PropType<(val: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
}>>, {
    disabled: boolean;
    content: string;
    offset: number;
    visible: EpPropMergeType<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown>;
    open: boolean;
    placement: EpPropMergeType<StringConstructor, Placement, unknown>;
    strategy: EpPropMergeType<StringConstructor, "fixed" | "absolute", unknown>;
    effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    showAfter: number;
    hideAfter: number;
    autoClose: number;
    role: EpPropMergeType<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown>;
    trigger: EpPropMergeType<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown>;
    virtualTriggering: boolean;
    arrowOffset: number;
    boundariesPadding: number;
    fallbackPlacements: Placement[];
    gpuAcceleration: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    popperOptions: Partial<Options>;
    enterable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    stopPopperMouseEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    pure: boolean;
    focusOnShow: boolean;
    trapping: boolean;
    triggerKeys: string[];
    teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    rawContent: boolean;
    persistent: boolean;
    showArrow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_50: DefineComponent<{
    readonly modelValue: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly max: NumberConstructor;
    readonly tagType: {
        readonly default: "info";
        readonly type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tagEffect: EpPropFinalized<StringConstructor, "dark" | "light" | "plain", unknown, "light", boolean>;
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space") | ((new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space"))[], unknown, unknown, string, boolean>;
    readonly draggable: BooleanConstructor;
    readonly delimiter: EpPropFinalized<readonly [
        StringConstructor,
        RegExpConstructor
    ], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly readonly: BooleanConstructor;
    readonly autofocus: BooleanConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly saveOnBlur: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly collapseTags: BooleanConstructor;
    readonly collapseTagsTooltip: BooleanConstructor;
    readonly maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly ariaLabel: StringConstructor;
}, {
    focus: () => void;
    blur: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    clear: () => void;
    "update:modelValue": (value?: string[] | undefined) => void;
    change: (value?: string[] | undefined) => void;
    input: (value: string) => void;
    blur: (evt: FocusEvent) => void;
    focus: (evt: FocusEvent) => void;
    "add-tag": (value: string | string[]) => void;
    "remove-tag": (value: string) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly modelValue: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly max: NumberConstructor;
    readonly tagType: {
        readonly default: "info";
        readonly type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tagEffect: EpPropFinalized<StringConstructor, "dark" | "light" | "plain", unknown, "light", boolean>;
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space") | ((new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space"))[], unknown, unknown, string, boolean>;
    readonly draggable: BooleanConstructor;
    readonly delimiter: EpPropFinalized<readonly [
        StringConstructor,
        RegExpConstructor
    ], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly readonly: BooleanConstructor;
    readonly autofocus: BooleanConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly saveOnBlur: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly collapseTags: BooleanConstructor;
    readonly collapseTagsTooltip: BooleanConstructor;
    readonly maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly ariaLabel: StringConstructor;
}>> & {
    "onUpdate:modelValue"?: ((value?: string[] | undefined) => any) | undefined;
    onChange?: ((value?: string[] | undefined) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onInput?: ((value: string) => any) | undefined;
    onClear?: (() => any) | undefined;
    "onAdd-tag"?: ((value: string | string[]) => any) | undefined;
    "onRemove-tag"?: ((value: string) => any) | undefined;
}, {
    readonly disabled: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly id: string;
    readonly tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly readonly: boolean;
    readonly trigger: EpPropMergeType<(new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space") | ((new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space"))[], unknown, unknown>;
    readonly autocomplete: string;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly clearable: boolean;
    readonly autofocus: boolean;
    readonly draggable: boolean;
    readonly collapseTags: boolean;
    readonly maxCollapseTags: number;
    readonly collapseTagsTooltip: boolean;
    readonly tagType: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly tagEffect: EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>;
    readonly delimiter: EpPropMergeType<readonly [
        StringConstructor,
        RegExpConstructor
    ], unknown, unknown>;
    readonly saveOnBlur: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_51: DefineComponent<{
    readonly type: EpPropFinalized<StringConstructor, "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, undefined, boolean>;
    readonly underline: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor
    ], boolean | "always" | "never" | "hover", unknown, undefined, boolean>;
    readonly disabled: BooleanConstructor;
    readonly href: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly target: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "_self", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (evt: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly type: EpPropFinalized<StringConstructor, "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, undefined, boolean>;
    readonly underline: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor
    ], boolean | "always" | "never" | "hover", unknown, undefined, boolean>;
    readonly disabled: BooleanConstructor;
    readonly href: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly target: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "_self", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onClick?: ((evt: MouseEvent) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly underline: EpPropMergeType<readonly [
        BooleanConstructor,
        StringConstructor
    ], boolean | "always" | "never" | "hover", unknown>;
    readonly type: EpPropMergeType<StringConstructor, "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly target: string;
    readonly href: string;
}>;
declare const __VLS_component_52: DefineComponent<{
    readonly index: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, null, boolean>;
    readonly route: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
}, {
    parentMenu: ComputedRef<ComponentInternalInstance>;
    rootMenu: MenuProvider;
    active: ComputedRef<boolean>;
    nsMenu: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    nsMenuItem: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    handleClick: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (item: MenuItemRegistered) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly index: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, null, boolean>;
    readonly route: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
}>> & {
    onClick?: ((item: MenuItemRegistered) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly index: EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>;
}>;
declare const __VLS_component_53: DefineComponent<{
    readonly title: StringConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly title: StringConstructor;
}>>, {}>;
declare const __VLS_component_54: DefineComponent<{
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly title: StringConstructor;
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    back: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly title: StringConstructor;
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
}>> & {
    onBack?: (() => any) | undefined;
}, {
    readonly content: string;
    readonly icon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
}>;
declare const __VLS_component_55: DefineComponent<{
    readonly title: StringConstructor;
    readonly confirmButtonText: StringConstructor;
    readonly cancelButtonText: StringConstructor;
    readonly confirmButtonType: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
    readonly cancelButtonType: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "text", boolean>;
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly iconColor: EpPropFinalized<StringConstructor, unknown, unknown, "#f90", boolean>;
    readonly hideIcon: BooleanConstructor;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: BooleanConstructor;
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 150, boolean>;
}, {
    popperRef: ComputedRef<PopperInstance | undefined>;
    hide: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    cancel: (e: MouseEvent) => void;
    confirm: (e: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly title: StringConstructor;
    readonly confirmButtonText: StringConstructor;
    readonly cancelButtonText: StringConstructor;
    readonly confirmButtonType: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
    readonly cancelButtonType: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "text", boolean>;
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly iconColor: EpPropFinalized<StringConstructor, unknown, unknown, "#f90", boolean>;
    readonly hideIcon: BooleanConstructor;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: BooleanConstructor;
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 150, boolean>;
}>> & {
    onConfirm?: ((e: MouseEvent) => any) | undefined;
    onCancel?: ((e: MouseEvent) => any) | undefined;
}, {
    readonly width: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly icon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly hideAfter: number;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly persistent: boolean;
    readonly confirmButtonType: EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly cancelButtonType: EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly iconColor: string;
    readonly hideIcon: boolean;
}>;
declare const __VLS_component_56: DefineComponent<{
    readonly virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly virtualTriggering: BooleanConstructor;
    readonly onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly open: BooleanConstructor;
}, {
    /**
    * @description trigger element
    */
    triggerRef: Ref<Measurable | undefined>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly virtualTriggering: BooleanConstructor;
    readonly onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly open: BooleanConstructor;
}>>, {
    readonly open: boolean;
    readonly virtualTriggering: boolean;
}>;
declare const __VLS_component_57: DefineComponent<{
    readonly type: EpPropFinalized<StringConstructor, "circle" | "line" | "dashboard", unknown, "line", boolean>;
    readonly percentage: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly status: EpPropFinalized<StringConstructor, "" | "success" | "warning" | "exception", unknown, "", boolean>;
    readonly indeterminate: BooleanConstructor;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly strokeWidth: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly strokeLinecap: EpPropFinalized<(new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>) | ((new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>))[], unknown, unknown, "round", boolean>;
    readonly textInside: BooleanConstructor;
    readonly width: EpPropFinalized<NumberConstructor, unknown, unknown, 126, boolean>;
    readonly showText: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly color: EpPropFinalized<(new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]) | ((new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]))[], unknown, unknown, "", boolean>;
    readonly striped: BooleanConstructor;
    readonly stripedFlow: BooleanConstructor;
    readonly format: EpPropFinalized<(new (...args: any[]) => ProgressFn) | (() => ProgressFn) | {
        (): ProgressFn;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => ProgressFn) | (() => ProgressFn) | {
        (): ProgressFn;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, (percentage: number) => string, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly type: EpPropFinalized<StringConstructor, "circle" | "line" | "dashboard", unknown, "line", boolean>;
    readonly percentage: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly status: EpPropFinalized<StringConstructor, "" | "success" | "warning" | "exception", unknown, "", boolean>;
    readonly indeterminate: BooleanConstructor;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly strokeWidth: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly strokeLinecap: EpPropFinalized<(new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>) | ((new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>))[], unknown, unknown, "round", boolean>;
    readonly textInside: BooleanConstructor;
    readonly width: EpPropFinalized<NumberConstructor, unknown, unknown, 126, boolean>;
    readonly showText: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly color: EpPropFinalized<(new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]) | ((new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]))[], unknown, unknown, "", boolean>;
    readonly striped: BooleanConstructor;
    readonly stripedFlow: BooleanConstructor;
    readonly format: EpPropFinalized<(new (...args: any[]) => ProgressFn) | (() => ProgressFn) | {
        (): ProgressFn;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => ProgressFn) | (() => ProgressFn) | {
        (): ProgressFn;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, (percentage: number) => string, boolean>;
}>>, {
    readonly width: number;
    readonly color: EpPropMergeType<(new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]) | ((new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]))[], unknown, unknown>;
    readonly strokeLinecap: EpPropMergeType<(new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>) | ((new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>))[], unknown, unknown>;
    readonly strokeWidth: number;
    readonly type: EpPropMergeType<StringConstructor, "circle" | "line" | "dashboard", unknown>;
    readonly format: ProgressFn;
    readonly duration: number;
    readonly indeterminate: boolean;
    readonly percentage: number;
    readonly status: EpPropMergeType<StringConstructor, "" | "success" | "warning" | "exception", unknown>;
    readonly showText: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly textInside: boolean;
    readonly striped: boolean;
    readonly stripedFlow: boolean;
}>;
declare const __VLS_component_58: DefineComponent<{
    readonly border: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: string | number | boolean | undefined) => void;
    change: (val: string | number | boolean | undefined) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly border: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
}, {
    readonly label: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
    readonly disabled: boolean;
    readonly border: boolean;
    readonly value: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
    readonly name: string;
    readonly modelValue: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
}>;
declare const __VLS_component_59: DefineComponent<{
    readonly modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
}>>, {
    readonly label: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
    readonly disabled: boolean;
    readonly value: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
    readonly name: string;
    readonly modelValue: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
}>;
declare const __VLS_component_6: DefineComponent<{
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
}, {
    triggerRef: Ref<Measurable | undefined>;
    contentRef: Ref<HTMLElement | undefined>;
    popperInstanceRef: Ref<Instance_2 | undefined>;
    referenceRef: Ref<Measurable | undefined>;
    role: ComputedRef<string>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
}>>, {
    readonly role: EpPropMergeType<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown>;
}>;
declare const __VLS_component_60: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor,
        BooleanConstructor
    ], unknown, unknown, undefined, boolean>;
    readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: string | number | boolean | undefined) => void;
    change: (val: string | number | boolean | undefined) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor,
        BooleanConstructor
    ], unknown, unknown, undefined, boolean>;
    readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly fill: string;
    readonly id: string;
    readonly name: string;
    readonly modelValue: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor,
        BooleanConstructor
    ], unknown, unknown>;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly textColor: string;
}>;
declare const __VLS_component_61: DefineComponent<{
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly subTitle: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icon: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly subTitle: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icon: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
}>>, {
    readonly title: string;
    readonly icon: EpPropMergeType<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown>;
    readonly subTitle: string;
}>;
declare const __VLS_component_62: DefineComponent<{
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly gutter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly justify: EpPropFinalized<StringConstructor, "center" | "space-around" | "space-between" | "space-evenly" | "end" | "start", unknown, "start", boolean>;
    readonly align: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "top" | "bottom" | "middle", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly gutter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly justify: EpPropFinalized<StringConstructor, "center" | "space-around" | "space-between" | "space-evenly" | "end" | "start", unknown, "start", boolean>;
    readonly align: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "top" | "bottom" | "middle", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly justify: EpPropMergeType<StringConstructor, "center" | "space-around" | "space-between" | "space-evenly" | "end" | "start", unknown>;
    readonly tag: string;
    readonly gutter: number;
}>;
declare const __VLS_component_63: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly ariaOrientation: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly distance: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly height: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly maxHeight: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly native: BooleanConstructor;
    readonly wrapStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly wrapClass: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown, "", boolean>;
    readonly viewClass: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown, "", boolean>;
    readonly viewStyle: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor,
        ObjectConstructor
    ], unknown, unknown, "", boolean>;
    readonly noresize: BooleanConstructor;
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly always: BooleanConstructor;
    readonly minSize: EpPropFinalized<NumberConstructor, unknown, unknown, 20, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, undefined, boolean>;
    readonly id: StringConstructor;
    readonly role: StringConstructor;
}, {
    /** @description scrollbar wrap ref */
    wrapRef: Ref<HTMLDivElement | undefined>;
    /** @description update scrollbar state manually */
    update: () => void;
    /** @description scrolls to a particular set of coordinates */
    scrollTo: typeof scrollTo_2;
    /** @description set distance to scroll top */
    setScrollTop: (value: number) => void;
    /** @description set distance to scroll left */
    setScrollLeft: (value: number) => void;
    /** @description handle scroll event */
    handleScroll: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    scroll: (args_0: {
        scrollTop: number;
        scrollLeft: number;
    }) => void;
    "end-reached": (direction: ScrollbarDirection) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly ariaOrientation: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly distance: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly height: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly maxHeight: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly native: BooleanConstructor;
    readonly wrapStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly wrapClass: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown, "", boolean>;
    readonly viewClass: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown, "", boolean>;
    readonly viewStyle: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor,
        ObjectConstructor
    ], unknown, unknown, "", boolean>;
    readonly noresize: BooleanConstructor;
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly always: BooleanConstructor;
    readonly minSize: EpPropFinalized<NumberConstructor, unknown, unknown, 20, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, undefined, boolean>;
    readonly id: StringConstructor;
    readonly role: StringConstructor;
}>> & {
    onScroll?: ((args_0: {
        scrollTop: number;
        scrollLeft: number;
    }) => any) | undefined;
    "onEnd-reached"?: ((direction: ScrollbarDirection) => any) | undefined;
}, {
    readonly height: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly maxHeight: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly always: boolean;
    readonly tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly minSize: number;
    readonly distance: number;
    readonly wrapStyle: StyleValue;
    readonly wrapClass: EpPropMergeType<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown>;
    readonly viewClass: EpPropMergeType<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown>;
    readonly viewStyle: EpPropMergeType<readonly [
        StringConstructor,
        ArrayConstructor,
        ObjectConstructor
    ], unknown, unknown>;
    readonly tag: string;
    readonly native: boolean;
    readonly noresize: boolean;
}>;
declare const __VLS_component_64: DefineComponent<{
    readonly animated: BooleanConstructor;
    readonly count: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly loading: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly throttle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | {
            leading?: number;
            trailing?: number;
            initVal?: boolean;
        }) | (() => ThrottleType) | ((new (...args: any[]) => number | {
            leading?: number;
            trailing?: number;
            initVal?: boolean;
        }) | (() => ThrottleType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description loading state */
    uiLoading: Ref<boolean>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly animated: BooleanConstructor;
    readonly count: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly loading: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly throttle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | {
            leading?: number;
            trailing?: number;
            initVal?: boolean;
        }) | (() => ThrottleType) | ((new (...args: any[]) => number | {
            leading?: number;
            trailing?: number;
            initVal?: boolean;
        }) | (() => ThrottleType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly loading: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly rows: number;
    readonly count: number;
    readonly animated: boolean;
}>;
declare const __VLS_component_65: DefineComponent<{
    readonly decimalSeparator: EpPropFinalized<StringConstructor, unknown, unknown, ".", boolean>;
    readonly groupSeparator: EpPropFinalized<StringConstructor, unknown, unknown, ",", boolean>;
    readonly precision: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly formatter: FunctionConstructor;
    readonly value: EpPropFinalized<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown, 0, boolean>;
    readonly prefix: StringConstructor;
    readonly suffix: StringConstructor;
    readonly title: StringConstructor;
    readonly valueStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /**
    * @description current display value
    */
    displayValue: ComputedRef<any>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly decimalSeparator: EpPropFinalized<StringConstructor, unknown, unknown, ".", boolean>;
    readonly groupSeparator: EpPropFinalized<StringConstructor, unknown, unknown, ",", boolean>;
    readonly precision: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly formatter: FunctionConstructor;
    readonly value: EpPropFinalized<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown, 0, boolean>;
    readonly prefix: StringConstructor;
    readonly suffix: StringConstructor;
    readonly title: StringConstructor;
    readonly valueStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly value: EpPropMergeType<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown>;
    readonly decimalSeparator: string;
    readonly groupSeparator: string;
    readonly precision: number;
}>;
declare const __VLS_component_66: DefineComponent<{
    readonly space: EpPropFinalized<readonly [
        NumberConstructor,
        StringConstructor
    ], unknown, unknown, "", boolean>;
    readonly active: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly alignCenter: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly simple: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly finishStatus: EpPropFinalized<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown, "finish", boolean>;
    readonly processStatus: EpPropFinalized<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown, "process", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    change: (newVal: number, oldVal: number) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly space: EpPropFinalized<readonly [
        NumberConstructor,
        StringConstructor
    ], unknown, unknown, "", boolean>;
    readonly active: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly alignCenter: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly simple: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly finishStatus: EpPropFinalized<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown, "finish", boolean>;
    readonly processStatus: EpPropFinalized<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown, "process", boolean>;
}>> & {
    onChange?: ((newVal: number, oldVal: number) => any) | undefined;
}, {
    readonly direction: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly space: EpPropMergeType<readonly [
        NumberConstructor,
        StringConstructor
    ], unknown, unknown>;
    readonly active: number;
    readonly finishStatus: EpPropMergeType<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown>;
    readonly processStatus: EpPropMergeType<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown>;
}>;
declare const __VLS_component_67: DefineComponent<{
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly status: EpPropFinalized<StringConstructor, "" | "wait" | "error" | "finish" | "success" | "process", unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly status: EpPropFinalized<StringConstructor, "" | "wait" | "error" | "finish" | "success" | "process", unknown, "", boolean>;
}>>, {
    readonly title: string;
    readonly description: string;
    readonly status: EpPropMergeType<StringConstructor, "" | "wait" | "error" | "finish" | "success" | "process", unknown>;
}>;
declare const __VLS_component_68: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, false, boolean>;
    readonly disabled: BooleanConstructor;
    readonly loading: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "small" | "default" | "large") | (() => "" | "small" | "default" | "large") | ((new (...args: any[]) => "" | "small" | "default" | "large") | (() => "" | "small" | "default" | "large"))[], unknown, "" | "small" | "default" | "large">>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly inlinePrompt: BooleanConstructor;
    readonly inactiveActionIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeActionIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly inactiveIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly inactiveText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly activeValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, true, boolean>;
    readonly inactiveValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, false, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly beforeChange: {
        readonly type: PropType<() => Promise<boolean> | boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly tabindex: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /**
    *  @description manual focus to the switch component
    **/
    focus: () => void;
    /**
    * @description whether Switch is checked
    */
    checked: ComputedRef<boolean>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: string | number | boolean) => void;
    change: (val: string | number | boolean) => void;
    input: (val: string | number | boolean) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, false, boolean>;
    readonly disabled: BooleanConstructor;
    readonly loading: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "small" | "default" | "large") | (() => "" | "small" | "default" | "large") | ((new (...args: any[]) => "" | "small" | "default" | "large") | (() => "" | "small" | "default" | "large"))[], unknown, "" | "small" | "default" | "large">>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly inlinePrompt: BooleanConstructor;
    readonly inactiveActionIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeActionIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly inactiveIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly inactiveText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly activeValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, true, boolean>;
    readonly inactiveValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, false, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly beforeChange: {
        readonly type: PropType<() => Promise<boolean> | boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly tabindex: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:modelValue"?: ((val: string | number | boolean) => any) | undefined;
    onChange?: ((val: string | number | boolean) => any) | undefined;
    onInput?: ((val: string | number | boolean) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly width: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly name: string;
    readonly loading: boolean;
    readonly modelValue: EpPropMergeType<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly activeText: string;
    readonly inactiveText: string;
    readonly activeValue: EpPropMergeType<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly inactiveValue: EpPropMergeType<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly inlinePrompt: boolean;
}>;
declare const __VLS_component_69: DefineComponent<{
    readonly label: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly closable: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly lazy: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly label: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly closable: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly lazy: BooleanConstructor;
}>>, {
    readonly label: string;
    readonly disabled: boolean;
    readonly closable: boolean;
    readonly lazy: boolean;
}>;
declare const __VLS_component_7: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly rawContent: BooleanConstructor;
    readonly persistent: BooleanConstructor;
    readonly visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    readonly transition: StringConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly disabled: BooleanConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
}, {
    /**
    * @description el-popper-content component instance
    */
    contentRef: Ref<PopperContentInstance | undefined>;
    /**
    * @description validate current focus event is trigger inside el-popper-content
    */
    isFocusInsideContent: (event?: FocusEvent) => boolean | undefined;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly rawContent: BooleanConstructor;
    readonly persistent: BooleanConstructor;
    readonly visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    readonly transition: StringConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly disabled: BooleanConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
}>>, {
    readonly disabled: boolean;
    readonly content: string;
    readonly offset: number;
    readonly visible: EpPropMergeType<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown>;
    readonly placement: EpPropMergeType<StringConstructor, Placement, unknown>;
    readonly strategy: EpPropMergeType<StringConstructor, "fixed" | "absolute", unknown>;
    readonly effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly showAfter: number;
    readonly hideAfter: number;
    readonly autoClose: number;
    readonly virtualTriggering: boolean;
    readonly arrowOffset: number;
    readonly boundariesPadding: number;
    readonly fallbackPlacements: Placement[];
    readonly gpuAcceleration: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly popperOptions: Partial<Options>;
    readonly enterable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly stopPopperMouseEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly pure: boolean;
    readonly focusOnShow: boolean;
    readonly trapping: boolean;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly rawContent: boolean;
    readonly persistent: boolean;
}>;
declare const __VLS_component_70: DefineComponent<{
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
    readonly closable: BooleanConstructor;
    readonly disableTransitions: BooleanConstructor;
    readonly hit: BooleanConstructor;
    readonly color: StringConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<StringConstructor, "dark" | "light" | "plain", unknown, "light", boolean>;
    readonly round: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (evt: MouseEvent) => void;
    close: (evt: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
    readonly closable: BooleanConstructor;
    readonly disableTransitions: BooleanConstructor;
    readonly hit: BooleanConstructor;
    readonly color: StringConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<StringConstructor, "dark" | "light" | "plain", unknown, "light", boolean>;
    readonly round: BooleanConstructor;
}>> & {
    onClick?: ((evt: MouseEvent) => any) | undefined;
    onClose?: ((evt: MouseEvent) => any) | undefined;
}, {
    readonly round: boolean;
    readonly type: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly effect: EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>;
    readonly closable: boolean;
    readonly disableTransitions: boolean;
    readonly hit: boolean;
}>;
declare const __VLS_component_71: DefineComponent<{
    readonly type: EpPropFinalized<StringConstructor, "" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly size: EpPropFinalized<StringConstructor, "" | "small" | "default" | "large", unknown, "", boolean>;
    readonly truncated: BooleanConstructor;
    readonly lineClamp: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "span", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly type: EpPropFinalized<StringConstructor, "" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly size: EpPropFinalized<StringConstructor, "" | "small" | "default" | "large", unknown, "", boolean>;
    readonly truncated: BooleanConstructor;
    readonly lineClamp: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "span", boolean>;
}>>, {
    readonly size: EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>;
    readonly type: EpPropMergeType<StringConstructor, "" | "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly tag: string;
    readonly truncated: boolean;
}>;
declare const __VLS_component_72: DefineComponent<{
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showWeekNumber: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly unlinkPanels: BooleanConstructor;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly format: StringConstructor;
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    readonly rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
}, {
    /**
    * @description focus input box.
    */
    focus: () => void;
    /**
    * @description blur input box.
    */
    blur: () => void;
    /**
    * @description opens picker
    */
    handleOpen: () => void;
    /**
    * @description closes picker
    */
    handleClose: () => void;
    /**
    * @description pick item manually
    */
    onPick: (date?: any, visible?: boolean) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    clear: (...args: any[]) => void;
    "update:modelValue": (...args: any[]) => void;
    change: (...args: any[]) => void;
    blur: (...args: any[]) => void;
    focus: (...args: any[]) => void;
    keydown: (...args: any[]) => void;
    "calendar-change": (...args: any[]) => void;
    "panel-change": (...args: any[]) => void;
    "visible-change": (...args: any[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showWeekNumber: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly unlinkPanels: BooleanConstructor;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly format: StringConstructor;
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    readonly rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
}>> & {
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    onFocus?: ((...args: any[]) => any) | undefined;
    onBlur?: ((...args: any[]) => any) | undefined;
    onKeydown?: ((...args: any[]) => any) | undefined;
    onClear?: ((...args: any[]) => any) | undefined;
    "onCalendar-change"?: ((...args: any[]) => any) | undefined;
    "onPanel-change"?: ((...args: any[]) => any) | undefined;
    "onVisible-change"?: ((...args: any[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly type: string;
    readonly placeholder: string;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown>;
    readonly placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown>;
    readonly tabindex: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>;
    readonly valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly readonly: boolean;
    readonly prefixIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly clearable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly fallbackPlacements: Placement[];
    readonly popperOptions: Partial<Options>;
    readonly editable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly rangeSeparator: string;
    readonly shortcuts: unknown[];
    readonly showNow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showConfirm: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showFooter: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showWeekNumber: boolean;
    readonly arrowControl: boolean;
    readonly unlinkPanels: boolean;
    readonly isRange: boolean;
}>;
declare const __VLS_component_73: DefineComponent<{
    readonly timestamp: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly hideTimestamp: BooleanConstructor;
    readonly center: BooleanConstructor;
    readonly placement: EpPropFinalized<StringConstructor, "top" | "bottom", unknown, "bottom", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly color: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly size: EpPropFinalized<StringConstructor, "normal" | "large", unknown, "normal", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hollow: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly timestamp: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly hideTimestamp: BooleanConstructor;
    readonly center: BooleanConstructor;
    readonly placement: EpPropFinalized<StringConstructor, "top" | "bottom", unknown, "bottom", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly color: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly size: EpPropFinalized<StringConstructor, "normal" | "large", unknown, "normal", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hollow: BooleanConstructor;
}>>, {
    readonly center: boolean;
    readonly color: string;
    readonly size: EpPropMergeType<StringConstructor, "normal" | "large", unknown>;
    readonly type: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly placement: EpPropMergeType<StringConstructor, "top" | "bottom", unknown>;
    readonly timestamp: string;
    readonly hideTimestamp: boolean;
    readonly hollow: boolean;
}>;
declare const __VLS_component_74: DefineComponent<{
    readonly data: EpPropFinalized<(new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]) | ((new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]))[], unknown, unknown, () => never[], boolean>;
    readonly titles: EpPropFinalized<(new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]) | ((new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]))[], unknown, unknown, () => never[], boolean>;
    readonly buttonTexts: EpPropFinalized<(new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]) | ((new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]))[], unknown, unknown, () => never[], boolean>;
    readonly filterPlaceholder: StringConstructor;
    readonly filterMethod: {
        readonly type: PropType<(query: string, item: TransferDataItem) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly leftDefaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly rightDefaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly renderContent: {
        readonly type: PropType<renderContent>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly format: EpPropFinalized<(new (...args: any[]) => TransferFormat) | (() => TransferFormat) | ((new (...args: any[]) => TransferFormat) | (() => TransferFormat))[], unknown, unknown, () => {}, boolean>;
    readonly filterable: BooleanConstructor;
    readonly props: EpPropFinalized<(new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias) | ((new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias))[], unknown, unknown, () => Mutable<{
        readonly label: "label";
        readonly key: "key";
        readonly disabled: "disabled";
    }>, boolean>;
    readonly targetOrder: EpPropFinalized<StringConstructor, "push" | "unshift" | "original", unknown, "original", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {
    /** @description clear the filter keyword of a certain panel */
    clearQuery: (which: TransferDirection) => void;
    /** @description left panel ref */
    leftPanel: Ref<TransferPanelInstance | undefined>;
    /** @description right panel ref */
    rightPanel: Ref<TransferPanelInstance | undefined>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: TransferKey[]) => void;
    change: (value: TransferKey[], direction: TransferDirection, movedKeys: TransferKey[]) => void;
    "left-check-change": (value: TransferKey[], movedKeys?: TransferKey[] | undefined) => void;
    "right-check-change": (value: TransferKey[], movedKeys?: TransferKey[] | undefined) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly data: EpPropFinalized<(new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]) | ((new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]))[], unknown, unknown, () => never[], boolean>;
    readonly titles: EpPropFinalized<(new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]) | ((new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]))[], unknown, unknown, () => never[], boolean>;
    readonly buttonTexts: EpPropFinalized<(new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]) | ((new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]))[], unknown, unknown, () => never[], boolean>;
    readonly filterPlaceholder: StringConstructor;
    readonly filterMethod: {
        readonly type: PropType<(query: string, item: TransferDataItem) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly leftDefaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly rightDefaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly renderContent: {
        readonly type: PropType<renderContent>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly format: EpPropFinalized<(new (...args: any[]) => TransferFormat) | (() => TransferFormat) | ((new (...args: any[]) => TransferFormat) | (() => TransferFormat))[], unknown, unknown, () => {}, boolean>;
    readonly filterable: BooleanConstructor;
    readonly props: EpPropFinalized<(new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias) | ((new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias))[], unknown, unknown, () => Mutable<{
        readonly label: "label";
        readonly key: "key";
        readonly disabled: "disabled";
    }>, boolean>;
    readonly targetOrder: EpPropFinalized<StringConstructor, "push" | "unshift" | "original", unknown, "original", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: TransferKey[]) => any) | undefined;
    onChange?: ((value: TransferKey[], direction: TransferDirection, movedKeys: TransferKey[]) => any) | undefined;
    "onLeft-check-change"?: ((value: TransferKey[], movedKeys?: TransferKey[] | undefined) => any) | undefined;
    "onRight-check-change"?: ((value: TransferKey[], movedKeys?: TransferKey[] | undefined) => any) | undefined;
}, {
    readonly data: TransferDataItem[];
    readonly props: TransferPropsAlias;
    readonly titles: [
        string,
        string
    ];
    readonly modelValue: TransferKey[];
    readonly format: TransferFormat;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly filterable: boolean;
    readonly buttonTexts: [
        string,
        string
    ];
    readonly leftDefaultChecked: TransferKey[];
    readonly rightDefaultChecked: TransferKey[];
    readonly targetOrder: EpPropMergeType<StringConstructor, "push" | "unshift" | "original", unknown>;
}>;
declare const __VLS_component_75: DefineComponent<{
    readonly data: EpPropFinalized<(new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]) | ((new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]))[], unknown, unknown, () => never[], boolean>;
    readonly optionRender: {
        readonly type: PropType<(option: TransferDataItem) => VNode | VNode[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly title: StringConstructor;
    readonly filterable: BooleanConstructor;
    readonly format: EpPropFinalized<(new (...args: any[]) => TransferFormat) | (() => TransferFormat) | ((new (...args: any[]) => TransferFormat) | (() => TransferFormat))[], unknown, unknown, () => {}, boolean>;
    readonly filterMethod: {
        readonly type: PropType<(query: string, item: TransferDataItem) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly props: EpPropFinalized<(new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias) | ((new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias))[], unknown, unknown, () => Mutable<{
        readonly label: "label";
        readonly key: "key";
        readonly disabled: "disabled";
    }>, boolean>;
}, {
    /** @description filter keyword */
    query: Ref<string>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "checked-change": (value: TransferKey[], movedKeys?: TransferKey[] | undefined) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly data: EpPropFinalized<(new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]) | ((new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]))[], unknown, unknown, () => never[], boolean>;
    readonly optionRender: {
        readonly type: PropType<(option: TransferDataItem) => VNode | VNode[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly title: StringConstructor;
    readonly filterable: BooleanConstructor;
    readonly format: EpPropFinalized<(new (...args: any[]) => TransferFormat) | (() => TransferFormat) | ((new (...args: any[]) => TransferFormat) | (() => TransferFormat))[], unknown, unknown, () => {}, boolean>;
    readonly filterMethod: {
        readonly type: PropType<(query: string, item: TransferDataItem) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly props: EpPropFinalized<(new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias) | ((new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias))[], unknown, unknown, () => Mutable<{
        readonly label: "label";
        readonly key: "key";
        readonly disabled: "disabled";
    }>, boolean>;
}>> & {
    "onChecked-change"?: ((value: TransferKey[], movedKeys?: TransferKey[] | undefined) => any) | undefined;
}, {
    readonly data: TransferDataItem[];
    readonly props: TransferPropsAlias;
    readonly format: TransferFormat;
    readonly filterable: boolean;
    readonly defaultChecked: TransferKey[];
}>;
declare const __VLS_component_76: DefineComponent<{
    readonly data: EpPropFinalized<(new (...args: any[]) => TreeData_3) | (() => TreeData_3) | ((new (...args: any[]) => TreeData_3) | (() => TreeData_3))[], unknown, unknown, () => [
    ], boolean>;
    readonly emptyText: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly props: EpPropFinalized<(new (...args: any[]) => TreeOptionProps_2) | (() => TreeOptionProps_2) | ((new (...args: any[]) => TreeOptionProps_2) | (() => TreeOptionProps_2))[], unknown, unknown, () => Mutable<{
        readonly children: import("./virtual-tree").TreeOptionsEnum.CHILDREN;
        readonly label: import("./virtual-tree").TreeOptionsEnum.LABEL;
        readonly disabled: import("./virtual-tree").TreeOptionsEnum.DISABLED;
        readonly value: import("./virtual-tree").TreeOptionsEnum.KEY;
        readonly class: import("./virtual-tree").TreeOptionsEnum.CLASS;
    }>, boolean>;
    readonly highlightCurrent: BooleanConstructor;
    readonly showCheckbox: BooleanConstructor;
    readonly defaultCheckedKeys: EpPropFinalized<(new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]) | ((new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly checkStrictly: BooleanConstructor;
    readonly defaultExpandedKeys: EpPropFinalized<(new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]) | ((new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly indent: EpPropFinalized<NumberConstructor, unknown, unknown, 16, boolean>;
    readonly itemSize: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandOnClickNode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly checkOnClickNode: BooleanConstructor;
    readonly checkOnClickLeaf: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly currentNodeKey: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number) | (() => TreeKey_2) | ((new (...args: any[]) => string | number) | (() => TreeKey_2))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly accordion: BooleanConstructor;
    readonly filterMethod: {
        readonly type: PropType<FilterMethod>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
}, {
    toggleCheckbox: (node: TreeNode_2, isChecked: CheckboxValueType, nodeClick?: boolean, immediateUpdate?: boolean) => void;
    getCurrentNode: () => TreeNodeData_2 | undefined;
    getCurrentKey: () => TreeKey_2 | undefined;
    setCurrentKey: (key: TreeKey_2) => void;
    getCheckedKeys: (leafOnly?: boolean) => TreeKey_2[];
    getCheckedNodes: (leafOnly?: boolean) => TreeNodeData_2[];
    getHalfCheckedKeys: () => TreeKey_2[];
    getHalfCheckedNodes: () => TreeNodeData_2[];
    setChecked: (key: TreeKey_2, isChecked: boolean) => void;
    setCheckedKeys: (keys: TreeKey_2[]) => void;
    filter: (query: string) => void;
    setData: (data: TreeData_3) => void;
    getNode: (data: TreeKey_2 | TreeNodeData_2) => TreeNode_2 | undefined;
    expandNode: (node: TreeNode_2) => void;
    collapseNode: (node: TreeNode_2) => void;
    setExpandedKeys: (keys: TreeKey_2[]) => void;
    scrollToNode: (key: TreeKey_2, strategy?: Alignment) => void;
    scrollTo: (offset: number) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    check: (data: TreeNodeData, checkedInfo: CheckedInfo) => void;
    "current-change": (data: TreeNodeData, node: TreeNode_2) => void;
    "node-drop": (data: TreeNodeData, node: TreeNode_2, e: DragEvent) => void;
    "node-expand": (data: TreeNodeData, node: TreeNode_2) => void;
    "check-change": (data: TreeNodeData, checked: boolean) => void;
    "node-click": (data: TreeNodeData, node: TreeNode_2, e: MouseEvent) => void;
    "node-contextmenu": (evt: Event, data: TreeNodeData, node: TreeNode_2) => void;
    "node-collapse": (data: TreeNodeData, node: TreeNode_2) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly data: EpPropFinalized<(new (...args: any[]) => TreeData_3) | (() => TreeData_3) | ((new (...args: any[]) => TreeData_3) | (() => TreeData_3))[], unknown, unknown, () => [
    ], boolean>;
    readonly emptyText: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly props: EpPropFinalized<(new (...args: any[]) => TreeOptionProps_2) | (() => TreeOptionProps_2) | ((new (...args: any[]) => TreeOptionProps_2) | (() => TreeOptionProps_2))[], unknown, unknown, () => Mutable<{
        readonly children: import("./virtual-tree").TreeOptionsEnum.CHILDREN;
        readonly label: import("./virtual-tree").TreeOptionsEnum.LABEL;
        readonly disabled: import("./virtual-tree").TreeOptionsEnum.DISABLED;
        readonly value: import("./virtual-tree").TreeOptionsEnum.KEY;
        readonly class: import("./virtual-tree").TreeOptionsEnum.CLASS;
    }>, boolean>;
    readonly highlightCurrent: BooleanConstructor;
    readonly showCheckbox: BooleanConstructor;
    readonly defaultCheckedKeys: EpPropFinalized<(new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]) | ((new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly checkStrictly: BooleanConstructor;
    readonly defaultExpandedKeys: EpPropFinalized<(new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]) | ((new (...args: any[]) => TreeKey_2[]) | (() => TreeKey_2[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly indent: EpPropFinalized<NumberConstructor, unknown, unknown, 16, boolean>;
    readonly itemSize: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandOnClickNode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly checkOnClickNode: BooleanConstructor;
    readonly checkOnClickLeaf: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly currentNodeKey: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number) | (() => TreeKey_2) | ((new (...args: any[]) => string | number) | (() => TreeKey_2))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly accordion: BooleanConstructor;
    readonly filterMethod: {
        readonly type: PropType<FilterMethod>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
}>> & {
    "onCurrent-change"?: ((data: TreeNodeData, node: TreeNode_2) => any) | undefined;
    "onNode-expand"?: ((data: TreeNodeData, node: TreeNode_2) => any) | undefined;
    onCheck?: ((data: TreeNodeData, checkedInfo: CheckedInfo) => any) | undefined;
    "onNode-drop"?: ((data: TreeNodeData, node: TreeNode_2, e: DragEvent) => any) | undefined;
    "onCheck-change"?: ((data: TreeNodeData, checked: boolean) => any) | undefined;
    "onNode-click"?: ((data: TreeNodeData, node: TreeNode_2, e: MouseEvent) => any) | undefined;
    "onNode-contextmenu"?: ((evt: Event, data: TreeNodeData, node: TreeNode_2) => any) | undefined;
    "onNode-collapse"?: ((data: TreeNodeData, node: TreeNode_2) => any) | undefined;
}, {
    readonly data: TreeData_3;
    readonly height: number;
    readonly props: TreeOptionProps_2;
    readonly checkStrictly: boolean;
    readonly checkOnClickNode: boolean;
    readonly checkOnClickLeaf: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly accordion: boolean;
    readonly perfMode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly scrollbarAlwaysOn: boolean;
    readonly itemSize: number;
    readonly indent: number;
    readonly defaultCheckedKeys: TreeKey_2[];
    readonly defaultExpandedKeys: TreeKey_2[];
    readonly showCheckbox: boolean;
    readonly expandOnClickNode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly highlightCurrent: boolean;
}>;
declare const __VLS_component_77: DefineComponent<{
    readonly beforeUpload: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly beforeRemove: {
        readonly type: PropType<(uploadFile: UploadFile, uploadFiles: UploadFiles) => Awaitable<boolean>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRemove: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onChange: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onPreview: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onSuccess: EpPropFinalized<(new (...args: any[]) => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onProgress: EpPropFinalized<(new (...args: any[]) => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onError: EpPropFinalized<(new (...args: any[]) => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onExceed: EpPropFinalized<(new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
}, {
    /** @description cancel upload request */
    abort: (file: UploadFile) => void;
    /** @description upload the file list manually */
    submit: () => void;
    /** @description clear the file list  */
    clearFiles: (states?: UploadStatus[]) => void;
    /** @description select the file manually */
    handleStart: (rawFile: UploadRawFile) => void;
    /** @description remove the file manually */
    handleRemove: (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly beforeUpload: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly beforeRemove: {
        readonly type: PropType<(uploadFile: UploadFile, uploadFiles: UploadFiles) => Awaitable<boolean>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRemove: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onChange: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onPreview: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onSuccess: EpPropFinalized<(new (...args: any[]) => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onProgress: EpPropFinalized<(new (...args: any[]) => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onError: EpPropFinalized<(new (...args: any[]) => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onExceed: EpPropFinalized<(new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
}>>, {
    readonly data: EpPropMergeType<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown>;
    readonly disabled: boolean;
    readonly drag: boolean;
    readonly multiple: boolean;
    readonly name: string;
    readonly onChange: (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    readonly onError: (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    readonly onProgress: (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    readonly method: string;
    readonly action: string;
    readonly accept: string;
    readonly withCredentials: boolean;
    readonly showFileList: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly fileList: UploadUserFile[];
    readonly autoUpload: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly listType: EpPropMergeType<StringConstructor, "picture" | "text" | "picture-card", unknown>;
    readonly httpRequest: UploadRequestHandler;
    readonly beforeUpload: (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
    readonly onRemove: (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    readonly onPreview: (uploadFile: UploadFile) => void;
    readonly onSuccess: (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    readonly onExceed: (files: File[], uploadFiles: UploadUserFile[]) => void;
}>;
declare const __VLS_component_78: DefineComponent<{
    readonly beforeUpload: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onRemove: EpPropFinalized<(new (...args: any[]) => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | (() => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | {
        (): (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | (() => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | {
        (): (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onStart: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => void) | (() => (rawFile: UploadRawFile) => void) | {
        (): (rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => void) | (() => (rawFile: UploadRawFile) => void) | {
        (): (rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onSuccess: EpPropFinalized<(new (...args: any[]) => (response: any, rawFile: UploadRawFile) => unknown) | (() => (response: any, rawFile: UploadRawFile) => unknown) | {
        (): (response: any, rawFile: UploadRawFile) => unknown;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (response: any, rawFile: UploadRawFile) => unknown) | (() => (response: any, rawFile: UploadRawFile) => unknown) | {
        (): (response: any, rawFile: UploadRawFile) => unknown;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onProgress: EpPropFinalized<(new (...args: any[]) => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | (() => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | {
        (): (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | (() => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | {
        (): (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onError: EpPropFinalized<(new (...args: any[]) => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | (() => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | {
        (): (err: UploadAjaxError, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | (() => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | {
        (): (err: UploadAjaxError, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onExceed: EpPropFinalized<(new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
}, {
    abort: (file?: UploadFile) => void;
    upload: (rawFile: UploadRawFile) => Promise<void>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly beforeUpload: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onRemove: EpPropFinalized<(new (...args: any[]) => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | (() => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | {
        (): (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | (() => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | {
        (): (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onStart: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => void) | (() => (rawFile: UploadRawFile) => void) | {
        (): (rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => void) | (() => (rawFile: UploadRawFile) => void) | {
        (): (rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onSuccess: EpPropFinalized<(new (...args: any[]) => (response: any, rawFile: UploadRawFile) => unknown) | (() => (response: any, rawFile: UploadRawFile) => unknown) | {
        (): (response: any, rawFile: UploadRawFile) => unknown;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (response: any, rawFile: UploadRawFile) => unknown) | (() => (response: any, rawFile: UploadRawFile) => unknown) | {
        (): (response: any, rawFile: UploadRawFile) => unknown;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onProgress: EpPropFinalized<(new (...args: any[]) => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | (() => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | {
        (): (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | (() => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | {
        (): (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onError: EpPropFinalized<(new (...args: any[]) => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | (() => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | {
        (): (err: UploadAjaxError, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | (() => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | {
        (): (err: UploadAjaxError, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onExceed: EpPropFinalized<(new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
}>>, {
    readonly data: EpPropMergeType<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown>;
    readonly disabled: boolean;
    readonly drag: boolean;
    readonly multiple: boolean;
    readonly name: string;
    readonly onError: (err: UploadAjaxError, rawFile: UploadRawFile) => void;
    readonly onProgress: (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
    readonly method: string;
    readonly action: string;
    readonly accept: string;
    readonly withCredentials: boolean;
    readonly showFileList: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly fileList: UploadUserFile[];
    readonly autoUpload: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly listType: EpPropMergeType<StringConstructor, "picture" | "text" | "picture-card", unknown>;
    readonly httpRequest: UploadRequestHandler;
    readonly beforeUpload: (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
    readonly onRemove: (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
    readonly onSuccess: (response: any, rawFile: UploadRawFile) => unknown;
    readonly onExceed: (files: File[], uploadFiles: UploadUserFile[]) => void;
    readonly onStart: (rawFile: UploadRawFile) => void;
}>;
declare const __VLS_component_79: DefineComponent<{
    readonly files: EpPropFinalized<(new (...args: any[]) => UploadFiles) | (() => UploadFiles) | ((new (...args: any[]) => UploadFiles) | (() => UploadFiles))[], unknown, unknown, () => never[], boolean>;
    readonly disabled: BooleanConstructor;
    readonly handlePreview: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    remove: (file: UploadFile) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly files: EpPropFinalized<(new (...args: any[]) => UploadFiles) | (() => UploadFiles) | ((new (...args: any[]) => UploadFiles) | (() => UploadFiles))[], unknown, unknown, () => never[], boolean>;
    readonly disabled: BooleanConstructor;
    readonly handlePreview: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onRemove?: ((file: UploadFile) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly listType: EpPropMergeType<StringConstructor, "picture" | "text" | "picture-card", unknown>;
    readonly files: UploadFiles;
    readonly handlePreview: (uploadFile: UploadFile) => void;
}>;
declare const __VLS_component_8: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly visible: BooleanConstructor;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
}, {
    /**
    * @description popper content element
    */
    popperContentRef: Ref<HTMLElement | undefined>;
    /**
    * @description popperjs instance
    */
    popperInstanceRef: ComputedRef<Instance_2 | undefined>;
    /**
    * @description method for updating popper
    */
    updatePopper: (shouldUpdateZIndex?: boolean) => void;
    /**
    * @description content style
    */
    contentStyle: ComputedRef<StyleValue[]>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    blur: () => void;
    close: () => void;
    focus: () => void;
    mouseenter: (evt: MouseEvent) => void;
    mouseleave: (evt: MouseEvent) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly visible: BooleanConstructor;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
}>> & {
    onFocus?: (() => any) | undefined;
    onBlur?: (() => any) | undefined;
    onMouseenter?: ((evt: MouseEvent) => any) | undefined;
    onMouseleave?: ((evt: MouseEvent) => any) | undefined;
    onClose?: (() => any) | undefined;
}, {
    readonly offset: number;
    readonly visible: boolean;
    readonly placement: EpPropMergeType<StringConstructor, Placement, unknown>;
    readonly strategy: EpPropMergeType<StringConstructor, "fixed" | "absolute", unknown>;
    readonly effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly virtualTriggering: boolean;
    readonly arrowOffset: number;
    readonly boundariesPadding: number;
    readonly fallbackPlacements: Placement[];
    readonly gpuAcceleration: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly popperOptions: Partial<Options>;
    readonly enterable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly stopPopperMouseEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly pure: boolean;
    readonly focusOnShow: boolean;
    readonly trapping: boolean;
}>;
declare const __VLS_component_80: DefineComponent<{
    readonly disabled: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    file: (file: File[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly disabled: BooleanConstructor;
}>> & {
    onFile?: ((file: File[]) => any) | undefined;
}, {
    readonly disabled: boolean;
}>;
declare const __VLS_component_81: DefineComponent<{
    readonly zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 9, boolean>;
    readonly rotate: EpPropFinalized<NumberConstructor, unknown, unknown, -22, boolean>;
    readonly width: NumberConstructor;
    readonly height: NumberConstructor;
    readonly image: StringConstructor;
    readonly content: EpPropFinalized<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown, "Element Plus", boolean>;
    readonly font: {
        readonly type: PropType<WatermarkFontType>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly gap: EpPropFinalized<(new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]) | ((new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]))[], unknown, unknown, () => number[], boolean>;
    readonly offset: {
        readonly type: PropType<[
            number,
            number
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 9, boolean>;
    readonly rotate: EpPropFinalized<NumberConstructor, unknown, unknown, -22, boolean>;
    readonly width: NumberConstructor;
    readonly height: NumberConstructor;
    readonly image: StringConstructor;
    readonly content: EpPropFinalized<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown, "Element Plus", boolean>;
    readonly font: {
        readonly type: PropType<WatermarkFontType>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly gap: EpPropFinalized<(new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]) | ((new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]))[], unknown, unknown, () => number[], boolean>;
    readonly offset: {
        readonly type: PropType<[
            number,
            number
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly content: EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown>;
    readonly rotate: number;
    readonly zIndex: number;
    readonly gap: [
        number,
        number
    ];
}>;
declare const __VLS_component_82: DefineComponent<{
    modelValue: BooleanConstructor;
    current: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    contentStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    mask: EpPropFinalized<(new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask) | ((new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask))[], unknown, unknown, boolean, boolean>;
    gap: EpPropFinalized<(new (...args: any[]) => TourGap) | (() => TourGap) | ((new (...args: any[]) => TourGap) | (() => TourGap))[], unknown, unknown, () => {
        offset: number;
        radius: number;
    }, boolean>;
    zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, () => {
        block: string;
    }, boolean>;
    type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "default" | "primary") | (() => "default" | "primary") | ((new (...args: any[]) => "default" | "primary") | (() => "default" | "primary"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, string, boolean>;
    closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    targetAreaClickable: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: boolean) => void;
    change: (current: number) => void;
    close: (current: number) => void;
    finish: () => void;
    "update:current": (current: number) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    modelValue: BooleanConstructor;
    current: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    contentStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    mask: EpPropFinalized<(new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask) | ((new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask))[], unknown, unknown, boolean, boolean>;
    gap: EpPropFinalized<(new (...args: any[]) => TourGap) | (() => TourGap) | ((new (...args: any[]) => TourGap) | (() => TourGap))[], unknown, unknown, () => {
        offset: number;
        radius: number;
    }, boolean>;
    zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, () => {
        block: string;
    }, boolean>;
    type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "default" | "primary") | (() => "default" | "primary") | ((new (...args: any[]) => "default" | "primary") | (() => "default" | "primary"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, string, boolean>;
    closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    targetAreaClickable: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: boolean) => any) | undefined;
    onChange?: ((current: number) => any) | undefined;
    onClose?: ((current: number) => any) | undefined;
    onFinish?: (() => any) | undefined;
    "onUpdate:current"?: ((current: number) => any) | undefined;
}, {
    mask: TourMask;
    gap: TourGap;
    modelValue: boolean;
    placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown>;
    scrollIntoViewOptions: EpPropMergeType<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown>;
    appendTo: EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>;
    showArrow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    showClose: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    closeOnPressEscape: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    current: number;
    targetAreaClickable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_83: DefineComponent<{
    target: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement | (() => HTMLElement | null)) | (() => string | HTMLElement | (() => HTMLElement | null) | null) | ((new (...args: any[]) => string | HTMLElement | (() => HTMLElement | null)) | (() => string | HTMLElement | (() => HTMLElement | null) | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    title: StringConstructor;
    description: StringConstructor;
    showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    mask: EpPropFinalized<(new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask) | ((new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask))[], unknown, unknown, undefined, boolean>;
    contentStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    prevButtonProps: {
        readonly type: PropType<TourBtnProps>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    nextButtonProps: {
        readonly type: PropType<TourBtnProps>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, undefined, boolean>;
    type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "default" | "primary") | (() => "default" | "primary") | ((new (...args: any[]) => "default" | "primary") | (() => "default" | "primary"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    close: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    target: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement | (() => HTMLElement | null)) | (() => string | HTMLElement | (() => HTMLElement | null) | null) | ((new (...args: any[]) => string | HTMLElement | (() => HTMLElement | null)) | (() => string | HTMLElement | (() => HTMLElement | null) | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    title: StringConstructor;
    description: StringConstructor;
    showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    mask: EpPropFinalized<(new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask) | ((new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask))[], unknown, unknown, undefined, boolean>;
    contentStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    prevButtonProps: {
        readonly type: PropType<TourBtnProps>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    nextButtonProps: {
        readonly type: PropType<TourBtnProps>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, undefined, boolean>;
    type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "default" | "primary") | (() => "default" | "primary") | ((new (...args: any[]) => "default" | "primary") | (() => "default" | "primary"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onClose?: (() => any) | undefined;
}, {
    mask: TourMask;
    placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown>;
    scrollIntoViewOptions: EpPropMergeType<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown>;
    showArrow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    showClose: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_84: DefineComponent<{
    container: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement | Window) | (() => string | HTMLElement | Window | null) | ((new (...args: any[]) => string | HTMLElement | Window) | (() => string | HTMLElement | Window | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    bound: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    duration: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    marker: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    type: EpPropFinalized<(new (...args: any[]) => "default" | "underline") | (() => "default" | "underline") | ((new (...args: any[]) => "default" | "underline") | (() => "default" | "underline"))[], unknown, unknown, string, boolean>;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    selectScrollTop: BooleanConstructor;
}, {
    scrollTo: (href?: string) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (e: MouseEvent, href?: string | undefined) => void;
    change: (href: string) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    container: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement | Window) | (() => string | HTMLElement | Window | null) | ((new (...args: any[]) => string | HTMLElement | Window) | (() => string | HTMLElement | Window | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    bound: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    duration: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    marker: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    type: EpPropFinalized<(new (...args: any[]) => "default" | "underline") | (() => "default" | "underline") | ((new (...args: any[]) => "default" | "underline") | (() => "default" | "underline"))[], unknown, unknown, string, boolean>;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    selectScrollTop: BooleanConstructor;
}>> & {
    onChange?: ((href: string) => any) | undefined;
    onClick?: ((e: MouseEvent, href?: string | undefined) => any) | undefined;
}, {
    marker: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    direction: EpPropMergeType<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown>;
    offset: number;
    type: EpPropMergeType<(new (...args: any[]) => "default" | "underline") | (() => "default" | "underline") | ((new (...args: any[]) => "default" | "underline") | (() => "default" | "underline"))[], unknown, unknown>;
    duration: number;
    bound: number;
    selectScrollTop: boolean;
}>;
declare const __VLS_component_85: DefineComponent<{
    title: StringConstructor;
    href: StringConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    title: StringConstructor;
    href: StringConstructor;
}>>, {}>;
declare const __VLS_component_86: DefineComponent<{
    ariaLabel: StringConstructor;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
    modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
    block: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    id: StringConstructor;
    name: StringConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: any) => void;
    change: (val: any) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    ariaLabel: StringConstructor;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
    modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
    block: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    id: StringConstructor;
    name: StringConstructor;
}>> & {
    "onUpdate:modelValue"?: ((val: any) => any) | undefined;
    onChange?: ((val: any) => any) | undefined;
}, {
    disabled: boolean;
    direction: EpPropMergeType<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown>;
    block: boolean;
    props: Props;
    modelValue: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
    options: Option_3[];
    validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_87: DefineComponent<{
    options: EpPropFinalized<(new (...args: any[]) => MentionOption[]) | (() => MentionOption[]) | ((new (...args: any[]) => MentionOption[]) | (() => MentionOption[]))[], unknown, unknown, () => never[], boolean>;
    prefix: EpPropFinalized<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown, string, boolean>;
    split: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    filterOption: EpPropFinalized<(new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)) | ((new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)))[], unknown, unknown, () => (pattern: string, option: MentionOption) => boolean, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom") | ((new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom"))[], unknown, unknown, string, boolean>;
    showArrow: BooleanConstructor;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    whole: BooleanConstructor;
    checkIsWhole: {
        readonly type: PropType<(pattern: string, prefix: string) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    modelValue: StringConstructor;
    loading: BooleanConstructor;
    popperClass: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    name: StringConstructor;
    ariaLabel: StringConstructor;
    id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly: BooleanConstructor;
    clearable: BooleanConstructor;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    showPassword: BooleanConstructor;
    showWordLimit: BooleanConstructor;
    suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    autofocus: BooleanConstructor;
    rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
}, {
    input: Ref<InputInstance | undefined>;
    tooltip: Ref<TooltipInstance | undefined>;
    dropdownVisible: ComputedRef<boolean>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    input: (value: string) => void;
    search: (pattern: string, prefix: string) => void;
    select: (option: MentionOption, prefix: string) => void;
    "update:modelValue": (value: string) => void;
    blur: (evt: FocusEvent) => void;
    focus: (evt: FocusEvent) => void;
    "whole-remove": (pattern: string, prefix: string) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    options: EpPropFinalized<(new (...args: any[]) => MentionOption[]) | (() => MentionOption[]) | ((new (...args: any[]) => MentionOption[]) | (() => MentionOption[]))[], unknown, unknown, () => never[], boolean>;
    prefix: EpPropFinalized<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown, string, boolean>;
    split: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    filterOption: EpPropFinalized<(new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)) | ((new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)))[], unknown, unknown, () => (pattern: string, option: MentionOption) => boolean, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom") | ((new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom"))[], unknown, unknown, string, boolean>;
    showArrow: BooleanConstructor;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    whole: BooleanConstructor;
    checkIsWhole: {
        readonly type: PropType<(pattern: string, prefix: string) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    modelValue: StringConstructor;
    loading: BooleanConstructor;
    popperClass: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    name: StringConstructor;
    ariaLabel: StringConstructor;
    id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly: BooleanConstructor;
    clearable: BooleanConstructor;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    showPassword: BooleanConstructor;
    showWordLimit: BooleanConstructor;
    suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    autofocus: BooleanConstructor;
    rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: string) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onInput?: ((value: string) => any) | undefined;
    onSelect?: ((option: MentionOption, prefix: string) => any) | undefined;
    onSearch?: ((pattern: string, prefix: string) => any) | undefined;
    "onWhole-remove"?: ((pattern: string, prefix: string) => any) | undefined;
}, {
    disabled: boolean;
    offset: number;
    id: string;
    type: string;
    split: string;
    loading: boolean;
    placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom") | ((new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom"))[], unknown, unknown>;
    options: MentionOption[];
    tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    prefix: EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown>;
    readonly: boolean;
    autosize: InputAutoSize;
    autocomplete: string;
    containerRole: string;
    validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    inputStyle: StyleValue;
    rows: number;
    inputmode: EpPropMergeType<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown>;
    clearable: boolean;
    showPassword: boolean;
    showWordLimit: boolean;
    autofocus: boolean;
    popperOptions: Partial<Options>;
    popperClass: string;
    showArrow: boolean;
    filterOption: EpPropMergeType<(new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)) | ((new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)))[], unknown, unknown>;
    whole: boolean;
}>;
declare const __VLS_component_88: DefineComponent<{
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly lazy: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    resizeStart: (index: number, sizes: number[]) => void;
    resize: (index: number, sizes: number[]) => void;
    resizeEnd: (index: number, sizes: number[]) => void;
    collapse: (index: number, type: "end" | "start", sizes: number[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly lazy: BooleanConstructor;
}>> & {
    onResize?: ((index: number, sizes: number[]) => any) | undefined;
    onCollapse?: ((index: number, type: "end" | "start", sizes: number[]) => any) | undefined;
    onResizeStart?: ((index: number, sizes: number[]) => any) | undefined;
    onResizeEnd?: ((index: number, sizes: number[]) => any) | undefined;
}, {
    readonly layout: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly lazy: boolean;
}>;
declare const __VLS_component_89: DefineComponent<{
    readonly min: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly max: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly size: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly resizable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly collapsible: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:size": (value: number) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly min: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly max: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly size: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly resizable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly collapsible: BooleanConstructor;
}>> & {
    "onUpdate:size"?: ((value: number) => any) | undefined;
}, {
    readonly collapsible: boolean;
    readonly resizable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const __VLS_component_9: DefineComponent<{
    readonly size: EpPropFinalized<readonly [
        NumberConstructor,
        StringConstructor
    ], "" | "small" | "default" | "large", number, "", boolean>;
    readonly shape: EpPropFinalized<StringConstructor, "circle" | "square", unknown, "circle", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly src: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly alt: StringConstructor;
    readonly srcSet: StringConstructor;
    readonly fit: EpPropFinalized<(new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty) | ((new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty))[], unknown, unknown, "cover", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    error: (evt: Event) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly size: EpPropFinalized<readonly [
        NumberConstructor,
        StringConstructor
    ], "" | "small" | "default" | "large", number, "", boolean>;
    readonly shape: EpPropFinalized<StringConstructor, "circle" | "square", unknown, "circle", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly src: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly alt: StringConstructor;
    readonly srcSet: StringConstructor;
    readonly fit: EpPropFinalized<(new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty) | ((new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty))[], unknown, unknown, "cover", boolean>;
}>> & {
    onError?: ((evt: Event) => any) | undefined;
}, {
    readonly size: EpPropMergeType<readonly [
        NumberConstructor,
        StringConstructor
    ], "" | "small" | "default" | "large", number>;
    readonly shape: EpPropMergeType<StringConstructor, "circle" | "square", unknown>;
    readonly src: string;
    readonly fit: EpPropMergeType<(new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty) | ((new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty))[], unknown, unknown>;
}>;
declare const __VLS_component_90: DefineComponent<{
    readonly customClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly dangerouslyUseHTMLString: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 3000, boolean>;
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, undefined, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly message: EpPropFinalized<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown, "", boolean>;
    readonly onClose: EpPropFinalized<(new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly type: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
    readonly plain: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 16, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown, undefined, boolean>;
    readonly zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly grouping: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly repeatNum: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
}, {
    visible: Ref<boolean>;
    bottom: ComputedRef<number>;
    close: typeof close_2;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    destroy: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly customClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly dangerouslyUseHTMLString: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 3000, boolean>;
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, undefined, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly message: EpPropFinalized<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown, "", boolean>;
    readonly onClose: EpPropFinalized<(new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly type: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
    readonly plain: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 16, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown, undefined, boolean>;
    readonly zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly grouping: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly repeatNum: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
}>> & {
    onDestroy?: (() => any) | undefined;
}, {
    readonly zIndex: number;
    readonly offset: number;
    readonly icon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly id: string;
    readonly type: EpPropMergeType<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown>;
    readonly message: EpPropMergeType<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown>;
    readonly placement: EpPropMergeType<StringConstructor, "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown>;
    readonly onClose: () => void;
    readonly duration: number;
    readonly showClose: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly customClass: string;
    readonly dangerouslyUseHTMLString: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly plain: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly grouping: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly repeatNum: number;
}>;
declare const __VLS_component_91: DefineComponent<{
    readonly customClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly dangerouslyUseHTMLString: BooleanConstructor;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 4500, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly message: EpPropFinalized<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown, "", boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly onClick: EpPropFinalized<(new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => undefined, boolean>;
    readonly onClose: {
        readonly type: PropType<() => void>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly position: EpPropFinalized<StringConstructor, "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown, "top-right", boolean>;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "" | "error" | "primary" | "success" | "warning" | "info", unknown, "", boolean>;
    readonly zIndex: NumberConstructor;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    visible: Ref<boolean>;
    /** @description close notification */
    close: typeof close_3;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    destroy: () => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly customClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly dangerouslyUseHTMLString: BooleanConstructor;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 4500, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly message: EpPropFinalized<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown, "", boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly onClick: EpPropFinalized<(new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => undefined, boolean>;
    readonly onClose: {
        readonly type: PropType<() => void>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly position: EpPropFinalized<StringConstructor, "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown, "top-right", boolean>;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "" | "error" | "primary" | "success" | "warning" | "info", unknown, "", boolean>;
    readonly zIndex: NumberConstructor;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onDestroy?: (() => any) | undefined;
}, {
    readonly title: string;
    readonly position: EpPropMergeType<StringConstructor, "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown>;
    readonly offset: number;
    readonly id: string;
    readonly type: EpPropMergeType<StringConstructor, "" | "error" | "primary" | "success" | "warning" | "info", unknown>;
    readonly message: EpPropMergeType<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown>;
    readonly onClick: () => void;
    readonly duration: number;
    readonly showClose: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly customClass: string;
    readonly dangerouslyUseHTMLString: boolean;
}>;
declare const __VLS_component_92: DefineComponent<{
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown, "bottom", boolean>;
    readonly disabled: BooleanConstructor;
    readonly visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    readonly transition: StringConstructor;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly enterable: {
        readonly default: true;
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly effect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly title: StringConstructor;
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 150, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, undefined, boolean>;
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly "onUpdate:visible": {
        readonly type: PropType<(visible: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    /** @description popper ref */
    popperRef: ComputedRef<PopperInstance | undefined>;
    /** @description hide popover */
    hide: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "after-enter": () => void;
    "after-leave": () => void;
    "before-enter": () => void;
    "before-leave": () => void;
    "update:visible": (value: boolean) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown, "bottom", boolean>;
    readonly disabled: BooleanConstructor;
    readonly visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    readonly transition: StringConstructor;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly enterable: {
        readonly default: true;
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly effect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly title: StringConstructor;
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 150, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, undefined, boolean>;
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly "onUpdate:visible": {
        readonly type: PropType<(visible: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:visible"?: ((value: boolean) => any) | undefined;
    "onAfter-enter"?: (() => any) | undefined;
    "onAfter-leave"?: (() => any) | undefined;
    "onBefore-enter"?: (() => any) | undefined;
    "onBefore-leave"?: (() => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly width: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly content: string;
    readonly offset: number;
    readonly visible: EpPropMergeType<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown>;
    readonly placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown>;
    readonly effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly showAfter: number;
    readonly hideAfter: number;
    readonly autoClose: number;
    readonly tabindex: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>;
    readonly trigger: EpPropMergeType<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown>;
    readonly popperOptions: Partial<Options>;
    readonly enterable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly triggerKeys: string[];
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showArrow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare function __VLS_template(): {
    default?(_: {}): any;
};
declare function __VLS_template_10(): {
    default?(_: {}): any;
};
declare function __VLS_template_11(): {
    default?(_: {}): any;
    content?(_: {
        value: string;
    }): any;
};
declare function __VLS_template_12(): {
    default?(_: {}): any;
};
declare function __VLS_template_13(): {
    default?(_: {}): any;
};
declare function __VLS_template_14(): {
    loading?(_: {}): any;
    icon?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_15(): {
    default?(_: {}): any;
};
declare function __VLS_template_16(): {
    header?(_: {
        date: string;
    }): any;
    "date-cell"?(_: {
        data: {
            isSelected: boolean;
            type: string;
            day: string;
            date: Date;
        };
    }): any;
    "date-cell"?(_: {
        data: {
            isSelected: boolean;
            type: string;
            day: string;
            date: Date;
        };
    }): any;
};
declare function __VLS_template_17(): {
    "date-cell"?(_: {
        data: {
            isSelected: boolean;
            type: string;
            day: string;
            date: Date;
        };
    }): any;
};
declare function __VLS_template_18(): {
    header?(_: {}): any;
    default?(_: {}): any;
    footer?(_: {}): any;
};
declare function __VLS_template_19(): {
    default?(_: {}): any;
};
declare function __VLS_template_2(): {
    icon?(_: {}): any;
    title?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_20(): {
    default?(_: {}): any;
};
declare function __VLS_template_21(): {
    empty?(_: {}): any;
};
declare function __VLS_template_22(): {
    empty?(_: {}): any;
};
declare function __VLS_template_23(): {
    prefix?(_: {}): any;
    tag?(_: {
        data: Tag[];
        deleteTag: (tag: Tag) => void;
    }): any;
    header?(_: {}): any;
    empty?(_: {}): any;
    empty?(_: {}): any;
    "suggestion-item"?(_: {
        item: CascaderNode;
    }): any;
    footer?(_: {}): any;
};
declare function __VLS_template_24(): {
    default?(_: {}): any;
};
declare function __VLS_template_25(): {
    default?(_: {}): any;
};
declare function __VLS_template_26(): {
    default?(_: {}): any;
};
declare function __VLS_template_27(): {
    default?(_: {}): any;
};
declare function __VLS_template_28(): {
    default?(_: {}): any;
};
declare function __VLS_template_29(): {
    default?(_: {}): any;
};
declare function __VLS_template_3(): {
    prepend?(_: {}): any;
    prefix?(_: {}): any;
    suffix?(_: {}): any;
    append?(_: {}): any;
};
declare function __VLS_template_30(): {
    title?(_: {
        isActive: boolean | undefined;
    }): any;
    icon?(_: {
        isActive: boolean | undefined;
    }): any;
    default?(_: {}): any;
};
declare function __VLS_template_31(): {
    default?(_: {}): any;
};
declare function __VLS_template_32(): {
    footer?(_: {}): any;
};
declare function __VLS_template_33(): {
    default?(_: {}): any;
};
declare function __VLS_template_34(): {
    default?(_: {}): any;
};
declare function __VLS_template_35(): {
    default?(_: {}): any;
};
declare function __VLS_template_36(): {
    default?(_: {}): any;
};
declare function __VLS_template_37(): {
    default?(_: {}): any;
};
declare function __VLS_template_38(): Partial<Record<NonNullable<string | number>, (_: {}) => any>>;
declare function __VLS_template_39(): {
    title?(_: {}): any;
    extra?(_: {}): any;
};
declare function __VLS_template_4(): {
    default?(_: {}): any;
};
declare function __VLS_template_40(): {
    header?(_: {
        close: () => void;
        titleId: string;
        titleClass: string;
    }): any;
    title?(_: {}): any;
    default?(_: {}): any;
    footer?(_: {}): any;
};
declare function __VLS_template_41(): {
    default?(_: {}): any;
};
declare function __VLS_template_42(): {
    header?(_: {
        close: () => void;
        titleId: string;
        titleClass: string;
    }): any;
    title?(_: {}): any;
    default?(_: {}): any;
    footer?(_: {}): any;
};
declare function __VLS_template_43(): {
    image?(_: {}): any;
    description?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_44(): {
    default?(_: {}): any;
};
declare function __VLS_template_45(): {
    label?(_: {
        label: string;
    }): any;
    default?(_: {}): any;
    error?(_: {
        error: string;
    }): any;
};
declare function __VLS_template_46(): {
    default?(_: {}): any;
};
declare function __VLS_template_47(): {
    error?(_: {}): any;
    placeholder?(_: {}): any;
    viewer?(_: {}): any;
    progress?(_: {
        activeIndex: number;
        total: number;
    }): any;
    toolbar?(_: {
        actions: (action: ImageViewerAction, options?: {}) => void;
        prev: () => void;
        next: () => void;
        reset: () => void;
        activeIndex: number;
        setActiveItem: (index: number) => void;
    }): any;
};
declare function __VLS_template_48(): {
    progress?(_: {
        activeIndex: number;
        total: number;
    }): any;
    toolbar?(_: {
        actions: typeof handleActions;
        prev: typeof prev;
        next: typeof next;
        reset: typeof toggleMode;
        activeIndex: number;
        setActiveItem: typeof setActiveItem;
    }): any;
    default?(_: {}): any;
};
declare function __VLS_template_49(): {
    "decrease-icon"?(_: {}): any;
    "increase-icon"?(_: {}): any;
    prefix?(_: {}): any;
    suffix?(_: {}): any;
};
declare function __VLS_template_5(): {
    default?(_: {}): any;
};
declare function __VLS_template_50(): {
    prefix?(_: {}): any;
    tag?(_: {
        value: string;
        index: number;
    }): any;
    tag?(_: {
        value: string;
        index: number;
    }): any;
    suffix?(_: {}): any;
};
declare function __VLS_template_51(): {
    default?(_: {}): any;
    icon?(_: {}): any;
};
declare function __VLS_template_52(): {
    title?(_: {}): any;
    title?(_: {}): any;
    default?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_53(): {
    title?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_54(): {
    breadcrumb?(_: {}): any;
    icon?(_: {}): any;
    title?(_: {}): any;
    content?(_: {}): any;
    extra?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_55(): {
    actions?(_: {
        confirm: (e: MouseEvent) => void;
        cancel: (e: MouseEvent) => void;
    }): any;
    reference?(_: {}): any;
};
declare function __VLS_template_56(): {
    default?(_: {}): any;
};
declare function __VLS_template_57(): {
    default?(_: {
        percentage: number;
    }): any;
    default?(_: {
        percentage: number;
    }): any;
};
declare function __VLS_template_58(): {
    default?(_: {}): any;
};
declare function __VLS_template_59(): {
    default?(_: {}): any;
};
declare function __VLS_template_6(): {
    default?(_: {}): any;
};
declare function __VLS_template_60(): {
    default?(_: {}): any;
};
declare function __VLS_template_61(): {
    icon?(_: {}): any;
    title?(_: {}): any;
    "sub-title"?(_: {}): any;
    extra?(_: {}): any;
};
declare function __VLS_template_62(): {
    default?(_: {}): any;
};
declare function __VLS_template_63(): {
    default?(_: {}): any;
};
declare function __VLS_template_64(): {
    template?(_: {
        key: number;
    }): any;
    default?(_: {
        [x: string]: unknown;
    }): any;
};
declare function __VLS_template_65(): {
    title?(_: {}): any;
    prefix?(_: {}): any;
    suffix?(_: {}): any;
};
declare function __VLS_template_66(): {
    default?(_: {}): any;
};
declare function __VLS_template_67(): {
    icon?(_: {}): any;
    title?(_: {}): any;
    description?(_: {}): any;
};
declare function __VLS_template_68(): {
    "active-action"?(_: {}): any;
    "inactive-action"?(_: {}): any;
};
declare function __VLS_template_69(): {
    default?(_: {}): any;
};
declare function __VLS_template_7(): {
    default?(_: {}): any;
    content?(_: {}): any;
};
declare function __VLS_template_70(): {
    default?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_71(): {
    default?(_: {}): any;
};
declare function __VLS_template_72(): {
    "range-separator"?(_: {}): any;
    default?(_: {
        visible: boolean;
        actualVisible: boolean;
        parsedValue: DayOrDays;
        format: string | undefined;
        dateFormat: string | undefined;
        timeFormat: string | undefined;
        unlinkPanels: boolean;
        type: string;
        defaultValue: EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown> | undefined;
        showNow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        showConfirm: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        showFooter: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        showWeekNumber: boolean;
        onMousedown: any;
        onPanelChange: any;
        onCalendarChange: any;
        onSetPickerOption: any;
        onSelectRange: any;
        onPick: any;
    }): any;
};
declare function __VLS_template_73(): {
    dot?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_74(): {
    empty?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_75(): {
    "left-empty"?(_: {}): any;
    "left-footer"?(_: {}): any;
    "right-empty"?(_: {}): any;
    "right-footer"?(_: {}): any;
};
declare function __VLS_template_76(): {
    empty?(_: {}): any;
};
declare function __VLS_template_77(): {
    file?(_: {
        file: UploadFile;
        index: number;
    }): any;
    file?(_: {
        file: UploadFile;
        index: number;
    }): any;
    trigger?(_: {}): any;
    trigger?(_: {}): any;
    default?(_: {}): any;
    default?(_: {}): any;
    default?(_: {}): any;
    tip?(_: {}): any;
};
declare function __VLS_template_78(): {
    default?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_79(): {
    default?(_: {
        file: UploadFile;
        index: number;
    }): any;
    append?(_: {}): any;
};
declare function __VLS_template_8(): {
    prepend?(_: {}): any;
    append?(_: {}): any;
    prefix?(_: {}): any;
    suffix?(_: {}): any;
    header?(_: {}): any;
    loading?(_: {}): any;
    default?(_: {
        item: Record<string, any>;
    }): any;
    footer?(_: {}): any;
};
declare function __VLS_template_80(): {
    default?(_: {}): any;
};
declare function __VLS_template_81(): {
    default?(_: {}): any;
};
declare function __VLS_template_82(): {
    default?(_: {}): any;
    indicators?(_: {
        current: number;
        total: number;
    }): any;
};
declare function __VLS_template_83(): {
    header?(_: {}): any;
    default?(_: {}): any;
};
declare function __VLS_template_84(): {
    default?(_: {}): any;
};
declare function __VLS_template_85(): {
    default?(_: {}): any;
    "sub-link"?(_: {}): any;
};
declare function __VLS_template_86(): {
    default?(_: {
        item: any;
    }): any;
};
declare function __VLS_template_87(): Partial<Record<NonNullable<string | number>, (_: any) => any>> & Partial<Record<NonNullable<string | number>, (_: any) => any>>;
declare function __VLS_template_88(): {
    default?(_: {}): any;
};
declare function __VLS_template_89(): {
    default?(_: {}): any;
    "start-collapsible"?(_: {}): any;
    "end-collapsible"?(_: {}): any;
};
declare function __VLS_template_9(): {
    default?(_: {}): any;
};
declare function __VLS_template_90(): {
    default?(_: {}): any;
};
declare function __VLS_template_91(): {
    default?(_: {}): any;
};
declare function __VLS_template_92(): {
    reference?(_: {}): any;
    default?(_: {}): any;
};
declare type __VLS_WithTemplateSlots<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_10<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_11<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_12<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_13<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_14<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_15<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_16<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_17<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_18<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_19<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_2<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_20<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_21<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_22<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_23<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_24<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_25<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_26<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_27<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_28<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_29<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_3<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_30<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_31<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_32<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_33<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_34<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_35<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_36<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_37<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_38<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_39<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_4<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_40<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_41<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_42<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_43<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_44<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_45<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_46<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_47<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_48<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_49<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_5<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_50<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_51<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_52<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_53<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_54<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_55<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_56<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_57<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_58<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_59<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_6<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_60<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_61<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_62<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_63<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_64<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_65<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_66<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_67<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_68<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_69<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_7<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_70<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_71<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_72<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_73<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_74<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_75<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_76<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_77<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_78<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_79<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_8<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_80<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_81<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_82<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_83<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_84<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_85<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_86<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_87<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_88<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_89<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_9<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_90<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_91<T, S> = T & {
    new (): {
        $slots: S;
    };
};
declare type __VLS_WithTemplateSlots_92<T, S> = T & {
    new (): {
        $slots: S;
    };
};
export declare type Action = "confirm" | "close" | "cancel";
export declare type AffixEmits = typeof affixEmits;
export declare const affixEmits: {
    scroll: ({ scrollTop, fixed }: {
        scrollTop: number;
        fixed: boolean;
    }) => boolean;
    change: (fixed: boolean) => boolean;
};
export declare type AffixInstance = InstanceType<typeof _default_2> & unknown;
export declare type AffixProps = ExtractPropTypes<typeof affixProps>;
export declare const affixProps: {
    readonly zIndex: EpPropFinalized<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown, 100, boolean>;
    readonly target: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly position: EpPropFinalized<StringConstructor, "top" | "bottom", unknown, "top", boolean>;
};
export declare type AffixPropsPublic = __ExtractPublicPropTypes<typeof affixProps>;
export declare const alertEffects: readonly [
    "light",
    "dark"
];
export declare type AlertEmits = typeof alertEmits;
export declare const alertEmits: {
    open: () => boolean;
    close: (evt?: Event) => boolean;
};
export declare type AlertInstance = InstanceType<typeof _default_3> & unknown;
export declare type AlertProps = ExtractPropTypes<typeof alertProps>;
export declare const alertProps: {
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
    readonly closable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly showIcon: BooleanConstructor;
    readonly center: BooleanConstructor;
    readonly effect: EpPropFinalized<StringConstructor, "dark" | "light", unknown, "light", boolean>;
};
export declare type AlertPropsPublic = __ExtractPublicPropTypes<typeof alertProps>;
export declare type Alignment = "auto" | "smart" | "center" | "start" | "end";
declare type Alignment_2 = ColumnAlignment;
export declare type AllowDragFunction = (node: Node_2) => boolean;
export declare type AllowDropFunction = (draggingNode: Node_2, dropNode: Node_2, type: AllowDropType) => boolean;
export declare type AllowDropType = "inner" | "prev" | "next";
export declare type AnchorEmits = typeof anchorEmits;
export declare const anchorEmits: {
    change: (href: string) => boolean;
    click: (e: MouseEvent, href?: string) => boolean;
};
export declare type AnchorInstance = InstanceType<typeof _default_106> & unknown;
export declare type AnchorProps = ExtractPropTypes<typeof anchorProps>;
export declare const anchorProps: {
    container: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement | Window) | (() => string | HTMLElement | Window | null) | ((new (...args: any[]) => string | HTMLElement | Window) | (() => string | HTMLElement | Window | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    bound: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    duration: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    marker: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    type: EpPropFinalized<(new (...args: any[]) => "default" | "underline") | (() => "default" | "underline") | ((new (...args: any[]) => "default" | "underline") | (() => "default" | "underline"))[], unknown, unknown, string, boolean>;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    selectScrollTop: BooleanConstructor;
};
export declare type AnchorPropsPublic = __ExtractPublicPropTypes<typeof anchorProps>;
declare type AnyColumn = Column<any>;
declare type AnyColumns = Columns<any>;
export declare const ariaProps: {
    ariaLabel: StringConstructor;
    ariaOrientation: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    ariaControls: StringConstructor;
};
declare type Arrayable<T> = T | T[];
/**
 * Array index key
 *
 * 
 */
declare type ArrayKey = number;
/**
 * Array method key
 *
 * 
 */
declare type ArrayMethodKey = keyof any[];
export declare const arrowMiddleware: ({ arrowRef, padding, }: ArrowMiddlewareProps) => Middleware;
export declare type ArrowMiddlewareProps = {
    arrowRef: Ref<HTMLElement | null | undefined>;
    padding?: number | SideObject_2;
};
export declare type AsideInstance = InstanceType<typeof _default_35> & unknown;
export declare type AutocompleteData = Record<string, any>[];
export declare type AutocompleteEmits = typeof autocompleteEmits;
export declare const autocompleteEmits: {
    "update:modelValue": (value: string) => boolean;
    input: (value: string) => boolean;
    change: (value: string) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
    clear: () => boolean;
    select: (item: Record<string, any>) => boolean;
};
export declare type AutocompleteFetchSuggestions = ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void) | AutocompleteData;
export declare type AutocompleteFetchSuggestionsCallback = (data: AutocompleteData) => void;
export declare type AutocompleteInstance = InstanceType<typeof _default_4> & unknown;
export declare type AutocompleteProps = ExtractPropTypes<typeof autocompleteProps>;
export declare const autocompleteProps: {
    readonly valueKey: EpPropFinalized<StringConstructor, unknown, unknown, "value", boolean>;
    readonly modelValue: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly debounce: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], "top" | "bottom" | "top-start" | "top-end" | "bottom-start" | "bottom-end", unknown, "bottom-start", boolean>;
    readonly fetchSuggestions: EpPropFinalized<(new (...args: any[]) => AutocompleteData | ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void)) | (() => AutocompleteFetchSuggestions) | ((new (...args: any[]) => AutocompleteData | ((queryString: string, cb: AutocompleteFetchSuggestionsCallback) => Awaitable<AutocompleteData> | void)) | (() => AutocompleteFetchSuggestions))[], unknown, unknown, () => void, boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly triggerOnFocus: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly selectWhenUnmatched: BooleanConstructor;
    readonly hideLoading: BooleanConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly highlightFirstItem: BooleanConstructor;
    readonly fitInputWidth: BooleanConstructor;
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly name: StringConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    readonly resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showPassword: BooleanConstructor;
    readonly showWordLimit: BooleanConstructor;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly autofocus: BooleanConstructor;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
};
export declare type AutocompletePropsPublic = __ExtractPublicPropTypes<typeof autocompleteProps>;
declare type AutoResizeHandler = (event: {
    height: number;
    width: number;
}) => void;
declare const AutoResizer: DefineComponent<{
    readonly disableWidth: BooleanConstructor;
    readonly disableHeight: BooleanConstructor;
    readonly onResize: {
        readonly type: PropType<(event: {
            height: number;
            width: number;
        }) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly disableWidth: BooleanConstructor;
    readonly disableHeight: BooleanConstructor;
    readonly onResize: {
        readonly type: PropType<(event: {
            height: number;
            width: number;
        }) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly disableWidth: boolean;
    readonly disableHeight: boolean;
}>;
export declare type AutoResizerProps = ExtractPropTypes<typeof autoResizerProps>;
export declare const autoResizerProps: {
    readonly disableWidth: BooleanConstructor;
    readonly disableHeight: BooleanConstructor;
    readonly onResize: {
        readonly type: PropType<AutoResizeHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type AutoResizerPropsPublic = __ExtractPublicPropTypes<typeof autoResizerProps>;
export declare type AvatarEmits = typeof avatarEmits;
export declare const avatarEmits: {
    error: (evt: Event) => boolean;
};
export declare type AvatarInstance = InstanceType<typeof _default_9> & unknown;
export declare type AvatarProps = ExtractPropTypes<typeof avatarProps>;
export declare const avatarProps: {
    readonly size: EpPropFinalized<readonly [
        NumberConstructor,
        StringConstructor
    ], "" | "small" | "default" | "large", number, "", boolean>;
    readonly shape: EpPropFinalized<StringConstructor, "circle" | "square", unknown, "circle", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly src: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly alt: StringConstructor;
    readonly srcSet: StringConstructor;
    readonly fit: EpPropFinalized<(new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty) | ((new (...args: any[]) => "fill" | "contain" | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "none" | "cover" | "scale-down") | (() => ObjectFitProperty))[], unknown, unknown, "cover", boolean>;
};
export declare type AvatarPropsPublic = __ExtractPublicPropTypes<typeof avatarProps>;
declare type Awaitable<T> = Promise<T> | T;
export declare type BacktopEmits = typeof backtopEmits;
export declare const backtopEmits: {
    click: (evt: MouseEvent) => boolean;
};
export declare type BacktopInstance = InstanceType<typeof _default_10> & unknown;
export declare type BacktopProps = ExtractPropTypes<typeof backtopProps>;
export declare const backtopProps: {
    /**
     * @description the button will not show until the scroll height reaches this value.
     */
    readonly visibilityHeight: {
        readonly type: NumberConstructor;
        readonly default: 200;
    };
    /**
     * @description the target to trigger scroll.
     */
    readonly target: {
        readonly type: StringConstructor;
        readonly default: "";
    };
    /**
     * @description right distance.
     */
    readonly right: {
        readonly type: NumberConstructor;
        readonly default: 40;
    };
    /**
     * @description bottom distance.
     */
    readonly bottom: {
        readonly type: NumberConstructor;
        readonly default: 40;
    };
};
export declare type BacktopPropsPublic = __ExtractPublicPropTypes<typeof backtopProps>;
declare const BACKWARD = "backward";
export declare type BadgeInstance = InstanceType<typeof _default_11> & unknown;
export declare type BadgeProps = ExtractPropTypes<typeof badgeProps>;
export declare const badgeProps: {
    readonly value: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 99, boolean>;
    readonly isDot: BooleanConstructor;
    readonly hidden: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "danger", boolean>;
    readonly showZero: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly color: StringConstructor;
    readonly badgeStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly offset: EpPropFinalized<(new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]) | ((new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]))[], unknown, unknown, readonly [
        0,
        0
    ], boolean>;
    readonly badgeClass: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type BadgePropsPublic = __ExtractPublicPropTypes<typeof badgeProps>;
export declare const BAR_MAP: {
    readonly vertical: {
        readonly offset: "offsetHeight";
        readonly scroll: "scrollTop";
        readonly scrollSize: "scrollHeight";
        readonly size: "height";
        readonly key: "vertical";
        readonly axis: "Y";
        readonly client: "clientY";
        readonly direction: "top";
    };
    readonly horizontal: {
        readonly offset: "offsetWidth";
        readonly scroll: "scrollLeft";
        readonly scrollSize: "scrollWidth";
        readonly size: "width";
        readonly key: "horizontal";
        readonly axis: "X";
        readonly client: "clientX";
        readonly direction: "left";
    };
};
declare function blur_2(): void;
export declare type BorderStyle = CSSStyleDeclaration["borderStyle"];
export declare type BreadcrumbInstance = InstanceType<typeof _default_12> & unknown;
export declare type BreadcrumbItemInstance = InstanceType<typeof _default_13> & unknown;
export declare type BreadcrumbItemProps = ExtractPropTypes<typeof breadcrumbItemProps>;
export declare const breadcrumbItemProps: {
    readonly to: EpPropFinalized<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown, "", boolean>;
    readonly replace: BooleanConstructor;
};
export declare type BreadcrumbItemPropsPublic = __ExtractPublicPropTypes<typeof breadcrumbItemProps>;
export declare const breadcrumbKey: InjectionKey<BreadcrumbProps>;
export declare type BreadcrumbProps = ExtractPropTypes<typeof breadcrumbProps>;
export declare const breadcrumbProps: {
    readonly separator: EpPropFinalized<StringConstructor, unknown, unknown, "/", boolean>;
    readonly separatorIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type BreadcrumbPropsPublic = __ExtractPublicPropTypes<typeof breadcrumbProps>;
declare type BrowserNativeObject = Date | FileList | File | Blob | RegExp;
export declare const buildLocaleContext: (locale: MaybeRef<Language>) => LocaleContext;
export declare const buildTimeList: (value: number, bound: number) => TimeList;
export declare const buildTranslator: (locale: MaybeRef<Language>) => Translator;
export declare interface ButtonConfigContext {
    type?: string;
    plain?: boolean;
    text?: boolean;
    round?: boolean;
    autoInsertSpace?: boolean;
}
export declare type ButtonEmits = typeof buttonEmits;
export declare const buttonEmits: {
    click: (evt: MouseEvent) => boolean;
};
export declare interface ButtonGroupContext {
    size?: ButtonProps["size"];
    type?: ButtonProps["type"];
}
export declare const buttonGroupContextKey: InjectionKey<ButtonGroupContext>;
export declare type ButtonGroupInstance = InstanceType<typeof _default_15> & unknown;
export declare type ButtonInstance = InstanceType<typeof _default_14> & unknown;
export declare type ButtonNativeType = ButtonProps["nativeType"];
export declare const buttonNativeTypes: readonly [
    "button",
    "submit",
    "reset"
];
export declare type ButtonProps = ExtractPropTypes<typeof buttonProps>;
export declare const buttonProps: {
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly nativeType: EpPropFinalized<StringConstructor, "button" | "reset" | "submit", unknown, "button", boolean>;
    readonly loading: BooleanConstructor;
    readonly loadingIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly plain: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly text: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly link: BooleanConstructor;
    readonly bg: BooleanConstructor;
    readonly autofocus: BooleanConstructor;
    readonly round: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly circle: BooleanConstructor;
    readonly color: StringConstructor;
    readonly dark: BooleanConstructor;
    readonly autoInsertSpace: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly tag: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "button", boolean>;
};
export declare type ButtonPropsPublic = __ExtractPublicPropTypes<typeof buttonProps>;
export declare type ButtonType = ButtonProps["type"];
export declare const buttonTypes: readonly [
    "default",
    "primary",
    "success",
    "warning",
    "info",
    "danger",
    "text",
    ""
];
declare type CalendarDateCellType = "next" | "prev" | "current";
export declare type CalendarDateTableInstance = DateTableInstance;
export declare type CalendarDateType = "prev-month" | "next-month" | "prev-year" | "next-year" | "today";
export declare type CalendarEmits = typeof calendarEmits;
export declare const calendarEmits: {
    "update:modelValue": (value: Date) => boolean;
    input: (value: Date) => boolean;
};
export declare type CalendarInstance = InstanceType<typeof _default_16> & unknown;
export declare type CalendarProps = ExtractPropTypes<typeof calendarProps>;
export declare const calendarProps: {
    readonly modelValue: {
        readonly type: PropType<Date>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly range: {
        readonly type: PropType<[
            Date,
            Date
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type CalendarPropsPublic = __ExtractPublicPropTypes<typeof calendarProps>;
export declare type Callback = ((value: string, action: Action) => any) | ((action: Action) => any);
export declare interface CardConfigContext {
    shadow?: string;
}
export declare const cardContextKey: InjectionKey<CardConfigContext>;
export declare type CardInstance = InstanceType<typeof _default_18> & unknown;
export declare type CardProps = ExtractPropTypes<typeof cardProps>;
export declare const cardProps: {
    readonly header: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly footer: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly bodyStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly shadow: EpPropFinalized<StringConstructor, "always" | "never" | "hover", unknown, undefined, boolean>;
};
export declare type CardPropsPublic = __ExtractPublicPropTypes<typeof cardProps>;
export declare const CAROUSEL_ITEM_NAME = "ElCarouselItem";
export declare type CarouselContext = {
    root: Ref<HTMLElement | undefined>;
    items: Ref<CarouselItemContext[]>;
    isCardType: Ref<boolean>;
    isVertical: Ref<boolean>;
    loop: boolean;
    cardScale: number;
    addItem: (item: CarouselItemContext) => void;
    removeItem: (item: CarouselItemContext) => void;
    setActiveItem: (index: number) => void;
    setContainerHeight: (height: number) => void;
};
export declare const carouselContextKey: InjectionKey<CarouselContext>;
export declare type CarouselEmits = typeof carouselEmits;
export declare const carouselEmits: {
    /**
     * @description triggers when the active slide switches
     * @param current index of the new active slide
     * @param prev index of the old active slide
     */
    change: (current: number, prev: number) => boolean;
};
export declare type CarouselInstance = InstanceType<typeof _default_19> & unknown;
export declare type CarouselItemContext = {
    props: CarouselItemProps;
    states: CarouselItemStates;
    uid: number;
    getVnode: () => VNode;
    translateItem: (index: number, activeIndex: number, oldIndex?: number) => void;
};
export declare type CarouselItemInstance = InstanceType<typeof _default_20> & unknown;
export declare type CarouselItemProps = ExtractPropTypes<typeof carouselItemProps>;
export declare const carouselItemProps: {
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly label: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
};
export declare type CarouselItemPropsPublic = __ExtractPublicPropTypes<typeof carouselItemProps>;
export declare type CarouselItemStates = {
    hover: boolean;
    translate: number;
    scale: number;
    active: boolean;
    ready: boolean;
    inStage: boolean;
    animating: boolean;
};
export declare type CarouselProps = ExtractPropTypes<typeof carouselProps>;
export declare const carouselProps: {
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly height: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly trigger: EpPropFinalized<StringConstructor, "click" | "hover", unknown, "hover", boolean>;
    readonly autoplay: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly interval: EpPropFinalized<NumberConstructor, unknown, unknown, 3000, boolean>;
    readonly indicatorPosition: EpPropFinalized<StringConstructor, "" | "none" | "outside", unknown, "", boolean>;
    readonly arrow: EpPropFinalized<StringConstructor, "always" | "never" | "hover", unknown, "hover", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "" | "card", unknown, "", boolean>;
    readonly cardScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.83, boolean>;
    readonly loop: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly pauseOnHover: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly motionBlur: BooleanConstructor;
};
export declare type CarouselPropsPublic = __ExtractPublicPropTypes<typeof carouselProps>;
export declare const CASCADER_PANEL_INJECTION_KEY: InjectionKey<ElCascaderPanelContext>;
export declare type CascaderConfig = Required<CascaderProps>;
declare type CascaderConfig_2 = Required<CascaderProps>;
export declare type CascaderEmits = typeof cascaderEmits;
export declare const cascaderEmits: {
    "update:modelValue": (value: CascaderValue | null | undefined) => boolean;
    change: (value: CascaderValue | null | undefined) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
    clear: () => boolean;
    visibleChange: (val: boolean) => boolean;
    expandChange: (val: CascaderValue) => boolean;
    removeTag: (val: CascaderNode["valueByOption"]) => boolean;
};
export declare type CascaderInstance = InstanceType<typeof _default_21> & unknown;
export declare type CascaderMenuInstance = InstanceType<typeof _default_23> & unknown;
export declare class CascaderNode {
    readonly data: CascaderOption;
    readonly config: CascaderConfig_2;
    readonly parent?: CascaderNode | undefined;
    readonly root: boolean;
    readonly uid: number;
    readonly level: number;
    readonly value: CascaderNodeValue_2;
    readonly label: string;
    readonly pathNodes: CascaderNode[];
    readonly pathValues: CascaderNodePathValue_2;
    readonly pathLabels: string[];
    childrenData: ChildrenData;
    children: CascaderNode[];
    text: string;
    loaded: boolean;
    /**
     * Is it checked
     *
     * @default false
     */
    checked: boolean;
    /**
     * Used to indicate the intermediate state of unchecked and fully checked child nodes
     *
     * @default false
     */
    indeterminate: boolean;
    /**
     * Loading Status
     *
     * @default false
     */
    loading: boolean;
    constructor(data: CascaderOption, config: CascaderConfig_2, parent?: CascaderNode | undefined, root?: boolean);
    get isDisabled(): boolean;
    get isLeaf(): boolean;
    get valueByOption(): CascaderNodeValue_2 | CascaderNodePathValue_2;
    appendChild(childData: CascaderOption): CascaderNode;
    calcText(allLevels: boolean, separator: string): string;
    broadcast(checked: boolean): void;
    emit(): void;
    onParentCheck(checked: boolean): void;
    onChildCheck(): void;
    setCheckState(checked: boolean): void;
    doCheck(checked: boolean): void;
}
export declare type CascaderNodePathValue = CascaderNodeValue[];
declare type CascaderNodePathValue_2 = CascaderNodeValue_2[];
export declare type CascaderNodeValue = string | number;
declare type CascaderNodeValue_2 = string | number;
export declare interface CascaderOption extends Record<string, unknown> {
    label?: string;
    value?: CascaderNodeValue_2;
    children?: CascaderOption[];
    disabled?: boolean;
    leaf?: boolean;
}
export declare const cascaderPanelEmits: {
    "update:modelValue": (value: CascaderValue_2 | undefined | null) => boolean;
    change: (value: CascaderValue_2 | undefined | null) => boolean;
    close: () => boolean;
    "expand-change": (value: CascaderNodePathValue_2) => CascaderNodePathValue_2;
};
export declare type CascaderPanelInstance = InstanceType<typeof _default_22> & unknown;
export declare const cascaderPanelProps: {
    border: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    renderLabel: {
        readonly type: PropType<RenderLabel_2>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
};
export declare interface CascaderProps {
    expandTrigger?: ExpandTrigger;
    multiple?: boolean;
    checkStrictly?: boolean;
    emitPath?: boolean;
    lazy?: boolean;
    lazyLoad?: LazyLoad_2;
    value?: string;
    label?: string;
    children?: string;
    disabled?: string | isDisabled_2;
    leaf?: string | isLeaf_2;
    hoverThreshold?: number;
    checkOnClickNode?: boolean;
    checkOnClickLeaf?: boolean;
    showPrefix?: boolean;
}
export declare const cascaderProps: {
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placeholder: StringConstructor;
    disabled: BooleanConstructor;
    clearable: BooleanConstructor;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    filterable: BooleanConstructor;
    filterMethod: EpPropFinalized<(new (...args: any[]) => (node: CascaderNode, keyword: string) => boolean) | (() => (node: CascaderNode, keyword: string) => boolean) | {
        (): (node: CascaderNode, keyword: string) => boolean;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (node: CascaderNode, keyword: string) => boolean) | (() => (node: CascaderNode, keyword: string) => boolean) | {
        (): (node: CascaderNode, keyword: string) => boolean;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, (node: CascaderNode, keyword: string) => boolean, boolean>;
    separator: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    showAllLevels: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    collapseTags: BooleanConstructor;
    maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    collapseTagsTooltip: BooleanConstructor;
    maxCollapseTagsTooltipHeight: {
        readonly type: PropType<EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    debounce: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    beforeFilter: EpPropFinalized<(new (...args: any[]) => (value: string) => boolean | Promise<any>) | (() => (value: string) => boolean | Promise<any>) | {
        (): (value: string) => boolean | Promise<any>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (value: string) => boolean | Promise<any>) | (() => (value: string) => boolean | Promise<any>) | {
        (): (value: string) => boolean | Promise<any>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, string, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, string[], boolean>;
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, string, boolean>;
    tagType: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagEffect: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    showCheckedStrategy: EpPropFinalized<StringConstructor, string, unknown, string, boolean>;
    checkOnClickNode: BooleanConstructor;
    showPrefix: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
};
export declare type CascaderValue = CascaderNodeValue | CascaderNodePathValue | (CascaderNodeValue | CascaderNodePathValue)[];
declare type CascaderValue_2 = CascaderNodeValue_2 | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[];
export declare type CellCls<T extends DefaultRow> = string | ((data: {
    row: T;
    rowIndex: number;
    column: TableColumnCtx<T>;
    columnIndex: number;
}) => string);
/**
 * Renderer/Getter types
 */
declare type CellRenderer<T> = (params: CellRendererParams<T>) => VNode;
/**
 * Param types
 */
declare type CellRendererParams<T> = {
    cellData: T;
} & RowCommonParams & ColumnCommonParams<T>;
export declare type CellStyle<T extends DefaultRow> = CSSProperties | ((data: {
    row: T;
    rowIndex: number;
    column: TableColumnCtx<T>;
    columnIndex: number;
}) => CSSProperties);
export declare const CHANGE_EVENT = "change";
export declare type CheckboxEmits = typeof checkboxEmits;
export declare const checkboxEmits: {
    "update:modelValue": (val: CheckboxValueType) => val is string | number | boolean;
    change: (val: CheckboxValueType) => val is string | number | boolean;
};
declare type CheckboxGroupContext = {
    modelValue?: WritableComputedRef<any>;
    changeEvent?: (...args: any) => any;
} & ToRefs<Pick<CheckboxGroupProps, "size" | "min" | "max" | "disabled" | "validateEvent" | "fill" | "textColor">>;
export declare const checkboxGroupContextKey: InjectionKey<CheckboxGroupContext>;
export declare type CheckboxGroupEmits = typeof checkboxGroupEmits;
export declare const checkboxGroupEmits: {
    "update:modelValue": (val: CheckboxGroupValueType) => boolean;
    change: (val: CheckboxValueType[]) => boolean;
};
export declare type CheckboxGroupInstance = InstanceType<typeof _default_27> & unknown;
export declare type CheckboxGroupProps = ExtractPropTypes<typeof checkboxGroupProps>;
export declare const checkboxGroupProps: {
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => CheckboxGroupValueType) | (() => CheckboxGroupValueType) | ((new (...args: any[]) => CheckboxGroupValueType) | (() => CheckboxGroupValueType))[], unknown, unknown, () => never[], boolean>;
    readonly disabled: BooleanConstructor;
    readonly min: NumberConstructor;
    readonly max: NumberConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fill: StringConstructor;
    readonly textColor: StringConstructor;
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare type CheckboxGroupPropsPublic = __ExtractPublicPropTypes<typeof checkboxGroupProps>;
export declare type CheckboxGroupValueType = Exclude<CheckboxValueType, boolean>[];
export declare type CheckboxInstance = InstanceType<typeof _default_25> & unknown;
export declare type CheckboxProps = ExtractPropTypes<typeof checkboxProps>;
export declare const checkboxProps: {
    ariaControls: StringConstructor;
    /**
     * @description binding value
     */
    modelValue: {
        type: (BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @description label of the Checkbox when used inside a `checkbox-group`
     */
    label: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @description value of the Checkbox when used inside a `checkbox-group`
     */
    value: {
        type: (ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @description Set indeterminate state, only responsible for style control
     */
    indeterminate: BooleanConstructor;
    /**
     * @description whether the Checkbox is disabled
     */
    disabled: BooleanConstructor;
    /**
     * @description if the Checkbox is checked
     */
    checked: BooleanConstructor;
    /**
     * @description native 'name' attribute
     */
    name: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * @description value of the Checkbox if it's checked
     */
    trueValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @description value of the Checkbox if it's not checked
     */
    falseValue: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @deprecated use `trueValue` instead
     * @description value of the Checkbox if it's checked
     */
    trueLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @deprecated use `falseValue` instead
     * @description value of the Checkbox if it's not checked
     */
    falseLabel: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    /**
     * @description input id
     */
    id: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * @description whether to add a border around Checkbox
     */
    border: BooleanConstructor;
    /**
     * @description size of the Checkbox
     */
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    /**
     * @description input tabindex
     */
    tabindex: (NumberConstructor | StringConstructor)[];
    /**
     * @description whether to trigger form validation
     */
    validateEvent: {
        type: BooleanConstructor;
        default: boolean;
    };
};
export declare type CheckboxPropsPublic = __ExtractPublicPropTypes<typeof checkboxProps>;
export declare type CheckboxValueType = string | number | boolean;
declare interface CheckedInfo {
    checkedKeys: TreeKey_2[];
    checkedNodes: TreeData_3;
    halfCheckedKeys: TreeKey_2[];
    halfCheckedNodes: TreeData_3;
}
export declare type CheckTagEmits = typeof checkTagEmits;
export declare const checkTagEmits: {
    "update:checked": (value: boolean) => boolean;
    change: (value: boolean) => boolean;
};
export declare type CheckTagInstance = InstanceType<typeof _default_24> & unknown;
export declare type CheckTagProps = ExtractPropTypes<typeof checkTagProps>;
export declare const checkTagProps: {
    readonly checked: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
};
export declare type CheckTagPropsPublic = __ExtractPublicPropTypes<typeof checkTagProps>;
declare type ChildEssential = {
    uid: number;
    getVnode: () => VNode;
};
declare type ChildrenData = CascaderOption[] | undefined;
declare type CI<T extends DefaultRow> = {
    column: TableColumnCtx<T>;
    $index: number;
    store: Store<T>;
    _self: any;
};
declare type ClassNameGetter<T> = (params: ClassNameGetterParams<T>) => string;
declare type ClassNameGetterParams<T> = {
    cellData: T;
} & RowCommonParams & ColumnCommonParams<T>;
declare type ClassObjectType = Record<string, boolean>;
declare type ClassType = string | ClassObjectType | ClassType[];
declare function clickHandler(): void;
export declare const ClickOutside: ObjectDirective;
declare function close_2(): void;
declare function close_3(): void;
export declare type ColInstance = InstanceType<typeof _default_28> & unknown;
export declare type CollapseActiveName = string | number;
export declare interface CollapseContext {
    activeNames: Ref<CollapseActiveName[]>;
    handleItemClick: (name: CollapseActiveName) => void;
}
export declare const collapseContextKey: InjectionKey<CollapseContext>;
export declare type CollapseEmits = typeof collapseEmits;
export declare const collapseEmits: {
    "update:modelValue": (value: CollapseModelValue) => value is string | number | CollapseActiveName[];
    change: (value: CollapseModelValue) => value is string | number | CollapseActiveName[];
};
export declare type CollapseIconPositionType = "left" | "right";
export declare type CollapseInstance = InstanceType<typeof _default_29> & unknown;
export declare type CollapseItemInstance = InstanceType<typeof _default_30> & unknown;
export declare type CollapseItemProps = ExtractPropTypes<typeof collapseItemProps>;
export declare const collapseItemProps: {
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: EpPropFinalized<(new (...args: any[]) => string | number) | (() => CollapseActiveName) | ((new (...args: any[]) => string | number) | (() => CollapseActiveName))[], unknown, unknown, undefined, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
};
export declare type CollapseItemPropsPublic = __ExtractPublicPropTypes<typeof collapseItemProps>;
export declare type CollapseModelValue = Arrayable<CollapseActiveName>;
export declare type CollapseProps = ExtractPropTypes<typeof collapseProps>;
export declare const collapseProps: {
    readonly accordion: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue) | ((new (...args: any[]) => string | number | CollapseActiveName[]) | (() => CollapseModelValue))[], unknown, unknown, () => [
    ], boolean>;
    readonly expandIconPosition: EpPropFinalized<(new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType) | ((new (...args: any[]) => "left" | "right") | (() => CollapseIconPositionType))[], unknown, unknown, "right", boolean>;
    readonly beforeCollapse: {
        readonly type: PropType<(name: CollapseActiveName) => Awaitable<boolean>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type CollapsePropsPublic = __ExtractPublicPropTypes<typeof collapseProps>;
declare type CollectionItem<T = Record<string, any>> = {
    ref: HTMLElement | null;
} & T;
declare class Color {
    private _hue;
    private _saturation;
    private _value;
    private _alpha;
    private _tiny;
    private _isValid;
    enableAlpha: boolean;
    format: string;
    value: string;
    selected?: boolean;
    constructor(options?: Partial<ColorOptions>);
    set(prop: {
        [key: string]: any;
    } | any, value?: number): void;
    get(prop: string): any;
    toRgb(): Numberify<RGBA>;
    fromString(value: string): void;
    compare(color: this): boolean;
    doOnChange(): void;
}
declare interface ColorOptions {
    enableAlpha: boolean;
    format: string;
    value?: string | null;
}
export declare type ColorPickerEmits = typeof colorPickerEmits;
export declare const colorPickerEmits: {
    "update:modelValue": (val: string | null) => boolean;
    change: (val: string | null) => boolean;
    activeChange: (val: string | null) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
};
export declare type ColorPickerInstance = InstanceType<typeof _default_33> & unknown;
export declare interface ColorPickerPanelContext {
    currentColor: ComputedRef<string>;
}
export declare const colorPickerPanelContextKey: InjectionKey<ColorPickerPanelContext>;
export declare type ColorPickerPanelEmits = typeof colorPickerPanelEmits;
export declare const colorPickerPanelEmits: {
    "update:modelValue": (val: string | null) => boolean;
};
export declare type ColorPickerPanelInstance = InstanceType<typeof _default_32> & unknown;
export declare type ColorPickerPanelProps = ExtractPropTypes<typeof colorPickerPanelProps>;
export declare const colorPickerPanelProps: {
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, undefined, boolean>;
    readonly border: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showAlpha: BooleanConstructor;
    readonly colorFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly predefine: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type ColorPickerPanelPropsPublic = __ExtractPublicPropTypes<typeof colorPickerPanelProps>;
export declare type ColorPickerProps = ExtractPropTypes<typeof colorPickerProps>;
export declare const colorPickerProps: {
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, undefined, boolean>;
    readonly id: StringConstructor;
    readonly showAlpha: BooleanConstructor;
    readonly colorFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly predefine: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare type ColorPickerPropsPublic = __ExtractPublicPropTypes<typeof colorPickerProps>;
export declare type ColProps = ExtractPropTypes<typeof colProps>;
export declare const colProps: {
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly span: EpPropFinalized<NumberConstructor, unknown, unknown, 24, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly pull: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly push: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly xs: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly sm: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly md: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly lg: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly xl: EpPropFinalized<(new (...args: any[]) => number | ColSizeObject) | (() => ColSize) | ((new (...args: any[]) => number | ColSizeObject) | (() => ColSize))[], unknown, unknown, () => Mutable<{}>, boolean>;
};
export declare type ColPropsPublic = __ExtractPublicPropTypes<typeof colProps>;
export declare type ColSize = number | ColSizeObject;
export declare type ColSizeObject = {
    span?: number;
    offset?: number;
    pull?: number;
    push?: number;
};
export declare type Column<T = any> = {
    /**
     * Attributes
     */
    align?: Alignment_2;
    class?: string | ClassNameGetter<T>;
    key?: KeyType_2;
    dataKey?: KeyType_2;
    fixed?: true | FixedDirection;
    flexGrow?: CSSProperties["flexGrow"];
    flexShrink?: CSSProperties["flexShrink"];
    title?: string;
    hidden?: boolean;
    headerClass?: HeaderClassGetter<T> | string;
    maxWidth?: number;
    minWidth?: number;
    style?: CSSProperties;
    sortable?: boolean;
    width: number;
    /**
     * Renderers
     */
    cellRenderer?: CellRenderer<T>;
    headerCellRenderer?: HeaderCellRenderer<T>;
    /**
     * Extendable sections
     */
    [key: string]: any;
};
export declare type ColumnAlignment = typeof columnAlignment[number];
export declare const columnAlignment: readonly [
    "left",
    "center",
    "right"
];
export declare type ColumnCls<T> = string | ((data: {
    row: T;
    rowIndex: number;
}) => string);
declare type ColumnCommonParams<T> = {
    columns: Column<T>[];
    column: Column<T>;
    columnIndex: number;
};
export declare type ColumnResizeHandler<T> = (column: Column<T>, width: number) => void;
export declare type Columns<T> = Column<T>[];
/**
 * Handler types
 */
export declare type ColumnSortHandler<T> = (params: ColumnSortParams<T>) => void;
/**
 * Param types
 */
export declare type ColumnSortParams<T> = {
    column: Column<T>;
    key: KeyType_2;
    order: TableV2SortOrder;
};
export declare type ColumnStyle<T> = CSSProperties | ((data: {
    row: T;
    rowIndex: number;
}) => CSSProperties);
export declare interface CommonColorContext {
    color: Color;
}
export declare const CommonPicker: __VLS_WithTemplateSlots_72<typeof __VLS_component_72, ReturnType<typeof __VLS_template_72>>;
declare type CommonPickerContext = ReturnType<typeof useCommonPicker>;
declare type CommonPickerEmits = (event: "update:modelValue" | "calendar-change" | "panel-change", ...args: any[]) => void;
declare interface CommonPickerProps {
    modelValue: ModelValueType | null;
    valueFormat?: string;
}
export declare const CommonProps: {
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null) | ((new (...args: any[]) => string | number | CascaderNodePathValue_2 | (CascaderNodeValue_2 | CascaderNodePathValue_2)[]) | (() => CascaderValue_2 | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly options: EpPropFinalized<(new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]) | ((new (...args: any[]) => CascaderOption[]) | (() => CascaderOption[]))[], unknown, unknown, () => CascaderOption[], boolean>;
    readonly props: EpPropFinalized<(new (...args: any[]) => CascaderProps) | (() => CascaderProps) | ((new (...args: any[]) => CascaderProps) | (() => CascaderProps))[], unknown, unknown, () => CascaderProps, boolean>;
};
export declare type ComponentSize = typeof componentSizes[number];
export declare const componentSizeMap: {
    readonly large: 40;
    readonly default: 32;
    readonly small: 24;
};
export declare const componentSizes: readonly [
    "",
    "default",
    "small",
    "large"
];
declare const ConfigProvider: DefineComponent<{
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly a11y: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly locale: {
        readonly type: PropType<Language>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly button: {
        readonly type: PropType<ButtonConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly card: {
        readonly type: PropType<CardConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly dialog: {
        readonly type: PropType<DialogConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly link: {
        readonly type: PropType<LinkConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly experimentalFeatures: {
        readonly type: PropType<ExperimentalFeatures>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly keyboardNavigation: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly message: {
        readonly type: PropType<MessageConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: NumberConstructor;
    readonly namespace: EpPropFinalized<StringConstructor, unknown, unknown, "el", boolean>;
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly a11y: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly locale: {
        readonly type: PropType<Language>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly button: {
        readonly type: PropType<ButtonConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly card: {
        readonly type: PropType<CardConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly dialog: {
        readonly type: PropType<DialogConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly link: {
        readonly type: PropType<LinkConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly experimentalFeatures: {
        readonly type: PropType<ExperimentalFeatures>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly keyboardNavigation: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly message: {
        readonly type: PropType<MessageConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: NumberConstructor;
    readonly namespace: EpPropFinalized<StringConstructor, unknown, unknown, "el", boolean>;
}>>, {
    readonly valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly a11y: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly keyboardNavigation: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly namespace: string;
}>;
export declare type ConfigProviderContext = Partial<ConfigProviderProps>;
export declare const configProviderContextKey: InjectionKey<Ref<ConfigProviderContext>>;
export declare type ConfigProviderInstance = InstanceType<typeof ConfigProvider> & unknown;
export declare type ConfigProviderProps = ExtractPropTypes<typeof configProviderProps>;
export declare const configProviderProps: {
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly a11y: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly locale: {
        readonly type: PropType<Language>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly button: {
        readonly type: PropType<ButtonConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly card: {
        readonly type: PropType<CardConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly dialog: {
        readonly type: PropType<DialogConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly link: {
        readonly type: PropType<LinkConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly experimentalFeatures: {
        readonly type: PropType<ExperimentalFeatures>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly keyboardNavigation: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly message: {
        readonly type: PropType<MessageConfigContext>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: NumberConstructor;
    readonly namespace: EpPropFinalized<StringConstructor, unknown, unknown, "el", boolean>;
};
export declare type ConfigProviderPropsPublic = __ExtractPublicPropTypes<typeof configProviderProps>;
export declare type ContainerInstance = InstanceType<typeof _default_34> & unknown;
export declare type CountdownEmits = typeof countdownEmits;
export declare const countdownEmits: {
    finish: () => boolean;
    change: (value: number) => boolean;
};
export declare type CountdownInstance = InstanceType<typeof _default_39> & unknown;
export declare type CountdownProps = ExtractPropTypes<typeof countdownProps>;
export declare const countdownProps: {
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "HH:mm:ss", boolean>;
    readonly prefix: StringConstructor;
    readonly suffix: StringConstructor;
    readonly title: StringConstructor;
    readonly value: EpPropFinalized<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown, 0, boolean>;
    readonly valueStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type CountdownPropsPublic = __ExtractPublicPropTypes<typeof countdownProps>;
declare const createGrid: ({ name, clearCache, getColumnPosition, getColumnStartIndexForOffset, getColumnStopIndexForStartIndex, getEstimatedTotalHeight, getEstimatedTotalWidth, getColumnOffset, getRowOffset, getRowPosition, getRowStartIndexForOffset, getRowStopIndexForStartIndex, initCache, injectToInstance, validateProps, }: GridConstructorProps<VirtualizedGridProps>) => DefineComponent<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("scroll" | "itemRendered")[], "scroll" | "itemRendered", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
}>> & {
    onScroll?: ((...args: any[]) => any) | undefined;
    onItemRendered?: ((...args: any[]) => any) | undefined;
}, {
    readonly data: any[];
    readonly direction: EpPropMergeType<StringConstructor, "ltr" | "rtl", never>;
    readonly className: string;
    readonly containerElement: EpPropMergeType<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown>;
    readonly innerElement: EpPropMergeType<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown>;
    readonly perfMode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly itemKey: GridItemKeyGetter;
    readonly columnCache: number;
    readonly initScrollLeft: number;
    readonly initScrollTop: number;
    readonly rowCache: number;
    readonly hScrollbarSize: number;
    readonly vScrollbarSize: number;
    readonly scrollbarStartGap: number;
    readonly scrollbarEndGap: number;
}>;
declare function createLoadingComponent(options: LoadingOptionsResolved, appContext: AppContext | null): {
    setText: (text: string) => void;
    removeElLoadingChild: () => void;
    close: () => void;
    handleAfterLeave: () => void;
    vm: ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
    $el: HTMLElement;
    originalPosition: Ref<string>;
    originalOverflow: Ref<string>;
    visible: Ref<boolean>;
    parent: Ref<LoadingParentElement>;
    background: Ref<string>;
    svg: Ref<string>;
    svgViewBox: Ref<string>;
    spinner: Ref<string | boolean>;
    text: Ref<string>;
    fullscreen: Ref<boolean>;
    lock: Ref<boolean>;
    customClass: Ref<string>;
    target: Ref<HTMLElement>;
    beforeClose?: Ref<(() => boolean) | undefined> | undefined;
    closed?: Ref<(() => void) | undefined> | undefined;
};
export declare const createModelToggleComposable: <T extends string>(name: T) => {
    useModelToggle: ({ indicator, toggleReason, shouldHideWhenRouteChanges, shouldProceed, onShow, onHide, }: ModelToggleParams) => {
        hide: (event?: Event) => void;
        show: (event?: Event) => void;
        toggle: () => void;
        hasUpdateHandler: ComputedRef<boolean>;
    };
    useModelToggleProps: UseModelTogglePropsRaw<T>;
    useModelToggleEmits: `update:${T}`[];
};
export declare interface CreatePopperInstanceParams {
    referenceEl: Measurable;
    popperContentEl: HTMLElement;
    arrowEl: HTMLElement | undefined;
}
declare type DataGetter<T> = (params: DataGetterParams<T>) => T;
declare type DataGetterParams<T> = {
    columns: Column<T>[];
    column: Column<T>;
    columnIndex: number;
} & RowCommonParams;
export declare interface DateCell {
    column?: number;
    customClass?: string;
    disabled?: boolean;
    end?: boolean;
    inRange?: boolean;
    row?: number;
    selected?: Dayjs;
    isCurrent?: boolean;
    isSelected?: boolean;
    start?: boolean;
    text?: number;
    renderText?: string;
    timestamp?: number;
    date?: Date;
    dayjs?: Dayjs;
    type?: DateCellType;
}
declare type DateCellType = "normal" | "today" | "week" | "next-month" | "prev-month";
export declare const dateEquals: (a: Date | unknown, b: Date | unknown) => boolean;
export declare type DateModelType = number | string | Date;
export declare type DateOrDates = SingleOrRange<Date>;
declare interface DatePickerContext {
    slots: SetupContext["slots"];
    pickerNs: UseNamespaceReturn;
}
export declare type DatePickerInstance = InstanceType<typeof _default_40> & unknown;
export declare type DatePickerPanelInstance = InstanceType<typeof _default_41> & unknown;
export declare type DatePickerPanelProps = ExtractPropTypes<typeof datePickerPanelProps>;
export declare const datePickerPanelProps: {
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly unlinkPanels: BooleanConstructor;
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: BooleanConstructor;
    readonly showFooter: BooleanConstructor;
    readonly showWeekNumber: BooleanConstructor;
    readonly type: EpPropFinalized<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown, "date", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly border: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType))[], unknown, unknown, "", boolean>;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
};
export declare type DatePickerPanelPropsPublic = __ExtractPublicPropTypes<typeof datePickerPanelProps>;
export declare type DatePickerProps = ExtractPropTypes<typeof datePickerProps>;
export declare const datePickerProps: {
    readonly type: EpPropFinalized<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown, "date", boolean>;
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showWeekNumber: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly unlinkPanels: BooleanConstructor;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly format: StringConstructor;
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    readonly rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
};
export declare type DatePickerPropsPublic = __ExtractPublicPropTypes<typeof datePickerProps>;
export declare type DatePickerType = "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange";
export declare type DatePickType = typeof datePickTypes[number];
export declare const datePickTypes: readonly [
    "year",
    "years",
    "month",
    "months",
    "date",
    "dates",
    "week",
    "datetime",
    "datetimerange",
    "daterange",
    "monthrange",
    "yearrange"
];
export declare type DateTableInstance = InstanceType<typeof _default_17> & unknown;
export { dayjs };
export declare type DayOrDays = SingleOrRange<Dayjs>;
export declare const dayOrDaysToDate: (dayOrDays: DayOrDays) => DateOrDates;
declare const _default: {
    version: string;
    install: (app: App, options?: ConfigProviderContext) => void;
};
export default _default;
declare const _default_10: __VLS_WithTemplateSlots_10<typeof __VLS_component_10, ReturnType<typeof __VLS_template_10>>;
declare const _default_100: __VLS_WithTemplateSlots_78<typeof __VLS_component_78, ReturnType<typeof __VLS_template_78>>;
declare const _default_101: __VLS_WithTemplateSlots_79<typeof __VLS_component_79, ReturnType<typeof __VLS_template_79>>;
declare const _default_102: __VLS_WithTemplateSlots_80<typeof __VLS_component_80, ReturnType<typeof __VLS_template_80>>;
declare const _default_103: __VLS_WithTemplateSlots_81<typeof __VLS_component_81, ReturnType<typeof __VLS_template_81>>;
declare const _default_104: __VLS_WithTemplateSlots_82<typeof __VLS_component_82, ReturnType<typeof __VLS_template_82>>;
declare const _default_105: __VLS_WithTemplateSlots_83<typeof __VLS_component_83, ReturnType<typeof __VLS_template_83>>;
declare const _default_106: __VLS_WithTemplateSlots_84<typeof __VLS_component_84, ReturnType<typeof __VLS_template_84>>;
declare const _default_107: __VLS_WithTemplateSlots_85<typeof __VLS_component_85, ReturnType<typeof __VLS_template_85>>;
declare const _default_108: __VLS_WithTemplateSlots_86<typeof __VLS_component_86, ReturnType<typeof __VLS_template_86>>;
declare const _default_109: __VLS_WithTemplateSlots_87<typeof __VLS_component_87, ReturnType<typeof __VLS_template_87>>;
declare const _default_11: __VLS_WithTemplateSlots_11<typeof __VLS_component_11, ReturnType<typeof __VLS_template_11>>;
declare const _default_110: __VLS_WithTemplateSlots_88<typeof __VLS_component_88, ReturnType<typeof __VLS_template_88>>;
declare const _default_111: __VLS_WithTemplateSlots_89<typeof __VLS_component_89, ReturnType<typeof __VLS_template_89>>;
declare const _default_112: __VLS_WithTemplateSlots_90<typeof __VLS_component_90, ReturnType<typeof __VLS_template_90>>;
declare const _default_113: __VLS_WithTemplateSlots_91<typeof __VLS_component_91, ReturnType<typeof __VLS_template_91>>;
declare const _default_114: ObjectDirective;
declare const _default_115: __VLS_WithTemplateSlots_92<typeof __VLS_component_92, ReturnType<typeof __VLS_template_92>>;
declare const _default_12: __VLS_WithTemplateSlots_12<typeof __VLS_component_12, ReturnType<typeof __VLS_template_12>>;
declare const _default_13: __VLS_WithTemplateSlots_13<typeof __VLS_component_13, ReturnType<typeof __VLS_template_13>>;
declare const _default_14: __VLS_WithTemplateSlots_14<typeof __VLS_component_14, ReturnType<typeof __VLS_template_14>>;
declare const _default_15: __VLS_WithTemplateSlots_15<typeof __VLS_component_15, ReturnType<typeof __VLS_template_15>>;
declare const _default_16: __VLS_WithTemplateSlots_16<typeof __VLS_component_16, ReturnType<typeof __VLS_template_16>>;
declare const _default_17: __VLS_WithTemplateSlots_17<typeof __VLS_component_17, ReturnType<typeof __VLS_template_17>>;
declare const _default_18: __VLS_WithTemplateSlots_18<typeof __VLS_component_18, ReturnType<typeof __VLS_template_18>>;
declare const _default_19: __VLS_WithTemplateSlots_19<typeof __VLS_component_19, ReturnType<typeof __VLS_template_19>>;
declare const _default_2: __VLS_WithTemplateSlots<typeof __VLS_component, ReturnType<typeof __VLS_template>>;
declare const _default_20: __VLS_WithTemplateSlots_20<typeof __VLS_component_20, ReturnType<typeof __VLS_template_20>>;
declare const _default_21: __VLS_WithTemplateSlots_21<typeof __VLS_component_21, ReturnType<typeof __VLS_template_23>>;
declare const _default_22: __VLS_WithTemplateSlots_22<typeof __VLS_component_22, ReturnType<typeof __VLS_template_22>>;
declare const _default_23: __VLS_WithTemplateSlots_23<typeof __VLS_component_23, ReturnType<typeof __VLS_template_21>>;
declare const _default_24: __VLS_WithTemplateSlots_24<typeof __VLS_component_24, ReturnType<typeof __VLS_template_24>>;
declare const _default_25: __VLS_WithTemplateSlots_25<typeof __VLS_component_25, ReturnType<typeof __VLS_template_25>>;
declare const _default_26: __VLS_WithTemplateSlots_26<typeof __VLS_component_26, ReturnType<typeof __VLS_template_26>>;
declare const _default_27: __VLS_WithTemplateSlots_27<typeof __VLS_component_27, ReturnType<typeof __VLS_template_27>>;
declare const _default_28: __VLS_WithTemplateSlots_28<typeof __VLS_component_28, ReturnType<typeof __VLS_template_28>>;
declare const _default_29: __VLS_WithTemplateSlots_29<typeof __VLS_component_29, ReturnType<typeof __VLS_template_29>>;
declare const _default_3: __VLS_WithTemplateSlots_2<typeof __VLS_component_2, ReturnType<typeof __VLS_template_2>>;
declare const _default_30: __VLS_WithTemplateSlots_30<typeof __VLS_component_30, ReturnType<typeof __VLS_template_30>>;
declare const _default_31: __VLS_WithTemplateSlots_31<typeof __VLS_component_31, ReturnType<typeof __VLS_template_31>>;
declare const _default_32: __VLS_WithTemplateSlots_32<typeof __VLS_component_32, ReturnType<typeof __VLS_template_32>>;
declare const _default_33: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, undefined, boolean>;
    readonly id: StringConstructor;
    readonly showAlpha: BooleanConstructor;
    readonly colorFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly predefine: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {
    /**
    * @description current color object
    */
    color: Color;
    /**
    * @description manually show ColorPicker
    */
    show: typeof show;
    /**
    * @description manually hide ColorPicker
    */
    hide: typeof hide;
    /**
    * @description focus the input element
    */
    focus: typeof focus_2;
    /**
    * @description blur the input element
    */
    blur: typeof blur_2;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: string | null) => void;
    change: (val: string | null) => void;
    blur: (evt: FocusEvent) => void;
    focus: (evt: FocusEvent) => void;
    activeChange: (val: string | null) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, undefined, boolean>;
    readonly id: StringConstructor;
    readonly showAlpha: BooleanConstructor;
    readonly colorFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly predefine: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((val: string | null) => any) | undefined;
    onChange?: ((val: string | null) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onActiveChange?: ((val: string | null) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>;
    readonly tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly popperClass: string;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showAlpha: boolean;
}>;
declare const _default_34: __VLS_WithTemplateSlots_33<typeof __VLS_component_33, ReturnType<typeof __VLS_template_33>>;
declare const _default_35: __VLS_WithTemplateSlots_34<typeof __VLS_component_34, ReturnType<typeof __VLS_template_34>>;
declare const _default_36: __VLS_WithTemplateSlots_35<typeof __VLS_component_35, ReturnType<typeof __VLS_template_35>>;
declare const _default_37: __VLS_WithTemplateSlots_36<typeof __VLS_component_36, ReturnType<typeof __VLS_template_36>>;
declare const _default_38: __VLS_WithTemplateSlots_37<typeof __VLS_component_37, ReturnType<typeof __VLS_template_37>>;
declare const _default_39: __VLS_WithTemplateSlots_38<typeof __VLS_component_38, ReturnType<typeof __VLS_template_38>>;
declare const _default_4: __VLS_WithTemplateSlots_3<typeof __VLS_component_3, ReturnType<typeof __VLS_template_8>>;
declare const _default_40: DefineComponent<{
    readonly type: EpPropFinalized<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown, "date", boolean>;
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showWeekNumber: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly unlinkPanels: BooleanConstructor;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly format: StringConstructor;
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    readonly rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, "update:modelValue"[], "update:modelValue", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly type: EpPropFinalized<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown, "date", boolean>;
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showWeekNumber: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly unlinkPanels: BooleanConstructor;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly format: StringConstructor;
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    readonly rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
}>> & {
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly type: EpPropMergeType<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown>;
    readonly placeholder: string;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown>;
    readonly placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown>;
    readonly tabindex: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>;
    readonly valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly readonly: boolean;
    readonly prefixIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly clearable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly fallbackPlacements: Placement[];
    readonly popperOptions: Partial<Options>;
    readonly editable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly rangeSeparator: string;
    readonly shortcuts: unknown[];
    readonly showNow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showConfirm: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showFooter: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showWeekNumber: boolean;
    readonly arrowControl: boolean;
    readonly unlinkPanels: boolean;
    readonly isRange: boolean;
}>;
declare const _default_41: DefineComponent<{
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly unlinkPanels: BooleanConstructor;
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: BooleanConstructor;
    readonly showFooter: BooleanConstructor;
    readonly showWeekNumber: BooleanConstructor;
    readonly type: EpPropFinalized<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown, "date", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly border: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType))[], unknown, unknown, "", boolean>;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("update:modelValue" | "calendar-change" | "panel-change" | "visible-change" | "pick")[], "update:modelValue" | "calendar-change" | "panel-change" | "visible-change" | "pick", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly unlinkPanels: BooleanConstructor;
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: BooleanConstructor;
    readonly showFooter: BooleanConstructor;
    readonly showWeekNumber: BooleanConstructor;
    readonly type: EpPropFinalized<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown, "date", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly border: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType))[], unknown, unknown, "", boolean>;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
}>> & {
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
    onPick?: ((...args: any[]) => any) | undefined;
    "onCalendar-change"?: ((...args: any[]) => any) | undefined;
    "onPanel-change"?: ((...args: any[]) => any) | undefined;
    "onVisible-change"?: ((...args: any[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly border: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly type: EpPropMergeType<(new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType) | ((new (...args: any[]) => "year" | "years" | "month" | "months" | "date" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "yearrange") | (() => DatePickerType))[], unknown, unknown>;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType))[], unknown, unknown>;
    readonly clearable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly shortcuts: unknown[];
    readonly showNow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showConfirm: boolean;
    readonly showFooter: boolean;
    readonly showWeekNumber: boolean;
    readonly arrowControl: boolean;
    readonly unlinkPanels: boolean;
    readonly isRange: boolean;
}>;
declare const _default_42: __VLS_WithTemplateSlots_39<typeof __VLS_component_39, ReturnType<typeof __VLS_template_39>>;
declare const _default_43: __VLS_WithTemplateSlots_40<typeof __VLS_component_40, ReturnType<typeof __VLS_template_40>>;
declare const _default_44: __VLS_WithTemplateSlots_41<typeof __VLS_component_41, ReturnType<typeof __VLS_template_41>>;
declare const _default_45: __VLS_WithTemplateSlots_42<typeof __VLS_component_42, ReturnType<typeof __VLS_template_42>>;
declare const _default_46: DefineComponent<{
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly effect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger") | (() => EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>) | ((new (...args: any[]) => "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger") | (() => EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly id: StringConstructor;
    readonly size: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly splitButton: BooleanConstructor;
    readonly hideOnClick: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly loop: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 150, boolean>;
    readonly hideTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 150, boolean>;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly maxHeight: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, "", boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly disabled: BooleanConstructor;
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "menu", boolean>;
    readonly buttonProps: {
        readonly type: PropType<Partial<ButtonProps>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {
    t: Translator;
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    scrollbar: Ref<null>;
    wrapStyle: ComputedRef<CSSProperties>;
    dropdownTriggerKls: ComputedRef<string[]>;
    dropdownSize: ComputedRef<"" | "small" | "default" | "large">;
    triggerId: ComputedRef<string>;
    currentTabId: Ref<string | null>;
    handleCurrentTabIdChange: (id: string) => void;
    handlerMainButtonClick: (event: MouseEvent) => void;
    handleEntryFocus: (e: Event) => void;
    handleClose: () => void;
    handleOpen: () => void;
    handleBeforeShowTooltip: () => void;
    handleShowTooltip: (event?: Event) => void;
    handleBeforeHideTooltip: () => void;
    onFocusAfterTrapped: (e: Event) => void;
    popperRef: Ref<TooltipInstance | undefined>;
    contentRef: Ref<HTMLElement | undefined>;
    triggeringElementRef: Ref<any>;
    referenceElementRef: Ref<any>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("click" | "visible-change" | "command")[], "click" | "visible-change" | "command", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly effect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger") | (() => EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>) | ((new (...args: any[]) => "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger") | (() => EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly id: StringConstructor;
    readonly size: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly splitButton: BooleanConstructor;
    readonly hideOnClick: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly loop: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 150, boolean>;
    readonly hideTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 150, boolean>;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly maxHeight: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, "", boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly disabled: BooleanConstructor;
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "menu", boolean>;
    readonly buttonProps: {
        readonly type: PropType<Partial<ButtonProps>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    onClick?: ((...args: any[]) => any) | undefined;
    "onVisible-change"?: ((...args: any[]) => any) | undefined;
    onCommand?: ((...args: any[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly maxHeight: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>;
    readonly size: string;
    readonly placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown>;
    readonly effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly tabindex: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>;
    readonly role: EpPropMergeType<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown>;
    readonly trigger: EpPropMergeType<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown>;
    readonly loop: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly popperOptions: Partial<Options>;
    readonly popperClass: string;
    readonly triggerKeys: string[];
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly hideOnClick: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showTimeout: number;
    readonly hideTimeout: number;
    readonly splitButton: boolean;
}>;
declare const _default_47: DefineComponent<{
    readonly command: EpPropFinalized<readonly [
        ObjectConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, () => {}, boolean>;
    readonly disabled: BooleanConstructor;
    readonly divided: BooleanConstructor;
    readonly textValue: StringConstructor;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    handleClick: (event: PointerEvent) => void;
    handlePointerMove: (event: PointerEvent) => void;
    handlePointerLeave: (event: PointerEvent) => void;
    textContent: ComputedRef<string>;
    propsAndAttrs: ComputedRef<{
        disabled: boolean;
        icon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown> | undefined;
        onClick: ((...args: any[]) => any) | undefined;
        onPointermove: ((...args: any[]) => any) | undefined;
        onPointerleave: ((...args: any[]) => any) | undefined;
        command: EpPropMergeType<readonly [
            ObjectConstructor,
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>;
        divided: boolean;
        textValue: string | undefined;
    }>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("click" | "pointerleave" | "pointermove")[], "click" | "pointerleave" | "pointermove", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly command: EpPropFinalized<readonly [
        ObjectConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, () => {}, boolean>;
    readonly disabled: BooleanConstructor;
    readonly divided: BooleanConstructor;
    readonly textValue: StringConstructor;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onClick?: ((...args: any[]) => any) | undefined;
    onPointermove?: ((...args: any[]) => any) | undefined;
    onPointerleave?: ((...args: any[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly command: EpPropMergeType<readonly [
        ObjectConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly divided: boolean;
}>;
declare const _default_48: DefineComponent<{
    onKeydown: {
        readonly type: PropType<(e: KeyboardEvent) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    size: ComputedRef<string> | undefined;
    rovingFocusGroupRootStyle: Ref<StyleValue>;
    tabIndex: Ref<number>;
    dropdownKls: ComputedRef<string[]>;
    role: ComputedRef<EpPropMergeType<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown>>;
    triggerId: ComputedRef<string>;
    dropdownListWrapperRef: (el: Element | ComponentPublicInstance | null) => void;
    handleKeydown: (e: KeyboardEvent) => void;
    onBlur: (e: Event) => void;
    onFocus: (e: FocusEvent) => void;
    onMousedown: (e: Event) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    onKeydown: {
        readonly type: PropType<(e: KeyboardEvent) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {}>;
declare const _default_49: __VLS_WithTemplateSlots_43<typeof __VLS_component_43, ReturnType<typeof __VLS_template_43>>;
declare const _default_5: __VLS_WithTemplateSlots_4<typeof __VLS_component_4, ReturnType<typeof __VLS_template_3>>;
declare const _default_50: __VLS_WithTemplateSlots_44<typeof __VLS_component_44, ReturnType<typeof __VLS_template_44>>;
declare const _default_51: __VLS_WithTemplateSlots_45<typeof __VLS_component_45, ReturnType<typeof __VLS_template_45>>;
declare const _default_52: __VLS_WithTemplateSlots_46<typeof __VLS_component_46, ReturnType<typeof __VLS_template_46>>;
declare const _default_53: __VLS_WithTemplateSlots_47<typeof __VLS_component_47, ReturnType<typeof __VLS_template_47>>;
declare const _default_54: __VLS_WithTemplateSlots_48<typeof __VLS_component_48, ReturnType<typeof __VLS_template_48>>;
declare const _default_55: __VLS_WithTemplateSlots_49<typeof __VLS_component_49, ReturnType<typeof __VLS_template_49>>;
declare const _default_56: __VLS_WithTemplateSlots_50<typeof __VLS_component_50, ReturnType<typeof __VLS_template_50>>;
declare const _default_57: __VLS_WithTemplateSlots_51<typeof __VLS_component_51, ReturnType<typeof __VLS_template_51>>;
declare const _default_58: DefineComponent<{
    readonly mode: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "vertical", boolean>;
    readonly defaultActive: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly defaultOpeneds: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly uniqueOpened: BooleanConstructor;
    readonly router: BooleanConstructor;
    readonly menuTrigger: EpPropFinalized<StringConstructor, "click" | "hover", unknown, "hover", boolean>;
    readonly collapse: BooleanConstructor;
    readonly backgroundColor: StringConstructor;
    readonly textColor: StringConstructor;
    readonly activeTextColor: StringConstructor;
    readonly closeOnClickOutside: BooleanConstructor;
    readonly collapseTransition: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly ellipsis: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly popperOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly ellipsisIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly popperEffect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly popperClass: StringConstructor;
    readonly showTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly hideTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    close: (index: string, indexPath: string[]) => boolean;
    open: (index: string, indexPath: string[]) => boolean;
    select: (index: string, indexPath: string[], item: MenuItemClicked, routerResult?: Promise<void | NavigationFailure>) => boolean;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly mode: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "vertical", boolean>;
    readonly defaultActive: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly defaultOpeneds: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly uniqueOpened: BooleanConstructor;
    readonly router: BooleanConstructor;
    readonly menuTrigger: EpPropFinalized<StringConstructor, "click" | "hover", unknown, "hover", boolean>;
    readonly collapse: BooleanConstructor;
    readonly backgroundColor: StringConstructor;
    readonly textColor: StringConstructor;
    readonly activeTextColor: StringConstructor;
    readonly closeOnClickOutside: BooleanConstructor;
    readonly collapseTransition: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly ellipsis: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly popperOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly ellipsisIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly popperEffect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly popperClass: StringConstructor;
    readonly showTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly hideTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    onSelect?: ((index: string, indexPath: string[], item: MenuItemClicked, routerResult?: Promise<void | NavigationFailure> | undefined) => any) | undefined;
    onOpen?: ((index: string, indexPath: string[]) => any) | undefined;
    onClose?: ((index: string, indexPath: string[]) => any) | undefined;
}, {
    readonly ellipsis: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly collapse: boolean;
    readonly mode: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showTimeout: number;
    readonly hideTimeout: number;
    readonly defaultActive: string;
    readonly defaultOpeneds: string[];
    readonly menuTrigger: EpPropMergeType<StringConstructor, "click" | "hover", unknown>;
    readonly collapseTransition: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly popperOffset: number;
    readonly ellipsisIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly popperEffect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly uniqueOpened: boolean;
    readonly router: boolean;
    readonly closeOnClickOutside: boolean;
}>;
declare const _default_59: __VLS_WithTemplateSlots_52<typeof __VLS_component_52, ReturnType<typeof __VLS_template_52>>;
declare const _default_6: __VLS_WithTemplateSlots_5<typeof __VLS_component_5, ReturnType<typeof __VLS_template_7>>;
declare const _default_60: __VLS_WithTemplateSlots_53<typeof __VLS_component_53, ReturnType<typeof __VLS_template_53>>;
declare const _default_61: DefineComponent<{
    readonly index: {
        readonly type: PropType<string>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showTimeout: NumberConstructor;
    readonly hideTimeout: NumberConstructor;
    readonly popperClass: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly popperOffset: NumberConstructor;
    readonly expandCloseIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandOpenIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly collapseCloseIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly collapseOpenIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly index: {
        readonly type: PropType<string>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showTimeout: NumberConstructor;
    readonly hideTimeout: NumberConstructor;
    readonly popperClass: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly popperOffset: NumberConstructor;
    readonly expandCloseIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandOpenIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly collapseCloseIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly collapseOpenIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly disabled: boolean;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
declare const _default_62: __VLS_WithTemplateSlots_54<typeof __VLS_component_54, ReturnType<typeof __VLS_template_54>>;
declare const _default_63: DefineComponent<{
    readonly pageSize: NumberConstructor;
    readonly defaultPageSize: NumberConstructor;
    readonly total: NumberConstructor;
    readonly pageCount: NumberConstructor;
    readonly pagerCount: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly currentPage: NumberConstructor;
    readonly defaultCurrentPage: NumberConstructor;
    readonly layout: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    readonly pageSizes: EpPropFinalized<(new (...args: any[]) => number[]) | (() => number[]) | ((new (...args: any[]) => number[]) | (() => number[]))[], unknown, unknown, () => [
        10,
        20,
        30,
        40,
        50,
        100
    ], boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly prevText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly prevIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly nextText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly nextIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly small: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly background: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly hideOnSinglePage: BooleanConstructor;
    readonly appendSizeTo: StringConstructor;
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:current-page": (val: number) => boolean;
    "update:page-size": (val: number) => boolean;
    "size-change": (val: number) => boolean;
    change: (currentPage: number, pageSize: number) => boolean;
    "current-change": (val: number) => boolean;
    "prev-click": (val: number) => boolean;
    "next-click": (val: number) => boolean;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly pageSize: NumberConstructor;
    readonly defaultPageSize: NumberConstructor;
    readonly total: NumberConstructor;
    readonly pageCount: NumberConstructor;
    readonly pagerCount: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly currentPage: NumberConstructor;
    readonly defaultCurrentPage: NumberConstructor;
    readonly layout: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    readonly pageSizes: EpPropFinalized<(new (...args: any[]) => number[]) | (() => number[]) | ((new (...args: any[]) => number[]) | (() => number[]))[], unknown, unknown, () => [
        10,
        20,
        30,
        40,
        50,
        100
    ], boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly prevText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly prevIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly nextText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly nextIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly small: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly background: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly hideOnSinglePage: BooleanConstructor;
    readonly appendSizeTo: StringConstructor;
}>> & {
    onChange?: ((currentPage: number, pageSize: number) => any) | undefined;
    "onUpdate:current-page"?: ((val: number) => any) | undefined;
    "onUpdate:page-size"?: ((val: number) => any) | undefined;
    "onSize-change"?: ((val: number) => any) | undefined;
    "onCurrent-change"?: ((val: number) => any) | undefined;
    "onPrev-click"?: ((val: number) => any) | undefined;
    "onNext-click"?: ((val: number) => any) | undefined;
}, {
    readonly small: boolean;
    readonly disabled: boolean;
    readonly background: boolean;
    readonly layout: string;
    readonly popperClass: string;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly prevText: string;
    readonly prevIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly nextText: string;
    readonly nextIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly pageSizes: number[];
    readonly pagerCount: number;
    readonly hideOnSinglePage: boolean;
}>;
declare const _default_64: __VLS_WithTemplateSlots_55<typeof __VLS_component_55, ReturnType<typeof __VLS_template_55>>;
declare const _default_65: __VLS_WithTemplateSlots_57<typeof __VLS_component_57, ReturnType<typeof __VLS_template_57>>;
declare const _default_66: __VLS_WithTemplateSlots_58<typeof __VLS_component_58, ReturnType<typeof __VLS_template_58>>;
declare const _default_67: __VLS_WithTemplateSlots_59<typeof __VLS_component_59, ReturnType<typeof __VLS_template_59>>;
declare const _default_68: __VLS_WithTemplateSlots_60<typeof __VLS_component_60, ReturnType<typeof __VLS_template_60>>;
declare const _default_69: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly lowThreshold: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly highThreshold: EpPropFinalized<NumberConstructor, unknown, unknown, 4, boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly colors: EpPropFinalized<(new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>) | ((new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>))[], unknown, unknown, () => [
        "",
        "",
        ""
    ], boolean>;
    readonly voidColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly disabledVoidColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icons: EpPropFinalized<(new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>) | ((new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>))[], unknown, unknown, () => [
        Component,
        Component,
        Component
    ], boolean>;
    readonly voidIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => Component, boolean>;
    readonly disabledVoidIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => Component, boolean>;
    readonly disabled: BooleanConstructor;
    readonly allowHalf: BooleanConstructor;
    readonly showText: BooleanConstructor;
    readonly showScore: BooleanConstructor;
    readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly texts: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
    ], boolean>;
    readonly scoreTemplate: EpPropFinalized<StringConstructor, unknown, unknown, "{value}", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clearable: BooleanConstructor;
}, {
    /** @description set current value */
    setCurrentValue: typeof setCurrentValue;
    /** @description reset current value */
    resetCurrentValue: typeof resetCurrentValue;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: number) => void;
    change: (value: number) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly lowThreshold: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly highThreshold: EpPropFinalized<NumberConstructor, unknown, unknown, 4, boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly colors: EpPropFinalized<(new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>) | ((new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>))[], unknown, unknown, () => [
        "",
        "",
        ""
    ], boolean>;
    readonly voidColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly disabledVoidColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icons: EpPropFinalized<(new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>) | ((new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>))[], unknown, unknown, () => [
        Component,
        Component,
        Component
    ], boolean>;
    readonly voidIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => Component, boolean>;
    readonly disabledVoidIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => Component, boolean>;
    readonly disabled: BooleanConstructor;
    readonly allowHalf: BooleanConstructor;
    readonly showText: BooleanConstructor;
    readonly showScore: BooleanConstructor;
    readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly texts: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
    ], boolean>;
    readonly scoreTemplate: EpPropFinalized<StringConstructor, unknown, unknown, "{value}", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clearable: BooleanConstructor;
}>> & {
    "onUpdate:modelValue"?: ((value: number) => any) | undefined;
    onChange?: ((value: number) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly id: string;
    readonly modelValue: number;
    readonly max: number;
    readonly clearable: boolean;
    readonly textColor: string;
    readonly colors: EpPropMergeType<(new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>) | ((new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>))[], unknown, unknown>;
    readonly showText: boolean;
    readonly lowThreshold: number;
    readonly highThreshold: number;
    readonly voidColor: string;
    readonly disabledVoidColor: string;
    readonly icons: EpPropMergeType<(new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>) | ((new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>))[], unknown, unknown>;
    readonly voidIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly disabledVoidIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly texts: string[];
    readonly scoreTemplate: string;
    readonly allowHalf: boolean;
    readonly showScore: boolean;
}>;
declare const _default_7: __VLS_WithTemplateSlots_6<typeof __VLS_component_6, ReturnType<typeof __VLS_template_4>>;
declare const _default_70: __VLS_WithTemplateSlots_61<typeof __VLS_component_61, ReturnType<typeof __VLS_template_61>>;
declare const _default_71: __VLS_WithTemplateSlots_62<typeof __VLS_component_62, ReturnType<typeof __VLS_template_62>>;
declare const _default_72: __VLS_WithTemplateSlots_63<typeof __VLS_component_63, ReturnType<typeof __VLS_template_63>>;
declare const _default_73: DefineComponent<{
    readonly vertical: BooleanConstructor;
    readonly size: StringConstructor;
    readonly move: NumberConstructor;
    readonly ratio: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly always: BooleanConstructor;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly vertical: BooleanConstructor;
    readonly size: StringConstructor;
    readonly move: NumberConstructor;
    readonly ratio: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly always: BooleanConstructor;
}>>, {
    readonly always: boolean;
    readonly vertical: boolean;
}>;
declare const _default_74: DefineComponent<{
    ariaLabel: StringConstructor;
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    name: StringConstructor;
    id: StringConstructor;
    modelValue: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null) | ((new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null))[], unknown, unknown, undefined, boolean>;
    autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    automaticDropdown: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, string, boolean>;
    disabled: BooleanConstructor;
    clearable: BooleanConstructor;
    filterable: BooleanConstructor;
    allowCreate: BooleanConstructor;
    loading: BooleanConstructor;
    popperClass: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties) | (() => string | CSSProperties) | ((new (...args: any[]) => string | CSSProperties) | (() => string | CSSProperties))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    remote: BooleanConstructor;
    loadingText: StringConstructor;
    noMatchText: StringConstructor;
    noDataText: StringConstructor;
    remoteMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    filterMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    multiple: BooleanConstructor;
    multipleLimit: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    defaultFirstOption: BooleanConstructor;
    reserveKeyword: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    valueKey: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    collapseTags: BooleanConstructor;
    collapseTagsTooltip: BooleanConstructor;
    maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    fitInputWidth: BooleanConstructor;
    suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagType: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagEffect: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    remoteShowSuffix: BooleanConstructor;
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, string, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, string[], boolean>;
    tabindex: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, number, boolean>;
    appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: {
        readonly type: PropType<Record<string, any>[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    props: EpPropFinalized<(new (...args: any[]) => Props_2) | (() => Props_2) | ((new (...args: any[]) => Props_2) | (() => Props_2))[], unknown, unknown, () => Required<Props_2>, boolean>;
}, {
    modelValue: ComputedRef<string | number | boolean | any[] | Record<string, any> | null | undefined>;
    selectedLabel: ComputedRef<string | string[]>;
    calculatorRef: ShallowRef<HTMLElement | undefined>;
    inputStyle: ComputedRef<{
        minWidth: string;
    }>;
    getLabel: (option: Option_2) => any;
    getValue: (option: Option_2) => any;
    getOptions: (option: Option_2) => any;
    getDisabled: (option: Option_2) => any;
    getOptionProps: (option: Record<string, any>) => {
        label: any;
        value: any;
        disabled: any;
    };
    inputId: Ref<string | undefined>;
    contentId: Ref<string>;
    nsSelect: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    nsInput: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    states: {
        inputValue: string;
        options: Map<OptionValue, SelectOptionProxy>;
        cachedOptions: Map<OptionValue, SelectOptionProxy>;
        optionValues: OptionValue[];
        selected: {
            value: OptionValue;
            currentLabel: SelectOptionProxy["currentLabel"];
            isDisabled?: SelectOptionProxy["isDisabled"] | undefined;
        }[];
        hoveringIndex: number;
        inputHovering: boolean;
        selectionWidth: number;
        collapseItemWidth: number;
        previousQuery: string | null;
        selectedLabel: string;
        menuVisibleOnFocus: boolean;
        isBeforeHide: boolean;
    };
    isFocused: Ref<boolean>;
    expanded: Ref<boolean>;
    optionsArray: ComputedRef<SelectOptionProxy[]>;
    hoverOption: Ref<any>;
    selectSize: ComputedRef<"" | "small" | "default" | "large">;
    filteredOptionsCount: ComputedRef<number>;
    updateTooltip: () => void;
    updateTagTooltip: () => void;
    debouncedOnInputChange: DebouncedFunc<() => void>;
    onInput: (event: Event) => void;
    deletePrevTag: (e: KeyboardEvent) => void;
    deleteTag: (event: MouseEvent, tag: SelectOptionProxy | OptionBasic) => void;
    deleteSelected: (event: Event) => void;
    handleOptionSelect: (option: SelectOptionProxy) => void;
    scrollToOption: (option: SelectOptionProxy | SelectOptionProxy[] | SelectStates["selected"]) => void;
    hasModelValue: ComputedRef<boolean>;
    shouldShowPlaceholder: ComputedRef<boolean>;
    currentPlaceholder: ComputedRef<string>;
    mouseEnterEventName: ComputedRef<"mouseenter" | null>;
    needStatusIcon: ComputedRef<boolean>;
    showClearBtn: ComputedRef<boolean>;
    iconComponent: ComputedRef<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown> | undefined>;
    iconReverse: ComputedRef<string>;
    validateState: ComputedRef<"" | "error" | "success" | "validating">;
    validateIcon: ComputedRef<"" | Component>;
    showNewOption: ComputedRef<boolean>;
    updateOptions: () => void;
    collapseTagSize: ComputedRef<"default" | "small">;
    setSelected: () => void;
    selectDisabled: ComputedRef<boolean>;
    emptyText: ComputedRef<string | null>;
    handleCompositionStart: (event: CompositionEvent) => void;
    handleCompositionUpdate: (event: CompositionEvent) => void;
    handleCompositionEnd: (event: CompositionEvent) => void;
    onOptionCreate: (vm: SelectOptionProxy) => void;
    onOptionDestroy: (key: OptionValue, vm: SelectOptionProxy) => void;
    handleMenuEnter: () => void;
    focus: () => void;
    blur: () => void;
    handleClearClick: (event: Event) => void;
    handleClickOutside: (event: Event) => void;
    handleEsc: () => void;
    toggleMenu: () => void;
    selectOption: () => void;
    getValueKey: (item: SelectOptionProxy | SelectStates["selected"][0]) => any;
    navigateOptions: (direction: "prev" | "next") => void;
    dropdownMenuVisible: WritableComputedRef<boolean>;
    showTagList: ComputedRef<{
        value: OptionValue;
        currentLabel: SelectOptionProxy["currentLabel"];
        isDisabled?: SelectOptionProxy["isDisabled"] | undefined;
    }[]>;
    collapseTagList: ComputedRef<{
        value: OptionValue;
        currentLabel: SelectOptionProxy["currentLabel"];
        isDisabled?: SelectOptionProxy["isDisabled"] | undefined;
    }[]>;
    popupScroll: (data: {
        scrollTop: number;
        scrollLeft: number;
    }) => void;
    tagStyle: ComputedRef<{
        maxWidth: string;
    }>;
    collapseTagStyle: ComputedRef<{
        maxWidth: string;
    }>;
    popperRef: ComputedRef<HTMLElement | undefined>;
    inputRef: Ref<HTMLInputElement | undefined>;
    tooltipRef: Ref<TooltipInstance | undefined>;
    tagTooltipRef: Ref<TooltipInstance | undefined>;
    prefixRef: Ref<HTMLElement | undefined>;
    suffixRef: Ref<HTMLElement | undefined>;
    selectRef: Ref<HTMLElement | undefined>;
    wrapperRef: ShallowRef<HTMLElement | undefined>;
    selectionRef: Ref<HTMLElement | undefined>;
    scrollbarRef: Ref<ScrollbarInstance | undefined>;
    menuRef: Ref<HTMLElement | undefined>;
    tagMenuRef: Ref<HTMLElement | undefined>;
    collapseItemRef: Ref<HTMLElement | undefined>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("clear" | "update:modelValue" | "change" | "blur" | "focus" | "visible-change" | "remove-tag" | "popup-scroll")[], "clear" | "update:modelValue" | "change" | "blur" | "focus" | "visible-change" | "remove-tag" | "popup-scroll", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    ariaLabel: StringConstructor;
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    name: StringConstructor;
    id: StringConstructor;
    modelValue: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null) | ((new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null))[], unknown, unknown, undefined, boolean>;
    autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    automaticDropdown: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, string, boolean>;
    disabled: BooleanConstructor;
    clearable: BooleanConstructor;
    filterable: BooleanConstructor;
    allowCreate: BooleanConstructor;
    loading: BooleanConstructor;
    popperClass: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties) | (() => string | CSSProperties) | ((new (...args: any[]) => string | CSSProperties) | (() => string | CSSProperties))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    remote: BooleanConstructor;
    loadingText: StringConstructor;
    noMatchText: StringConstructor;
    noDataText: StringConstructor;
    remoteMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    filterMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    multiple: BooleanConstructor;
    multipleLimit: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    defaultFirstOption: BooleanConstructor;
    reserveKeyword: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    valueKey: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    collapseTags: BooleanConstructor;
    collapseTagsTooltip: BooleanConstructor;
    maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    fitInputWidth: BooleanConstructor;
    suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagType: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagEffect: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    remoteShowSuffix: BooleanConstructor;
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, string, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, string[], boolean>;
    tabindex: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, number, boolean>;
    appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: {
        readonly type: PropType<Record<string, any>[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    props: EpPropFinalized<(new (...args: any[]) => Props_2) | (() => Props_2) | ((new (...args: any[]) => Props_2) | (() => Props_2))[], unknown, unknown, () => Required<Props_2>, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    onFocus?: ((...args: any[]) => any) | undefined;
    onBlur?: ((...args: any[]) => any) | undefined;
    onClear?: ((...args: any[]) => any) | undefined;
    "onVisible-change"?: ((...args: any[]) => any) | undefined;
    "onRemove-tag"?: ((...args: any[]) => any) | undefined;
    "onPopup-scroll"?: ((...args: any[]) => any) | undefined;
}, {
    disabled: boolean;
    offset: number;
    multiple: boolean;
    props: Props_2;
    loading: boolean;
    modelValue: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null) | ((new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null))[], unknown, unknown>;
    placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown>;
    effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    tabindex: EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>;
    valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    autocomplete: string;
    validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    clearable: boolean;
    fallbackPlacements: Placement[];
    popperOptions: Partial<Options>;
    popperClass: string;
    teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    showArrow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    valueKey: string;
    fitInputWidth: boolean;
    filterable: boolean;
    collapseTags: boolean;
    maxCollapseTags: number;
    collapseTagsTooltip: boolean;
    tagType: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    tagEffect: EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>;
    multipleLimit: number;
    reserveKeyword: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    allowCreate: boolean;
    automaticDropdown: boolean;
    defaultFirstOption: boolean;
    remote: boolean;
    remoteShowSuffix: boolean;
}>;
declare const _default_75: DefineComponent<{
    value: {
        readonly type: PropType<EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    label: {
        readonly type: PropType<EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    created: BooleanConstructor;
    disabled: BooleanConstructor;
}, {
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    id: Ref<string>;
    containerKls: ComputedRef<string[]>;
    currentLabel: ComputedRef<boolean | EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
    itemSelected: ComputedRef<boolean>;
    isDisabled: ComputedRef<boolean>;
    select: SelectContext;
    visible: Ref<boolean>;
    hover: Ref<boolean>;
    states: {
        index: number;
        groupDisabled: boolean;
        visible: boolean;
        hover: boolean;
    };
    hoverItem: () => void;
    updateOption: (query: string) => void;
    selectOptionClick: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    value: {
        readonly type: PropType<EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    label: {
        readonly type: PropType<EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    created: BooleanConstructor;
    disabled: BooleanConstructor;
}>>, {
    disabled: boolean;
    created: boolean;
}>;
declare const _default_76: DefineComponent<{
    /**
    * @description name of the group
    */
    label: StringConstructor;
    /**
    * @description whether to disable all options in this group
    */
    disabled: BooleanConstructor;
}, {
    groupRef: Ref<HTMLElement | undefined>;
    visible: ComputedRef<boolean>;
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    /**
    * @description name of the group
    */
    label: StringConstructor;
    /**
    * @description whether to disable all options in this group
    */
    disabled: BooleanConstructor;
}>>, {
    disabled: boolean;
}>;
declare const _default_77: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly allowCreate: BooleanConstructor;
    readonly autocomplete: EpPropFinalized<(new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list") | ((new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list"))[], unknown, unknown, "none", boolean>;
    readonly automaticDropdown: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "light", boolean>;
    readonly collapseTags: BooleanConstructor;
    readonly collapseTagsTooltip: BooleanConstructor;
    readonly maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly defaultFirstOption: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly estimatedOptionHeight: EpPropFinalized<NumberConstructor, unknown, unknown, undefined, boolean>;
    readonly filterable: BooleanConstructor;
    readonly filterMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: EpPropFinalized<NumberConstructor, unknown, unknown, 274, boolean>;
    readonly itemHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 34, boolean>;
    readonly id: StringConstructor;
    readonly loading: BooleanConstructor;
    readonly loadingText: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => any) | (() => any) | {
        (): any;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => any) | (() => any) | {
        (): any;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly multiple: BooleanConstructor;
    readonly multipleLimit: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly name: StringConstructor;
    readonly noDataText: StringConstructor;
    readonly noMatchText: StringConstructor;
    readonly remoteMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly reserveKeyword: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly options: {
        readonly type: PropType<OptionType[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    readonly remote: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly props: EpPropFinalized<(new (...args: any[]) => Props_2) | (() => Props_2) | ((new (...args: any[]) => Props_2) | (() => Props_2))[], unknown, unknown, () => Required<Props_2>, boolean>;
    readonly valueKey: EpPropFinalized<StringConstructor, unknown, unknown, "value", boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom-start", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom-start",
        "top-start",
        "right",
        "left"
    ], boolean>;
    readonly tagType: {
        readonly default: "info";
        readonly type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tagEffect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fitInputWidth: EpPropFinalized<readonly [
        BooleanConstructor,
        NumberConstructor
    ], unknown, number | boolean, true, boolean>;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    modelValue: ComputedRef<any>;
    selectedLabel: ComputedRef<string | string[]>;
    calculatorRef: ShallowRef<HTMLElement | undefined>;
    inputStyle: ComputedRef<{
        minWidth: string;
    }>;
    inputId: Ref<string | undefined>;
    collapseTagSize: ComputedRef<"default" | "small">;
    currentPlaceholder: ComputedRef<string>;
    expanded: Ref<boolean>;
    emptyText: ComputedRef<string | false | null>;
    popupHeight: ComputedRef<number>;
    debounce: ComputedRef<0 | 300>;
    allOptions: ComputedRef<OptionType[]>;
    filteredOptions: Ref<({
        [x: string]: any;
    } | {
        [x: string]: any;
        created?: boolean | undefined;
    })[]>;
    iconComponent: ComputedRef<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown> | undefined>;
    iconReverse: ComputedRef<string | undefined>;
    tagStyle: ComputedRef<{
        maxWidth: string;
    }>;
    collapseTagStyle: ComputedRef<{
        maxWidth: string;
    }>;
    popperSize: Ref<number>;
    dropdownMenuVisible: WritableComputedRef<boolean>;
    hasModelValue: ComputedRef<boolean>;
    shouldShowPlaceholder: ComputedRef<boolean>;
    selectDisabled: ComputedRef<boolean>;
    selectSize: ComputedRef<"" | "small" | "default" | "large">;
    needStatusIcon: ComputedRef<boolean>;
    showClearBtn: ComputedRef<boolean>;
    states: SelectStates_2;
    isFocused: Ref<boolean>;
    nsSelect: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    nsInput: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    inputRef: Ref<HTMLElement | undefined>;
    menuRef: Ref<SelectDropdownInstance | undefined>;
    tagMenuRef: Ref<HTMLElement | undefined>;
    tooltipRef: Ref<TooltipInstance | undefined>;
    tagTooltipRef: Ref<TooltipInstance | undefined>;
    selectRef: Ref<HTMLElement | undefined>;
    wrapperRef: ShallowRef<HTMLElement | undefined>;
    selectionRef: Ref<HTMLElement | undefined>;
    prefixRef: Ref<HTMLElement | undefined>;
    suffixRef: Ref<HTMLElement | undefined>;
    collapseItemRef: Ref<HTMLElement | undefined>;
    popperRef: ComputedRef<HTMLElement | undefined>;
    validateState: ComputedRef<"" | "error" | "success" | "validating">;
    validateIcon: ComputedRef<any>;
    showTagList: ComputedRef<Option_2[]>;
    collapseTagList: ComputedRef<Option_2[]>;
    debouncedOnInputChange: DebouncedFunc<() => void>;
    deleteTag: (event: MouseEvent, option: Option_2) => void;
    getLabel: (option: Option_2) => any;
    getValue: (option: Option_2) => any;
    getDisabled: (option: Option_2) => any;
    getValueKey: (item: unknown) => any;
    handleClear: () => void;
    handleClickOutside: (event: Event) => void;
    handleDel: (e: KeyboardEvent) => void;
    handleEsc: () => void;
    focus: () => void;
    blur: () => void;
    handleMenuEnter: () => Promise<void>;
    handleResize: () => void;
    resetSelectionWidth: () => void;
    updateTooltip: () => void;
    updateTagTooltip: () => void;
    updateOptions: () => void;
    toggleMenu: () => void;
    scrollTo: (index: number) => void;
    onInput: (event: Event) => void;
    onKeyboardNavigate: (direction: "forward" | "backward", hoveringIndex?: number | undefined) => void;
    onKeyboardSelect: () => void;
    onSelect: (option: Option_2) => void;
    onHover: (idx?: number) => void;
    handleCompositionStart: (event: CompositionEvent) => void;
    handleCompositionEnd: (event: CompositionEvent) => void;
    handleCompositionUpdate: (event: CompositionEvent) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: SelectV2Props["modelValue"]) => boolean;
    change: (val: SelectV2Props["modelValue"]) => boolean;
    "remove-tag": (val: unknown) => boolean;
    "visible-change": (visible: boolean) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
    clear: () => boolean;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly allowCreate: BooleanConstructor;
    readonly autocomplete: EpPropFinalized<(new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list") | ((new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list"))[], unknown, unknown, "none", boolean>;
    readonly automaticDropdown: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "light", boolean>;
    readonly collapseTags: BooleanConstructor;
    readonly collapseTagsTooltip: BooleanConstructor;
    readonly maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly defaultFirstOption: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly estimatedOptionHeight: EpPropFinalized<NumberConstructor, unknown, unknown, undefined, boolean>;
    readonly filterable: BooleanConstructor;
    readonly filterMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: EpPropFinalized<NumberConstructor, unknown, unknown, 274, boolean>;
    readonly itemHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 34, boolean>;
    readonly id: StringConstructor;
    readonly loading: BooleanConstructor;
    readonly loadingText: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => any) | (() => any) | {
        (): any;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => any) | (() => any) | {
        (): any;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly multiple: BooleanConstructor;
    readonly multipleLimit: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly name: StringConstructor;
    readonly noDataText: StringConstructor;
    readonly noMatchText: StringConstructor;
    readonly remoteMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly reserveKeyword: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly options: {
        readonly type: PropType<OptionType[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    readonly remote: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly props: EpPropFinalized<(new (...args: any[]) => Props_2) | (() => Props_2) | ((new (...args: any[]) => Props_2) | (() => Props_2))[], unknown, unknown, () => Required<Props_2>, boolean>;
    readonly valueKey: EpPropFinalized<StringConstructor, unknown, unknown, "value", boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom-start", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom-start",
        "top-start",
        "right",
        "left"
    ], boolean>;
    readonly tagType: {
        readonly default: "info";
        readonly type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tagEffect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fitInputWidth: EpPropFinalized<readonly [
        BooleanConstructor,
        NumberConstructor
    ], unknown, number | boolean, true, boolean>;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:modelValue"?: ((val: any) => any) | undefined;
    onChange?: ((val: any) => any) | undefined;
    onFocus?: ((evt: FocusEvent) => any) | undefined;
    onBlur?: ((evt: FocusEvent) => any) | undefined;
    onClear?: (() => any) | undefined;
    "onVisible-change"?: ((visible: boolean) => any) | undefined;
    "onRemove-tag"?: ((val: unknown) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly height: number;
    readonly offset: number;
    readonly multiple: boolean;
    readonly props: Props_2;
    readonly loading: boolean;
    readonly modelValue: any;
    readonly placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown>;
    readonly effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly tabindex: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
    readonly valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly autocomplete: EpPropMergeType<(new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list") | ((new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list"))[], unknown, unknown>;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly clearable: boolean;
    readonly fallbackPlacements: Placement[];
    readonly popperOptions: Partial<Options>;
    readonly teleported: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showArrow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly valueKey: string;
    readonly fitInputWidth: EpPropMergeType<readonly [
        BooleanConstructor,
        NumberConstructor
    ], unknown, number | boolean>;
    readonly filterable: boolean;
    readonly collapseTags: boolean;
    readonly maxCollapseTags: number;
    readonly collapseTagsTooltip: boolean;
    readonly tagType: EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>;
    readonly tagEffect: EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>;
    readonly scrollbarAlwaysOn: boolean;
    readonly estimatedOptionHeight: number;
    readonly itemHeight: number;
    readonly multipleLimit: number;
    readonly reserveKeyword: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly allowCreate: boolean;
    readonly automaticDropdown: boolean;
    readonly defaultFirstOption: boolean;
    readonly remote: boolean;
}>;
declare const _default_78: __VLS_WithTemplateSlots_64<typeof __VLS_component_64, ReturnType<typeof __VLS_template_64>>;
declare const _default_79: DefineComponent<{
    readonly variant: EpPropFinalized<StringConstructor, "button" | "caption" | "h1" | "h3" | "p" | "circle" | "image" | "rect" | "text", unknown, "text", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly variant: EpPropFinalized<StringConstructor, "button" | "caption" | "h1" | "h3" | "p" | "circle" | "image" | "rect" | "text", unknown, "text", boolean>;
}>>, {
    readonly variant: EpPropMergeType<StringConstructor, "button" | "caption" | "h1" | "h3" | "p" | "circle" | "image" | "rect" | "text", unknown>;
}>;
declare const _default_8: __VLS_WithTemplateSlots_7<typeof __VLS_component_7, ReturnType<typeof __VLS_template_6>>;
declare const _default_80: DefineComponent<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => Arrayable<number>) | ((new (...args: any[]) => number | number[]) | (() => Arrayable<number>))[], unknown, unknown, 0, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly min: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 100, boolean>;
    readonly step: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly showInput: BooleanConstructor;
    readonly showInputControls: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly inputSize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showStops: BooleanConstructor;
    readonly showTooltip: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly formatTooltip: EpPropFinalized<(new (...args: any[]) => (val: number) => number | string) | (() => (val: number) => number | string) | {
        (): (val: number) => number | string;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (val: number) => number | string) | (() => (val: number) => number | string) | {
        (): (val: number) => number | string;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly disabled: BooleanConstructor;
    readonly range: BooleanConstructor;
    readonly vertical: BooleanConstructor;
    readonly height: StringConstructor;
    readonly debounce: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly rangeStartLabel: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly rangeEndLabel: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly formatValueText: EpPropFinalized<(new (...args: any[]) => (val: number) => string) | (() => (val: number) => string) | {
        (): (val: number) => string;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (val: number) => string) | (() => (val: number) => string) | {
        (): (val: number) => string;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly tooltipClass: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "top", boolean>;
    readonly marks: {
        readonly type: PropType<{
            [x: number]: EpPropMergeType<(new (...args: any[]) => string | {
                style: CSSProperties;
                label: any;
            }) | (() => string | {
                style: CSSProperties;
                label: any;
            }) | ((new (...args: any[]) => string | {
                style: CSSProperties;
                label: any;
            }) | (() => string | {
                style: CSSProperties;
                label: any;
            }))[], unknown, unknown> | undefined;
        }>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}, {
    onSliderClick: (event: MouseEvent | TouchEvent) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: Arrayable<number>) => void;
    change: (value: Arrayable<number>) => void;
    input: (value: Arrayable<number>) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => Arrayable<number>) | ((new (...args: any[]) => number | number[]) | (() => Arrayable<number>))[], unknown, unknown, 0, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly min: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 100, boolean>;
    readonly step: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly showInput: BooleanConstructor;
    readonly showInputControls: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly inputSize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showStops: BooleanConstructor;
    readonly showTooltip: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly formatTooltip: EpPropFinalized<(new (...args: any[]) => (val: number) => number | string) | (() => (val: number) => number | string) | {
        (): (val: number) => number | string;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (val: number) => number | string) | (() => (val: number) => number | string) | {
        (): (val: number) => number | string;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly disabled: BooleanConstructor;
    readonly range: BooleanConstructor;
    readonly vertical: BooleanConstructor;
    readonly height: StringConstructor;
    readonly debounce: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly rangeStartLabel: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly rangeEndLabel: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly formatValueText: EpPropFinalized<(new (...args: any[]) => (val: number) => string) | (() => (val: number) => string) | {
        (): (val: number) => string;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (val: number) => string) | (() => (val: number) => string) | {
        (): (val: number) => string;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly tooltipClass: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "top", boolean>;
    readonly marks: {
        readonly type: PropType<{
            [x: number]: EpPropMergeType<(new (...args: any[]) => string | {
                style: CSSProperties;
                label: any;
            }) | (() => string | {
                style: CSSProperties;
                label: any;
            }) | ((new (...args: any[]) => string | {
                style: CSSProperties;
                label: any;
            }) | (() => string | {
                style: CSSProperties;
                label: any;
            }))[], unknown, unknown> | undefined;
        }>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((value: Arrayable<number>) => any) | undefined;
    onChange?: ((value: Arrayable<number>) => any) | undefined;
    onInput?: ((value: Arrayable<number>) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly vertical: boolean;
    readonly range: boolean;
    readonly id: string;
    readonly modelValue: EpPropMergeType<(new (...args: any[]) => number | number[]) | (() => Arrayable<number>) | ((new (...args: any[]) => number | number[]) | (() => Arrayable<number>))[], unknown, unknown>;
    readonly placement: EpPropMergeType<StringConstructor, Placement, unknown>;
    readonly min: number;
    readonly max: number;
    readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly persistent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly debounce: number;
    readonly step: number;
    readonly showInputControls: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showTooltip: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly formatTooltip: (val: number) => number | string;
    readonly rangeStartLabel: string;
    readonly rangeEndLabel: string;
    readonly formatValueText: (val: number) => string;
    readonly tooltipClass: string;
    readonly showInput: boolean;
    readonly showStops: boolean;
}>;
declare const _default_81: __VLS_WithTemplateSlots_65<typeof __VLS_component_65, ReturnType<typeof __VLS_template_65>>;
declare const _default_82: __VLS_WithTemplateSlots_66<typeof __VLS_component_66, ReturnType<typeof __VLS_template_66>>;
declare const _default_83: __VLS_WithTemplateSlots_67<typeof __VLS_component_67, ReturnType<typeof __VLS_template_67>>;
declare const _default_84: __VLS_WithTemplateSlots_68<typeof __VLS_component_68, ReturnType<typeof __VLS_template_68>>;
declare const _default_85: DefineComponent<{
    data: {
        type: PropType<any[]>;
        default: () => never[];
    };
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    width: (NumberConstructor | StringConstructor)[];
    height: (NumberConstructor | StringConstructor)[];
    maxHeight: (NumberConstructor | StringConstructor)[];
    fit: {
        type: BooleanConstructor;
        default: boolean;
    };
    stripe: BooleanConstructor;
    border: BooleanConstructor;
    rowKey: PropType<TableProps<any>["rowKey"]>;
    showHeader: {
        type: BooleanConstructor;
        default: boolean;
    };
    showSummary: BooleanConstructor;
    sumText: StringConstructor;
    summaryMethod: PropType<TableProps<any>["summaryMethod"]>;
    rowClassName: PropType<TableProps<any>["rowClassName"]>;
    rowStyle: PropType<TableProps<any>["rowStyle"]>;
    cellClassName: PropType<TableProps<any>["cellClassName"]>;
    cellStyle: PropType<TableProps<any>["cellStyle"]>;
    headerRowClassName: PropType<TableProps<any>["headerRowClassName"]>;
    headerRowStyle: PropType<TableProps<any>["headerRowStyle"]>;
    headerCellClassName: PropType<TableProps<any>["headerCellClassName"]>;
    headerCellStyle: PropType<TableProps<any>["headerCellStyle"]>;
    highlightCurrentRow: BooleanConstructor;
    currentRowKey: (NumberConstructor | StringConstructor)[];
    emptyText: StringConstructor;
    expandRowKeys: PropType<TableProps<any>["expandRowKeys"]>;
    defaultExpandAll: BooleanConstructor;
    defaultSort: PropType<TableProps<any>["defaultSort"]>;
    tooltipEffect: StringConstructor;
    tooltipOptions: PropType<TableProps<any>["tooltipOptions"]>;
    spanMethod: PropType<TableProps<any>["spanMethod"]>;
    selectOnIndeterminate: {
        type: BooleanConstructor;
        default: boolean;
    };
    indent: {
        type: NumberConstructor;
        default: number;
    };
    treeProps: {
        type: PropType<TableProps<any>["treeProps"]>;
        default: () => {
            hasChildren: string;
            children: string;
            checkStrictly: boolean;
        };
    };
    lazy: BooleanConstructor;
    load: PropType<TableProps<any>["load"]>;
    style: {
        type: PropType<CSSProperties>;
        default: () => {};
    };
    className: {
        type: StringConstructor;
        default: string;
    };
    tableLayout: {
        type: PropType<"fixed" | "auto">;
        default: string;
    };
    scrollbarAlwaysOn: BooleanConstructor;
    flexible: BooleanConstructor;
    showOverflowTooltip: PropType<TableProps<any>["showOverflowTooltip"]>;
    tooltipFormatter: PropType<TableProps<any>["tooltipFormatter"]>;
    appendFilterPanelTo: StringConstructor;
    scrollbarTabindex: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    allowDragLastColumn: {
        type: BooleanConstructor;
        default: boolean;
    };
    preserveExpandedContent: BooleanConstructor;
    nativeScrollbar: BooleanConstructor;
}, {
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    layout: TableLayout<any>;
    store: {
        mutations: {
            setData(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, data: any[]): void;
            insertColumn(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, column: TableColumnCtx<any>, parent: TableColumnCtx<any>, updateColumnOrder: () => void): void;
            updateColumnOrder(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, column: TableColumnCtx<any>): void;
            removeColumn(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, column: TableColumnCtx<any>, parent: TableColumnCtx<any>, updateColumnOrder: () => void): void;
            sort(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, options: Sort): void;
            changeSortCondition(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, options: Sort): void;
            filterChange(_states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, options: Filter<any>): void;
            toggleAllSelection(): void;
            rowSelectedChanged(_states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, row: any): void;
            setHoverRow(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, row: any): void;
            setCurrentRow(_states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<any>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, any[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<any[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<any[]>;
                _data: Ref<any[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<any>[]>;
                originColumns: Ref<TableColumnCtx<any>[]>;
                columns: Ref<TableColumnCtx<any>[]>;
                fixedColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedColumns: Ref<TableColumnCtx<any>[]>;
                leafColumns: Ref<TableColumnCtx<any>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<any[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: any, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<any[] | null>;
                sortingColumn: Ref<TableColumnCtx<any> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<any>;
            }, row: any): void;
        };
        commit: (name: "sort" | "setData" | "insertColumn" | "updateColumnOrder" | "removeColumn" | "changeSortCondition" | "filterChange" | "toggleAllSelection" | "rowSelectedChanged" | "setHoverRow" | "setCurrentRow", ...args: any[]) => void;
        updateTableScrollY: () => void;
        assertRowKey: () => void;
        updateColumns: () => void;
        scheduleLayout: (needUpdateColumns?: boolean, immediate?: boolean) => void;
        isSelected: (row: any) => boolean;
        clearSelection: () => void;
        cleanSelection: () => void;
        getSelectionRows: () => any[];
        toggleRowSelection: (row: any, selected?: boolean, emitChange?: boolean, ignoreSelectable?: boolean) => void;
        _toggleAllSelection: () => void;
        toggleAllSelection: (() => void) | null;
        updateAllSelected: () => void;
        updateFilters: (column: TableColumnCtx<any>, values: string[]) => Record<string, string[]>;
        updateCurrentRow: (_currentRow: any) => void;
        updateSort: (column: TableColumnCtx<any> | null, prop: string | null, order: TableSortOrder | null) => void;
        execFilter: () => void;
        execSort: () => void;
        execQuery: (ignore?: {
            filter: boolean;
        } | undefined) => void;
        clearFilter: (columnKeys?: string[] | string) => void;
        clearSort: () => void;
        toggleRowExpansion: (row: any, expanded?: boolean) => void;
        setExpandRowKeysAdapter: (val: string[]) => void;
        setCurrentRowKey: (key: string) => void;
        toggleRowExpansionAdapter: (row: any, expanded?: boolean) => void;
        isRowExpanded: (row: any) => boolean;
        updateExpandRows: () => void;
        updateCurrentRowData: () => void;
        loadOrToggle: (row: any) => void;
        updateTreeData: (ifChangeExpandRowKeys?: boolean, ifExpandAll?: boolean) => void;
        updateKeyChildren: (key: string, data: any[]) => void;
        states: {
            _currentRowKey: Ref<string | null>;
            currentRow: Ref<any>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<Record<string, TreeData_2>>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<Record<string, any[]>>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<any[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string | null>;
            data: Ref<any[]>;
            _data: Ref<any[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<any>[]>;
            originColumns: Ref<TableColumnCtx<any>[]>;
            columns: Ref<TableColumnCtx<any>[]>;
            fixedColumns: Ref<TableColumnCtx<any>[]>;
            rightFixedColumns: Ref<TableColumnCtx<any>[]>;
            leafColumns: Ref<TableColumnCtx<any>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<any>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<any>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<any[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<((row: any, index: number) => boolean) | null>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<any[] | null>;
            sortingColumn: Ref<TableColumnCtx<any> | null>;
            sortProp: Ref<string | null>;
            sortOrder: Ref<string | number | null>;
            hoverRow: Ref<any>;
        };
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string) => string;
            e: (element?: string) => string;
            m: (modifier?: string) => string;
            be: (blockSuffix?: string, element?: string) => string;
            em: (element?: string, modifier?: string) => string;
            bm: (blockSuffix?: string, modifier?: string) => string;
            bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
    };
    columns: ComputedRef<TableColumnCtx<any>[]>;
    handleHeaderFooterMousewheel: (_event: WheelEvent, data: any) => void;
    handleMouseLeave: () => void;
    tableId: string;
    tableSize: ComputedRef<"" | "small" | "default" | "large">;
    isHidden: Ref<boolean>;
    isEmpty: ComputedRef<boolean>;
    renderExpanded: Ref<RenderExpanded<any> | null>;
    resizeProxyVisible: Ref<boolean>;
    resizeState: Ref<{
        width: null | number;
        height: null | number;
        headerHeight: null | number;
    }>;
    isGroup: Ref<boolean>;
    bodyWidth: ComputedRef<string>;
    tableBodyStyles: ComputedRef<{
        width: string;
    }>;
    emptyBlockStyle: ComputedRef<{
        width: string;
        height: string;
    } | undefined>;
    debouncedUpdateLayout: DebouncedFunc<() => void>;
    /**
    * @description used in single selection Table, set a certain row selected. If called without any parameter, it will clear selection
    */
    setCurrentRow: (row: any) => void;
    /**
    * @description returns the currently selected rows
    */
    getSelectionRows: () => any[];
    /**
    * @description used in multiple selection Table, toggle if a certain row is selected. With the second parameter, you can directly set if this row is selected
    */
    toggleRowSelection: (row: any, selected?: boolean, ignoreSelectable?: boolean) => void;
    /**
    * @description used in multiple selection Table, clear user selection
    */
    clearSelection: () => void;
    /**
    * @description clear filters of the columns whose `columnKey` are passed in. If no params, clear all filters
    */
    clearFilter: (columnKeys?: string[] | string) => void;
    /**
    * @description used in multiple selection Table, toggle select all and deselect all
    */
    toggleAllSelection: () => void;
    /**
    * @description used in expandable Table or tree Table, toggle if a certain row is expanded. With the second parameter, you can directly set if this row is expanded or collapsed
    */
    toggleRowExpansion: (row: any, expanded?: boolean) => void;
    /**
    * @description clear sorting, restore data to the original order
    */
    clearSort: () => void;
    /**
    * @description refresh the layout of Table. When the visibility of Table changes, you may need to call this method to get a correct layout
    */
    doLayout: () => void;
    /**
    * @description sort Table manually. Property `prop` is used to set sort column, property `order` is used to set sort order
    */
    sort: (prop: string, order: string) => void;
    /**
    * @description used in lazy Table, must set `rowKey`, update key children
    */
    updateKeyChildren: (key: string, data: any[]) => void;
    t: Translator;
    setDragVisible: (visible: boolean) => void;
    context: Table<any>;
    computedSumText: ComputedRef<string>;
    computedEmptyText: ComputedRef<string>;
    tableLayout: ComputedRef<("fixed" | "auto") | undefined>;
    scrollbarViewStyle: {
        display: string;
        verticalAlign: string;
    };
    scrollbarStyle: ComputedRef<{
        height: string;
        maxHeight?: undefined;
    } | {
        maxHeight: string;
        height?: undefined;
    } | {
        height?: undefined;
        maxHeight?: undefined;
    }>;
    scrollBarRef: Ref<any>;
    /**
    * @description scrolls to a particular set of coordinates
    */
    scrollTo: (options: ScrollToOptions | number, yCoord?: number) => void;
    /**
    * @description set horizontal scroll position
    */
    setScrollLeft: (left?: number) => void;
    /**
    * @description set vertical scroll position
    */
    setScrollTop: (top?: number) => void;
    /**
    * @description whether to allow drag the last column
    */
    allowDragLastColumn: boolean;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("select" | "scroll" | "select-all" | "expand-change" | "current-change" | "header-click" | "header-contextmenu" | "header-dragend" | "selection-change" | "sort-change" | "filter-change" | "cell-mouse-enter" | "cell-mouse-leave" | "cell-contextmenu" | "cell-click" | "cell-dblclick" | "row-click" | "row-contextmenu" | "row-dblclick")[], "select" | "scroll" | "select-all" | "expand-change" | "current-change" | "header-click" | "header-contextmenu" | "header-dragend" | "selection-change" | "sort-change" | "filter-change" | "cell-mouse-enter" | "cell-mouse-leave" | "cell-contextmenu" | "cell-click" | "cell-dblclick" | "row-click" | "row-contextmenu" | "row-dblclick", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    data: {
        type: PropType<any[]>;
        default: () => never[];
    };
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    width: (NumberConstructor | StringConstructor)[];
    height: (NumberConstructor | StringConstructor)[];
    maxHeight: (NumberConstructor | StringConstructor)[];
    fit: {
        type: BooleanConstructor;
        default: boolean;
    };
    stripe: BooleanConstructor;
    border: BooleanConstructor;
    rowKey: PropType<TableProps<any>["rowKey"]>;
    showHeader: {
        type: BooleanConstructor;
        default: boolean;
    };
    showSummary: BooleanConstructor;
    sumText: StringConstructor;
    summaryMethod: PropType<TableProps<any>["summaryMethod"]>;
    rowClassName: PropType<TableProps<any>["rowClassName"]>;
    rowStyle: PropType<TableProps<any>["rowStyle"]>;
    cellClassName: PropType<TableProps<any>["cellClassName"]>;
    cellStyle: PropType<TableProps<any>["cellStyle"]>;
    headerRowClassName: PropType<TableProps<any>["headerRowClassName"]>;
    headerRowStyle: PropType<TableProps<any>["headerRowStyle"]>;
    headerCellClassName: PropType<TableProps<any>["headerCellClassName"]>;
    headerCellStyle: PropType<TableProps<any>["headerCellStyle"]>;
    highlightCurrentRow: BooleanConstructor;
    currentRowKey: (NumberConstructor | StringConstructor)[];
    emptyText: StringConstructor;
    expandRowKeys: PropType<TableProps<any>["expandRowKeys"]>;
    defaultExpandAll: BooleanConstructor;
    defaultSort: PropType<TableProps<any>["defaultSort"]>;
    tooltipEffect: StringConstructor;
    tooltipOptions: PropType<TableProps<any>["tooltipOptions"]>;
    spanMethod: PropType<TableProps<any>["spanMethod"]>;
    selectOnIndeterminate: {
        type: BooleanConstructor;
        default: boolean;
    };
    indent: {
        type: NumberConstructor;
        default: number;
    };
    treeProps: {
        type: PropType<TableProps<any>["treeProps"]>;
        default: () => {
            hasChildren: string;
            children: string;
            checkStrictly: boolean;
        };
    };
    lazy: BooleanConstructor;
    load: PropType<TableProps<any>["load"]>;
    style: {
        type: PropType<CSSProperties>;
        default: () => {};
    };
    className: {
        type: StringConstructor;
        default: string;
    };
    tableLayout: {
        type: PropType<"fixed" | "auto">;
        default: string;
    };
    scrollbarAlwaysOn: BooleanConstructor;
    flexible: BooleanConstructor;
    showOverflowTooltip: PropType<TableProps<any>["showOverflowTooltip"]>;
    tooltipFormatter: PropType<TableProps<any>["tooltipFormatter"]>;
    appendFilterPanelTo: StringConstructor;
    scrollbarTabindex: {
        type: (NumberConstructor | StringConstructor)[];
        default: undefined;
    };
    allowDragLastColumn: {
        type: BooleanConstructor;
        default: boolean;
    };
    preserveExpandedContent: BooleanConstructor;
    nativeScrollbar: BooleanConstructor;
}>> & {
    onScroll?: ((...args: any[]) => any) | undefined;
    onSelect?: ((...args: any[]) => any) | undefined;
    "onExpand-change"?: ((...args: any[]) => any) | undefined;
    "onCurrent-change"?: ((...args: any[]) => any) | undefined;
    "onSelect-all"?: ((...args: any[]) => any) | undefined;
    "onHeader-click"?: ((...args: any[]) => any) | undefined;
    "onHeader-contextmenu"?: ((...args: any[]) => any) | undefined;
    "onHeader-dragend"?: ((...args: any[]) => any) | undefined;
    "onSelection-change"?: ((...args: any[]) => any) | undefined;
    "onSort-change"?: ((...args: any[]) => any) | undefined;
    "onFilter-change"?: ((...args: any[]) => any) | undefined;
    "onCell-mouse-enter"?: ((...args: any[]) => any) | undefined;
    "onCell-mouse-leave"?: ((...args: any[]) => any) | undefined;
    "onCell-contextmenu"?: ((...args: any[]) => any) | undefined;
    "onCell-click"?: ((...args: any[]) => any) | undefined;
    "onCell-dblclick"?: ((...args: any[]) => any) | undefined;
    "onRow-click"?: ((...args: any[]) => any) | undefined;
    "onRow-contextmenu"?: ((...args: any[]) => any) | undefined;
    "onRow-dblclick"?: ((...args: any[]) => any) | undefined;
}, {
    data: any[];
    style: CSSProperties;
    tableLayout: "fixed" | "auto";
    border: boolean;
    className: string;
    fit: boolean;
    lazy: boolean;
    scrollbarAlwaysOn: boolean;
    allowDragLastColumn: boolean;
    treeProps: TreeProps | undefined;
    defaultExpandAll: boolean;
    selectOnIndeterminate: boolean;
    indent: number;
    stripe: boolean;
    showHeader: boolean;
    showSummary: boolean;
    highlightCurrentRow: boolean;
    flexible: boolean;
    scrollbarTabindex: string | number;
    nativeScrollbar: boolean;
    preserveExpandedContent: boolean;
}>;
declare const _default_86: DefineComponent<{
    type: {
        type: StringConstructor;
        default: string;
    };
    label: StringConstructor;
    className: StringConstructor;
    labelClassName: StringConstructor;
    property: StringConstructor;
    prop: StringConstructor;
    width: {
        type: (NumberConstructor | StringConstructor)[];
        default: string;
    };
    minWidth: {
        type: (NumberConstructor | StringConstructor)[];
        default: string;
    };
    renderHeader: PropType<TableColumnCtx<any>["renderHeader"]>;
    sortable: {
        type: (BooleanConstructor | StringConstructor)[];
        default: boolean;
    };
    sortMethod: PropType<TableColumnCtx<any>["sortMethod"]>;
    sortBy: PropType<TableColumnCtx<any>["sortBy"]>;
    resizable: {
        type: BooleanConstructor;
        default: boolean;
    };
    columnKey: StringConstructor;
    align: StringConstructor;
    headerAlign: StringConstructor;
    showOverflowTooltip: {
        type: PropType<TableColumnCtx<any>["showOverflowTooltip"]>;
        default: undefined;
    };
    tooltipFormatter: PropType<TableColumnCtx<any>["tooltipFormatter"]>;
    fixed: (BooleanConstructor | StringConstructor)[];
    formatter: PropType<TableColumnCtx<any>["formatter"]>;
    selectable: PropType<TableColumnCtx<any>["selectable"]>;
    reserveSelection: BooleanConstructor;
    filterMethod: PropType<TableColumnCtx<any>["filterMethod"]>;
    filteredValue: PropType<TableColumnCtx<any>["filteredValue"]>;
    filters: PropType<TableColumnCtx<any>["filters"]>;
    filterPlacement: StringConstructor;
    filterMultiple: {
        type: BooleanConstructor;
        default: boolean;
    };
    filterClassName: StringConstructor;
    index: PropType<TableColumnCtx<any>["index"]>;
    sortOrders: {
        type: PropType<TableColumnCtx<any>["sortOrders"]>;
        default: () => (string | null)[];
        validator: (val: TableColumnCtx<any>["sortOrders"]) => boolean;
    };
}, void, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    type: {
        type: StringConstructor;
        default: string;
    };
    label: StringConstructor;
    className: StringConstructor;
    labelClassName: StringConstructor;
    property: StringConstructor;
    prop: StringConstructor;
    width: {
        type: (NumberConstructor | StringConstructor)[];
        default: string;
    };
    minWidth: {
        type: (NumberConstructor | StringConstructor)[];
        default: string;
    };
    renderHeader: PropType<TableColumnCtx<any>["renderHeader"]>;
    sortable: {
        type: (BooleanConstructor | StringConstructor)[];
        default: boolean;
    };
    sortMethod: PropType<TableColumnCtx<any>["sortMethod"]>;
    sortBy: PropType<TableColumnCtx<any>["sortBy"]>;
    resizable: {
        type: BooleanConstructor;
        default: boolean;
    };
    columnKey: StringConstructor;
    align: StringConstructor;
    headerAlign: StringConstructor;
    showOverflowTooltip: {
        type: PropType<TableColumnCtx<any>["showOverflowTooltip"]>;
        default: undefined;
    };
    tooltipFormatter: PropType<TableColumnCtx<any>["tooltipFormatter"]>;
    fixed: (BooleanConstructor | StringConstructor)[];
    formatter: PropType<TableColumnCtx<any>["formatter"]>;
    selectable: PropType<TableColumnCtx<any>["selectable"]>;
    reserveSelection: BooleanConstructor;
    filterMethod: PropType<TableColumnCtx<any>["filterMethod"]>;
    filteredValue: PropType<TableColumnCtx<any>["filteredValue"]>;
    filters: PropType<TableColumnCtx<any>["filters"]>;
    filterPlacement: StringConstructor;
    filterMultiple: {
        type: BooleanConstructor;
        default: boolean;
    };
    filterClassName: StringConstructor;
    index: PropType<TableColumnCtx<any>["index"]>;
    sortOrders: {
        type: PropType<TableColumnCtx<any>["sortOrders"]>;
        default: () => (string | null)[];
        validator: (val: TableColumnCtx<any>["sortOrders"]) => boolean;
    };
}>>, {
    width: string | number;
    minWidth: string | number;
    type: string;
    resizable: boolean;
    showOverflowTooltip: boolean | Partial<Pick<ElTooltipProps, "offset" | "transition" | "placement" | "effect" | "showAfter" | "hideAfter" | "popperOptions" | "enterable" | "popperClass" | "appendTo" | "showArrow">> | undefined;
    sortOrders: (TableSortOrder | null)[];
    sortable: string | boolean;
    reserveSelection: boolean;
    filterMultiple: boolean;
}>;
declare const _default_87: __VLS_WithTemplateSlots_69<typeof __VLS_component_69, ReturnType<typeof __VLS_template_69>>;
declare const _default_88: DefineComponent<{
    readonly tabs: EpPropFinalized<(new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | ((new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly tabRefs: EpPropFinalized<(new (...args: any[]) => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | (() => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | ((new (...args: any[]) => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | (() => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }))[], unknown, unknown, () => Mutable<{}>, boolean>;
}, {
    /** @description tab root html element */
    ref: Ref<HTMLDivElement | undefined>;
    /** @description method to manually update tab bar style */
    update: () => CSSProperties;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly tabs: EpPropFinalized<(new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | ((new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly tabRefs: EpPropFinalized<(new (...args: any[]) => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | (() => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | ((new (...args: any[]) => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | (() => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }))[], unknown, unknown, () => Mutable<{}>, boolean>;
}>>, {
    readonly tabs: {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[];
    readonly tabRefs: {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    };
}>;
declare const _default_89: __VLS_WithTemplateSlots_70<typeof __VLS_component_70, ReturnType<typeof __VLS_template_70>>;
declare const _default_9: __VLS_WithTemplateSlots_9<typeof __VLS_component_9, ReturnType<typeof __VLS_template_9>>;
declare const _default_90: __VLS_WithTemplateSlots_71<typeof __VLS_component_71, ReturnType<typeof __VLS_template_71>>;
declare const _default_91: DefineComponent<{
    /**
    * @description whether to pick a time range
    */
    isRange: BooleanConstructor;
    showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    showWeekNumber: BooleanConstructor;
    ariaLabel: StringConstructor;
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    arrowControl: BooleanConstructor;
    tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    unlinkPanels: BooleanConstructor;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    format: StringConstructor;
    valueFormat: StringConstructor;
    dateFormat: StringConstructor;
    timeFormat: StringConstructor;
    type: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly: BooleanConstructor;
    disabled: BooleanConstructor;
    placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    startPlaceholder: StringConstructor;
    endPlaceholder: StringConstructor;
    defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, "update:modelValue"[], "update:modelValue", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    /**
    * @description whether to pick a time range
    */
    isRange: BooleanConstructor;
    showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    showWeekNumber: BooleanConstructor;
    ariaLabel: StringConstructor;
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    arrowControl: BooleanConstructor;
    tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    unlinkPanels: BooleanConstructor;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    format: StringConstructor;
    valueFormat: StringConstructor;
    dateFormat: StringConstructor;
    timeFormat: StringConstructor;
    type: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly: BooleanConstructor;
    disabled: BooleanConstructor;
    placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    startPlaceholder: StringConstructor;
    endPlaceholder: StringConstructor;
    defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
}, {
    disabled: boolean;
    type: string;
    placeholder: string;
    modelValue: EpPropMergeType<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown>;
    placement: EpPropMergeType<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown>;
    tabindex: EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>;
    valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly: boolean;
    prefixIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    clearable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    fallbackPlacements: Placement[];
    popperOptions: Partial<Options>;
    editable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    rangeSeparator: string;
    shortcuts: unknown[];
    showNow: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    showConfirm: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    showFooter: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    showWeekNumber: boolean;
    arrowControl: boolean;
    unlinkPanels: boolean;
    isRange: boolean;
}>;
declare const _default_92: DefineComponent<{
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "HH:mm", boolean>;
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "light", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly start: EpPropFinalized<StringConstructor, unknown, unknown, "09:00", boolean>;
    readonly end: EpPropFinalized<StringConstructor, unknown, unknown, "18:00", boolean>;
    readonly step: EpPropFinalized<StringConstructor, unknown, unknown, "00:30", boolean>;
    readonly minTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly maxTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly includeEndTime: BooleanConstructor;
    readonly name: StringConstructor;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly clearIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
}, {
    /**
    * @description blur the Input component
    */
    blur: () => void;
    /**
    * @description focus the Input component
    */
    focus: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    clear: (...args: any[]) => void;
    "update:modelValue": (...args: any[]) => void;
    change: (...args: any[]) => void;
    blur: (...args: any[]) => void;
    focus: (...args: any[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "HH:mm", boolean>;
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "light", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly start: EpPropFinalized<StringConstructor, unknown, unknown, "09:00", boolean>;
    readonly end: EpPropFinalized<StringConstructor, unknown, unknown, "18:00", boolean>;
    readonly step: EpPropFinalized<StringConstructor, unknown, unknown, "00:30", boolean>;
    readonly minTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly maxTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly includeEndTime: BooleanConstructor;
    readonly name: StringConstructor;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly clearIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
}>> & {
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    onFocus?: ((...args: any[]) => any) | undefined;
    onBlur?: ((...args: any[]) => any) | undefined;
    onClear?: ((...args: any[]) => any) | undefined;
}, {
    readonly disabled: boolean;
    readonly end: string;
    readonly start: string;
    readonly effect: EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>;
    readonly valueOnClear: EpPropMergeType<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown>;
    readonly format: string;
    readonly clearIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly prefixIcon: EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>;
    readonly clearable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly editable: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly step: string;
    readonly includeEndTime: boolean;
}>;
declare const _default_93: __VLS_WithTemplateSlots_73<typeof __VLS_component_73, ReturnType<typeof __VLS_template_73>>;
declare const _default_94: __VLS_WithTemplateSlots_74<typeof __VLS_component_74, ReturnType<typeof __VLS_template_75>>;
declare const _default_95: __VLS_WithTemplateSlots_75<typeof __VLS_component_75, ReturnType<typeof __VLS_template_74>>;
declare const _default_96: DefineComponent<{
    data: {
        type: PropType<TreeData>;
        default: () => never[];
    };
    emptyText: {
        type: StringConstructor;
    };
    renderAfterExpand: {
        type: BooleanConstructor;
        default: boolean;
    };
    nodeKey: StringConstructor;
    checkStrictly: BooleanConstructor;
    defaultExpandAll: BooleanConstructor;
    expandOnClickNode: {
        type: BooleanConstructor;
        default: boolean;
    };
    checkOnClickNode: BooleanConstructor;
    checkOnClickLeaf: {
        type: BooleanConstructor;
        default: boolean;
    };
    checkDescendants: BooleanConstructor;
    autoExpandParent: {
        type: BooleanConstructor;
        default: boolean;
    };
    defaultCheckedKeys: PropType<TreeComponentProps["defaultCheckedKeys"]>;
    defaultExpandedKeys: PropType<TreeComponentProps["defaultExpandedKeys"]>;
    currentNodeKey: PropType<string | number>;
    renderContent: {
        type: PropType<RenderContentFunction>;
    };
    showCheckbox: BooleanConstructor;
    draggable: BooleanConstructor;
    allowDrag: {
        type: PropType<AllowDragFunction>;
    };
    allowDrop: {
        type: PropType<AllowDropFunction>;
    };
    props: {
        type: PropType<TreeComponentProps["props"]>;
        default: () => {
            children: string;
            label: string;
            disabled: string;
        };
    };
    lazy: BooleanConstructor;
    highlightCurrent: BooleanConstructor;
    load: PropType<TreeComponentProps["load"]>;
    filterNodeMethod: PropType<TreeComponentProps["filterNodeMethod"]>;
    accordion: BooleanConstructor;
    indent: {
        type: NumberConstructor;
        default: number;
    };
    icon: {
        type: PropType<string | Component>;
    };
}, {
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    store: Ref<{
        currentNode: {
            id: number;
            text: string | null;
            checked: boolean;
            indeterminate: boolean;
            data: TreeNodeData;
            expanded: boolean;
            parent: any | null;
            visible: boolean;
            isCurrent: boolean;
            store: any;
            isLeafByUser: boolean | undefined;
            isLeaf: boolean | undefined;
            canFocus: boolean;
            level: number;
            loaded: boolean;
            childNodes: any[];
            loading: boolean;
            initialize: () => void;
            setData: (data: TreeNodeData) => void;
            readonly label: string;
            readonly key: TreeKey | null | undefined;
            readonly disabled: boolean;
            readonly nextSibling: any | null;
            readonly previousSibling: any | null;
            contains: (target: Node_2, deep?: boolean) => boolean;
            remove: () => void;
            insertChild: (child?: FakeNode | Node_2, index?: number, batch?: boolean) => void;
            insertBefore: (child: FakeNode | Node_2, ref: Node_2) => void;
            insertAfter: (child: FakeNode | Node_2, ref: Node_2) => void;
            removeChild: (child: Node_2) => void;
            removeChildByData: (data: TreeNodeData | null) => void;
            expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
            doCreateChildren: (array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps) => void;
            collapse: () => void;
            shouldLoadData: () => boolean;
            updateLeafState: () => void;
            setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
            getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
            updateChildren: () => void;
            loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps) => void;
            eachNode: (callback: (node: Node_2) => void) => void;
            reInitChecked: () => void;
        } | null;
        currentNodeKey: TreeKey | null;
        nodesMap: TreeStoreNodesMap;
        root: {
            id: number;
            text: string | null;
            checked: boolean;
            indeterminate: boolean;
            data: TreeNodeData;
            expanded: boolean;
            parent: any | null;
            visible: boolean;
            isCurrent: boolean;
            store: any;
            isLeafByUser: boolean | undefined;
            isLeaf: boolean | undefined;
            canFocus: boolean;
            level: number;
            loaded: boolean;
            childNodes: any[];
            loading: boolean;
            initialize: () => void;
            setData: (data: TreeNodeData) => void;
            readonly label: string;
            readonly key: TreeKey | null | undefined;
            readonly disabled: boolean;
            readonly nextSibling: any | null;
            readonly previousSibling: any | null;
            contains: (target: Node_2, deep?: boolean) => boolean;
            remove: () => void;
            insertChild: (child?: FakeNode | Node_2, index?: number, batch?: boolean) => void;
            insertBefore: (child: FakeNode | Node_2, ref: Node_2) => void;
            insertAfter: (child: FakeNode | Node_2, ref: Node_2) => void;
            removeChild: (child: Node_2) => void;
            removeChildByData: (data: TreeNodeData | null) => void;
            expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
            doCreateChildren: (array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps) => void;
            collapse: () => void;
            shouldLoadData: () => boolean;
            updateLeafState: () => void;
            setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
            getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
            updateChildren: () => void;
            loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps) => void;
            eachNode: (callback: (node: Node_2) => void) => void;
            reInitChecked: () => void;
        };
        data: TreeNodeData[];
        lazy: boolean;
        load?: LoadFunction | undefined;
        filterNodeMethod?: FilterNodeMethodFunction | undefined;
        key: TreeKey;
        defaultCheckedKeys?: TreeKey[] | undefined;
        checkStrictly: boolean;
        defaultExpandedKeys?: TreeKey[] | undefined;
        autoExpandParent: boolean;
        defaultExpandAll: boolean;
        checkDescendants: boolean;
        props: {
            children?: string | undefined;
            label?: (string | ((data: TreeNodeData, node: Node_2) => string)) | undefined;
            disabled?: (string | ((data: TreeNodeData, node: Node_2) => boolean)) | undefined;
            isLeaf?: (string | ((data: TreeNodeData, node: Node_2) => boolean)) | undefined;
            class?: ((data: TreeNodeData, node: Node_2) => string | {
                [key: string]: boolean;
            }) | undefined;
        };
        initialize: () => void;
        filter: (value: FilterValue) => void;
        setData: (newVal: TreeData) => void;
        getNode: (data: TreeKey | TreeNodeData | Node_2) => Node_2;
        insertBefore: (data: TreeNodeData, refData: TreeKey | TreeNodeData | Node_2) => void;
        insertAfter: (data: TreeNodeData, refData: TreeKey | TreeNodeData | Node_2) => void;
        remove: (data: TreeNodeData | Node_2) => void;
        append: (data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node_2) => void;
        _initDefaultCheckedNodes: () => void;
        _initDefaultCheckedNode: (node: Node_2) => void;
        setDefaultCheckedKey: (newVal: TreeKey[]) => void;
        registerNode: (node: Node_2) => void;
        deregisterNode: (node: Node_2) => void;
        getCheckedNodes: (leafOnly?: boolean, includeHalfChecked?: boolean) => TreeNodeData[];
        getCheckedKeys: (leafOnly?: boolean) => TreeKey[];
        getHalfCheckedNodes: () => TreeNodeData[];
        getHalfCheckedKeys: () => TreeKey[];
        _getAllNodes: () => Node_2[];
        updateChildren: (key: TreeKey, data: TreeData) => void;
        _setCheckedKeys: (key: TreeKey, leafOnly: boolean | undefined, checkedKeys: {
            [key: string]: boolean;
        }) => void;
        setCheckedNodes: (array: Node_2[], leafOnly?: boolean) => void;
        setCheckedKeys: (keys: TreeKey[], leafOnly?: boolean) => void;
        setDefaultExpandedKeys: (keys: TreeKey[]) => void;
        setChecked: (data: TreeKey | TreeNodeData, checked: boolean, deep: boolean) => void;
        getCurrentNode: () => Node_2 | null;
        setCurrentNode: (currentNode: Node_2) => void;
        setUserCurrentNode: (node: Node_2, shouldAutoExpandParent?: boolean) => void;
        setCurrentNodeKey: (key: TreeKey | null, shouldAutoExpandParent?: boolean) => void;
    }>;
    root: Ref<{
        id: number;
        text: string | null;
        checked: boolean;
        indeterminate: boolean;
        data: TreeNodeData;
        expanded: boolean;
        parent: any | null;
        visible: boolean;
        isCurrent: boolean;
        store: any;
        isLeafByUser: boolean | undefined;
        isLeaf: boolean | undefined;
        canFocus: boolean;
        level: number;
        loaded: boolean;
        childNodes: any[];
        loading: boolean;
        initialize: () => void;
        setData: (data: TreeNodeData) => void;
        readonly label: string;
        readonly key: TreeKey | null | undefined;
        readonly disabled: boolean;
        readonly nextSibling: any | null;
        readonly previousSibling: any | null;
        contains: (target: Node_2, deep?: boolean) => boolean;
        remove: () => void;
        insertChild: (child?: FakeNode | Node_2, index?: number, batch?: boolean) => void;
        insertBefore: (child: FakeNode | Node_2, ref: Node_2) => void;
        insertAfter: (child: FakeNode | Node_2, ref: Node_2) => void;
        removeChild: (child: Node_2) => void;
        removeChildByData: (data: TreeNodeData | null) => void;
        expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
        doCreateChildren: (array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps) => void;
        collapse: () => void;
        shouldLoadData: () => boolean;
        updateLeafState: () => void;
        setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
        getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
        updateChildren: () => void;
        loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps) => void;
        eachNode: (callback: (node: Node_2) => void) => void;
        reInitChecked: () => void;
    }>;
    currentNode: Ref<{
        id: number;
        text: string | null;
        checked: boolean;
        indeterminate: boolean;
        data: TreeNodeData;
        expanded: boolean;
        parent: any | null;
        visible: boolean;
        isCurrent: boolean;
        store: any;
        isLeafByUser: boolean | undefined;
        isLeaf: boolean | undefined;
        canFocus: boolean;
        level: number;
        loaded: boolean;
        childNodes: any[];
        loading: boolean;
        initialize: () => void;
        setData: (data: TreeNodeData) => void;
        readonly label: string;
        readonly key: TreeKey | null | undefined;
        readonly disabled: boolean;
        readonly nextSibling: any | null;
        readonly previousSibling: any | null;
        contains: (target: Node_2, deep?: boolean) => boolean;
        remove: () => void;
        insertChild: (child?: FakeNode | Node_2, index?: number, batch?: boolean) => void;
        insertBefore: (child: FakeNode | Node_2, ref: Node_2) => void;
        insertAfter: (child: FakeNode | Node_2, ref: Node_2) => void;
        removeChild: (child: Node_2) => void;
        removeChildByData: (data: TreeNodeData | null) => void;
        expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
        doCreateChildren: (array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps) => void;
        collapse: () => void;
        shouldLoadData: () => boolean;
        updateLeafState: () => void;
        setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
        getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
        updateChildren: () => void;
        loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps) => void;
        eachNode: (callback: (node: Node_2) => void) => void;
        reInitChecked: () => void;
    } | null>;
    dragState: Ref<{
        allowDrop: boolean;
        dropType: NodeDropType | null;
        draggingNode: {
            node: {
                id: number;
                text: string | null;
                checked: boolean;
                indeterminate: boolean;
                data: TreeNodeData;
                expanded: boolean;
                parent: any | null;
                visible: boolean;
                isCurrent: boolean;
                store: any;
                isLeafByUser: boolean | undefined;
                isLeaf: boolean | undefined;
                canFocus: boolean;
                level: number;
                loaded: boolean;
                childNodes: any[];
                loading: boolean;
                initialize: () => void;
                setData: (data: TreeNodeData) => void;
                readonly label: string;
                readonly key: TreeKey | null | undefined;
                readonly disabled: boolean;
                readonly nextSibling: any | null;
                readonly previousSibling: any | null;
                contains: (target: Node_2, deep?: boolean) => boolean;
                remove: () => void;
                insertChild: (child?: FakeNode | Node_2, index?: number, batch?: boolean) => void;
                insertBefore: (child: FakeNode | Node_2, ref: Node_2) => void;
                insertAfter: (child: FakeNode | Node_2, ref: Node_2) => void;
                removeChild: (child: Node_2) => void;
                removeChildByData: (data: TreeNodeData | null) => void;
                expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
                doCreateChildren: (array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps) => void;
                collapse: () => void;
                shouldLoadData: () => boolean;
                updateLeafState: () => void;
                setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
                getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
                updateChildren: () => void;
                loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps) => void;
                eachNode: (callback: (node: Node_2) => void) => void;
                reInitChecked: () => void;
            };
            $el?: HTMLElement | undefined;
        } | null;
        showDropIndicator: boolean;
        dropNode: {
            node: {
                id: number;
                text: string | null;
                checked: boolean;
                indeterminate: boolean;
                data: TreeNodeData;
                expanded: boolean;
                parent: any | null;
                visible: boolean;
                isCurrent: boolean;
                store: any;
                isLeafByUser: boolean | undefined;
                isLeaf: boolean | undefined;
                canFocus: boolean;
                level: number;
                loaded: boolean;
                childNodes: any[];
                loading: boolean;
                initialize: () => void;
                setData: (data: TreeNodeData) => void;
                readonly label: string;
                readonly key: TreeKey | null | undefined;
                readonly disabled: boolean;
                readonly nextSibling: any | null;
                readonly previousSibling: any | null;
                contains: (target: Node_2, deep?: boolean) => boolean;
                remove: () => void;
                insertChild: (child?: FakeNode | Node_2, index?: number, batch?: boolean) => void;
                insertBefore: (child: FakeNode | Node_2, ref: Node_2) => void;
                insertAfter: (child: FakeNode | Node_2, ref: Node_2) => void;
                removeChild: (child: Node_2) => void;
                removeChildByData: (data: TreeNodeData | null) => void;
                expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
                doCreateChildren: (array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps) => void;
                collapse: () => void;
                shouldLoadData: () => boolean;
                updateLeafState: () => void;
                setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
                getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
                updateChildren: () => void;
                loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps) => void;
                eachNode: (callback: (node: Node_2) => void) => void;
                reInitChecked: () => void;
            };
            $el?: HTMLElement | undefined;
        } | null;
    }>;
    el$: Ref<Nullable<HTMLElement>>;
    dropIndicator$: Ref<Nullable<HTMLElement>>;
    isEmpty: ComputedRef<boolean>;
    filter: (value: FilterValue) => void;
    getNodeKey: (node: Node_2) => any;
    getNodePath: (data: TreeKey | TreeNodeData) => TreeNodeData[];
    getCheckedNodes: (leafOnly?: boolean, includeHalfChecked?: boolean) => TreeNodeData[];
    getCheckedKeys: (leafOnly?: boolean) => TreeKey[];
    getCurrentNode: () => TreeNodeData | null;
    getCurrentKey: () => TreeKey | null;
    setCheckedNodes: (nodes: Node_2[], leafOnly?: boolean) => void;
    setCheckedKeys: (keys: TreeKey[], leafOnly?: boolean) => void;
    setChecked: (data: TreeKey | TreeNodeData, checked: boolean, deep: boolean) => void;
    getHalfCheckedNodes: () => TreeNodeData[];
    getHalfCheckedKeys: () => TreeKey[];
    setCurrentNode: (node: Node_2, shouldAutoExpandParent?: boolean) => void;
    setCurrentKey: (key?: TreeKey, shouldAutoExpandParent?: boolean) => void;
    t: Translator;
    getNode: (data: TreeKey | TreeNodeData) => Node_2;
    remove: (data: TreeNodeData | Node_2) => void;
    append: (data: TreeNodeData, parentNode: TreeNodeData | TreeKey | Node_2) => void;
    insertBefore: (data: TreeNodeData, refNode: TreeKey | TreeNodeData | Node_2) => void;
    insertAfter: (data: TreeNodeData, refNode: TreeKey | TreeNodeData | Node_2) => void;
    handleNodeExpand: (nodeData: TreeNodeData, node: Node_2, instance: ComponentInternalInstance) => void;
    updateKeyChildren: (key: TreeKey, data: TreeData) => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, string[], string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    data: {
        type: PropType<TreeData>;
        default: () => never[];
    };
    emptyText: {
        type: StringConstructor;
    };
    renderAfterExpand: {
        type: BooleanConstructor;
        default: boolean;
    };
    nodeKey: StringConstructor;
    checkStrictly: BooleanConstructor;
    defaultExpandAll: BooleanConstructor;
    expandOnClickNode: {
        type: BooleanConstructor;
        default: boolean;
    };
    checkOnClickNode: BooleanConstructor;
    checkOnClickLeaf: {
        type: BooleanConstructor;
        default: boolean;
    };
    checkDescendants: BooleanConstructor;
    autoExpandParent: {
        type: BooleanConstructor;
        default: boolean;
    };
    defaultCheckedKeys: PropType<TreeComponentProps["defaultCheckedKeys"]>;
    defaultExpandedKeys: PropType<TreeComponentProps["defaultExpandedKeys"]>;
    currentNodeKey: PropType<string | number>;
    renderContent: {
        type: PropType<RenderContentFunction>;
    };
    showCheckbox: BooleanConstructor;
    draggable: BooleanConstructor;
    allowDrag: {
        type: PropType<AllowDragFunction>;
    };
    allowDrop: {
        type: PropType<AllowDropFunction>;
    };
    props: {
        type: PropType<TreeComponentProps["props"]>;
        default: () => {
            children: string;
            label: string;
            disabled: string;
        };
    };
    lazy: BooleanConstructor;
    highlightCurrent: BooleanConstructor;
    load: PropType<TreeComponentProps["load"]>;
    filterNodeMethod: PropType<TreeComponentProps["filterNodeMethod"]>;
    accordion: BooleanConstructor;
    indent: {
        type: NumberConstructor;
        default: number;
    };
    icon: {
        type: PropType<string | Component>;
    };
}>> & {
    [x: `on${Capitalize<string>}`]: ((...args: any[]) => any) | undefined;
}, {
    data: TreeData;
    props: TreeOptionProps;
    draggable: boolean;
    checkStrictly: boolean;
    lazy: boolean;
    checkOnClickNode: boolean;
    checkOnClickLeaf: boolean;
    accordion: boolean;
    defaultExpandAll: boolean;
    indent: number;
    autoExpandParent: boolean;
    checkDescendants: boolean;
    renderAfterExpand: boolean;
    showCheckbox: boolean;
    expandOnClickNode: boolean;
    highlightCurrent: boolean;
}>;
declare const _default_97: DefineComponent<any, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<any>, {} | {
    [x: string]: any;
}>;
declare const _default_98: __VLS_WithTemplateSlots_76<typeof __VLS_component_76, ReturnType<typeof __VLS_template_76>>;
declare const _default_99: __VLS_WithTemplateSlots_77<typeof __VLS_component_77, ReturnType<typeof __VLS_template_77>>;
export declare const DEFAULT_DIALOG_TRANSITION = "dialog-fade";
export declare const DEFAULT_EMPTY_VALUES: (string | null | undefined)[];
export declare const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
export declare const DEFAULT_FORMATS_DATEPICKER: {
    date: string;
    dates: string;
    week: string;
    year: string;
    years: string;
    month: string;
    months: string;
    datetime: string;
    monthrange: string;
    yearrange: string;
    daterange: string;
    datetimerange: string;
};
export declare const DEFAULT_FORMATS_TIME = "HH:mm:ss";
export declare const DEFAULT_VALUE_ON_CLEAR: undefined;
export declare const defaultInitialZIndex = 2000;
export declare const defaultNamespace = "el";
export declare const DefaultProps: CascaderConfig_2;
export declare const defaultProps: Required<Props>;
declare type DefaultRow = Record<PropertyKey, any>;
declare type DeprecationParam = {
    from: string;
    replacement: string;
    scope: string;
    version: string;
    ref: string;
    type?: "API" | "Attribute" | "Event" | "Slot";
};
export declare type DescriptionInstance = InstanceType<typeof _default_42> & unknown;
declare const DescriptionItem: DefineComponent<{
    label: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    span: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    rowspan: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    width: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    minWidth: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    labelWidth: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    align: EpPropFinalized<StringConstructor, "center" | "left" | "right", unknown, string, boolean>;
    labelAlign: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "center" | "left" | "right", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    className: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    labelClassName: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
}, unknown, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    label: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    span: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    rowspan: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    width: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    minWidth: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    labelWidth: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    align: EpPropFinalized<StringConstructor, "center" | "left" | "right", unknown, string, boolean>;
    labelAlign: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "center" | "left" | "right", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    className: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    labelClassName: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
}>>, {
    label: string;
    span: number;
    width: EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>;
    minWidth: EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>;
    className: string;
    labelWidth: EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>;
    align: EpPropMergeType<StringConstructor, "center" | "left" | "right", unknown>;
    rowspan: number;
    labelClassName: string;
}>;
export declare type DescriptionItemProps = ExtractPropTypes<typeof descriptionItemProps>;
export declare const descriptionItemProps: {
    label: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    span: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    rowspan: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    width: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    minWidth: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    labelWidth: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, string, boolean>;
    align: EpPropFinalized<StringConstructor, "center" | "left" | "right", unknown, string, boolean>;
    labelAlign: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "center" | "left" | "right", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    className: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    labelClassName: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
};
export declare type DescriptionItemPropsPublic = __ExtractPublicPropTypes<typeof descriptionItemProps>;
export declare type DescriptionItemVNode = VNode & {
    children: {
        [name: string]: Slot;
    } | null;
    props: Partial<DescriptionItemProps> | null;
};
export declare type DescriptionProps = ExtractPropTypes<typeof descriptionProps>;
export declare const descriptionProps: {
    readonly border: BooleanConstructor;
    readonly column: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly extra: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
};
export declare type DescriptionPropsPublic = __ExtractPublicPropTypes<typeof descriptionProps>;
export declare type DialogBeforeCloseFn = (done: DoneFn) => void;
export declare interface DialogConfigContext {
    alignCenter?: boolean;
    draggable?: boolean;
    overflow?: boolean;
    transition?: DialogTransition;
}
export declare type DialogContext = {
    dialogRef: Ref<HTMLElement | undefined>;
    headerRef: Ref<HTMLElement | undefined>;
    bodyId: Ref<string>;
    ns: UseNamespaceReturn;
    rendered: Ref<boolean>;
    style: ComputedRef<CSSProperties>;
};
export declare const dialogContextKey: InjectionKey<DialogConfigContext>;
export declare type DialogEmits = typeof dialogEmits;
export declare const dialogEmits: {
    open: () => boolean;
    opened: () => boolean;
    close: () => boolean;
    closed: () => boolean;
    "update:modelValue": (value: boolean) => boolean;
    openAutoFocus: () => boolean;
    closeAutoFocus: () => boolean;
};
export declare const dialogInjectionKey: InjectionKey<DialogContext>;
export declare type DialogInstance = InstanceType<typeof _default_43> & unknown;
export declare type DialogProps = ExtractPropTypes<typeof dialogProps>;
export declare const dialogProps: {
    readonly appendToBody: BooleanConstructor;
    readonly appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, "body", boolean>;
    readonly beforeClose: {
        readonly type: PropType<DialogBeforeCloseFn>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly destroyOnClose: BooleanConstructor;
    readonly closeOnClickModal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly lockScroll: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalPenetrable: BooleanConstructor;
    readonly openDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly closeDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly top: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: BooleanConstructor;
    readonly modalClass: StringConstructor;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly trapFocus: BooleanConstructor;
    readonly headerAriaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
    readonly transition: EpPropFinalized<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown, undefined, boolean>;
    readonly center: BooleanConstructor;
    readonly alignCenter: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly draggable: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly overflow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly fullscreen: BooleanConstructor;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly ariaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
};
export declare type DialogPropsPublic = __ExtractPublicPropTypes<typeof dialogProps>;
export declare type DialogTransition = string | TransitionProps;
declare type Dir = typeof FORWARD | typeof BACKWARD;
export declare type Direction = "ltr" | "rtl";
export declare type DividerInstance = InstanceType<typeof _default_44> & unknown;
export declare type DividerProps = ExtractPropTypes<typeof dividerProps>;
export declare const dividerProps: {
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly contentPosition: EpPropFinalized<StringConstructor, "center" | "left" | "right", unknown, "center", boolean>;
    readonly borderStyle: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "solid", boolean>;
};
export declare type DividerPropsPublic = __ExtractPublicPropTypes<typeof dividerProps>;
declare type DoneFn = (cancel?: boolean) => void;
export declare const drawerEmits: {
    open: () => boolean;
    opened: () => boolean;
    close: () => boolean;
    closed: () => boolean;
    "update:modelValue": (value: boolean) => boolean;
    openAutoFocus: () => boolean;
    closeAutoFocus: () => boolean;
};
export declare type DrawerProps = ExtractPropTypes<typeof drawerProps>;
export declare const drawerProps: {
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl" | "ttb" | "btt", unknown, "rtl", boolean>;
    readonly resizable: BooleanConstructor;
    readonly size: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "30%", boolean>;
    readonly withHeader: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalFade: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly headerAriaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
    readonly appendToBody: BooleanConstructor;
    readonly appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, "body", boolean>;
    readonly beforeClose: {
        readonly type: PropType<DialogBeforeCloseFn>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly destroyOnClose: BooleanConstructor;
    readonly closeOnClickModal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly lockScroll: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modal: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly modalPenetrable: BooleanConstructor;
    readonly openDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly closeDelay: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly top: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: BooleanConstructor;
    readonly modalClass: StringConstructor;
    readonly headerClass: StringConstructor;
    readonly bodyClass: StringConstructor;
    readonly footerClass: StringConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly trapFocus: BooleanConstructor;
    readonly transition: EpPropFinalized<(new (...args: any[]) => string | TransitionProps) | (() => DialogTransition) | ((new (...args: any[]) => string | TransitionProps) | (() => DialogTransition))[], unknown, unknown, undefined, boolean>;
    readonly center: BooleanConstructor;
    readonly alignCenter: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly draggable: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly overflow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly fullscreen: BooleanConstructor;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly ariaLevel: EpPropFinalized<StringConstructor, unknown, unknown, "2", boolean>;
};
export declare type DrawerPropsPublic = __ExtractPublicPropTypes<typeof drawerProps>;
export declare const DROPDOWN_COLLECTION_INJECTION_KEY: InjectionKey<ElCollectionInjectionContext>;
export declare const DROPDOWN_COLLECTION_ITEM_INJECTION_KEY: InjectionKey<ElCollectionItemInjectionContext>;
export declare const DROPDOWN_INJECTION_KEY: InjectionKey<ElDropdownInjectionContext>;
export declare const DROPDOWN_INSTANCE_INJECTION_KEY = "elDropdown";
export declare type DropdownInstance = InstanceType<typeof _default_46> & unknown;
export declare const dropdownItemProps: {
    readonly command: EpPropFinalized<readonly [
        ObjectConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, () => {}, boolean>;
    readonly disabled: BooleanConstructor;
    readonly divided: BooleanConstructor;
    readonly textValue: StringConstructor;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare const dropdownMenuProps: {
    onKeydown: {
        readonly type: PropType<(e: KeyboardEvent) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare const dropdownProps: {
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly effect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger") | (() => EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>) | ((new (...args: any[]) => "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger") | (() => EpPropMergeType<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly id: StringConstructor;
    readonly size: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly splitButton: BooleanConstructor;
    readonly hideOnClick: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly loop: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 150, boolean>;
    readonly hideTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 150, boolean>;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly maxHeight: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, "", boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly disabled: BooleanConstructor;
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "menu", boolean>;
    readonly buttonProps: {
        readonly type: PropType<Partial<ButtonProps>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare const DynamicSizeGrid: DefineComponent<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("scroll" | "itemRendered")[], "scroll" | "itemRendered", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
}>> & {
    onScroll?: ((...args: any[]) => any) | undefined;
    onItemRendered?: ((...args: any[]) => any) | undefined;
}, {
    readonly data: any[];
    readonly direction: EpPropMergeType<StringConstructor, "ltr" | "rtl", never>;
    readonly className: string;
    readonly containerElement: EpPropMergeType<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown>;
    readonly innerElement: EpPropMergeType<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown>;
    readonly perfMode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly itemKey: GridItemKeyGetter;
    readonly columnCache: number;
    readonly initScrollLeft: number;
    readonly initScrollTop: number;
    readonly rowCache: number;
    readonly hScrollbarSize: number;
    readonly vScrollbarSize: number;
    readonly scrollbarStartGap: number;
    readonly scrollbarEndGap: number;
}>;
export declare type DynamicSizeGridInstance = GridInstance & {
    resetAfterColumnIndex: ResetAfterIndex;
    resetAfterRowIndex: ResetAfterIndex;
    resetAfter: ResetAfterIndices;
};
export declare const DynamicSizeList: DefineComponent<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedItemSize: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", never, "vertical", false>;
    readonly initScrollOffset: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly total: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly itemSize: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    clientSize: ComputedRef<string | number | undefined>;
    estimatedTotalSize: ComputedRef<number>;
    windowStyle: ComputedRef<(string | CSSProperties | StyleValue[] | {
        [x: string]: string;
        position: string;
        WebkitOverflowScrolling: string;
        willChange: string;
    } | undefined)[]>;
    windowRef: Ref<HTMLElement | undefined>;
    innerRef: Ref<HTMLElement | undefined>;
    innerStyle: ComputedRef<{
        height: string;
        pointerEvents: string | undefined;
        width: string;
    }>;
    itemsToRender: ComputedRef<number[]>;
    scrollbarRef: Ref<any>;
    states: Ref<{
        isScrolling: boolean;
        scrollDir: string;
        scrollOffset: number;
        updateRequested: boolean;
        isScrollbarDragging: boolean;
        scrollbarAlwaysOn: boolean;
    }>;
    getItemStyle: (idx: number) => CSSProperties;
    onScroll: (e: Event) => void;
    onScrollbarScroll: (distanceToGo: number, totalSteps: number) => void;
    onWheel: (e: WheelEvent) => void;
    scrollTo: (offset: number) => void;
    scrollToItem: (idx: number, alignment?: Alignment) => void;
    resetScrollTop: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("scroll" | "itemRendered")[], "scroll" | "itemRendered", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedItemSize: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", never, "vertical", false>;
    readonly initScrollOffset: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly total: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly itemSize: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onScroll?: ((...args: any[]) => any) | undefined;
    onItemRendered?: ((...args: any[]) => any) | undefined;
}, {
    readonly data: any[];
    readonly direction: EpPropMergeType<StringConstructor, "ltr" | "rtl", never>;
    readonly layout: EpPropMergeType<StringConstructor, "horizontal" | "vertical", never>;
    readonly className: string;
    readonly containerElement: EpPropMergeType<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown>;
    readonly innerElement: EpPropMergeType<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown>;
    readonly perfMode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly cache: number;
    readonly initScrollOffset: number;
}>;
export declare type DynamicSizeListInstance = InstanceType<typeof DynamicSizeList> & unknown;
export declare const Effect: {
    readonly LIGHT: "light";
    readonly DARK: "dark";
};
declare const effects: readonly [
    "light",
    "dark"
];
export declare const ElAffix: SFCWithInstall<typeof _default_2>;
export declare const ElAlert: SFCWithInstall<typeof _default_3>;
export declare const ElAnchor: SFCWithInstall<typeof _default_106> & {
    AnchorLink: typeof _default_107;
};
export declare const ElAnchorLink: SFCWithInstall<typeof _default_107>;
export declare const ElAside: SFCWithInstall<typeof _default_35>;
export declare const ElAutocomplete: SFCWithInstall<typeof _default_4>;
export declare const ElAutoResizer: SFCWithInstall<typeof AutoResizer>;
export declare const ElAvatar: SFCWithInstall<typeof _default_9>;
export declare const ElBacktop: SFCWithInstall<typeof _default_10>;
export declare const ElBadge: SFCWithInstall<typeof _default_11>;
export declare const ElBreadcrumb: SFCWithInstall<typeof _default_12> & {
    BreadcrumbItem: typeof _default_13;
};
export declare const ElBreadcrumbItem: SFCWithInstall<typeof _default_13>;
export declare const ElButton: SFCWithInstall<typeof _default_14> & {
    ButtonGroup: typeof _default_15;
};
export declare const ElButtonGroup: SFCWithInstall<typeof _default_15>;
export declare const ElCalendar: SFCWithInstall<typeof _default_16>;
export declare const ElCard: SFCWithInstall<typeof _default_18>;
export declare const ElCarousel: SFCWithInstall<typeof _default_19> & {
    CarouselItem: typeof _default_20;
};
export declare const ElCarouselItem: SFCWithInstall<typeof _default_20>;
export declare const ElCascader: SFCWithInstall<typeof _default_21>;
export declare const ElCascaderPanel: SFCWithInstall<typeof _default_22>;
export declare interface ElCascaderPanelContext {
    config: CascaderConfig;
    expandingNode: CascaderNode | undefined;
    checkedNodes: CascaderNode[];
    isHoverMenu: boolean;
    initialLoaded: boolean;
    renderLabelFn: RenderLabel;
    lazyLoad: (node?: CascaderNode, cb?: (dataList: CascaderOption[]) => void) => void;
    expandNode: (node: CascaderNode, silent?: boolean) => void;
    handleCheckChange: (node: CascaderNode, checked: boolean, emitClose?: boolean) => void;
}
export declare const ElCheckbox: SFCWithInstall<typeof _default_25> & {
    CheckboxButton: typeof _default_26;
    CheckboxGroup: typeof _default_27;
};
export declare const ElCheckboxButton: SFCWithInstall<typeof _default_26>;
export declare const ElCheckboxGroup: SFCWithInstall<typeof _default_27>;
export declare const ElCheckTag: SFCWithInstall<typeof _default_24>;
export declare const ElCol: SFCWithInstall<typeof _default_28>;
export declare const ElCollapse: SFCWithInstall<typeof _default_29> & {
    CollapseItem: typeof _default_30;
};
export declare const ElCollapseItem: SFCWithInstall<typeof _default_30>;
export declare const ElCollapseTransition: SFCWithInstall<typeof _default_31>;
export declare const ElCollection: {
    name: string;
    setup(): void;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
    template?: string | object;
    render?: Function;
    components?: Record<string, Component>;
    directives?: Record<string, Directive>;
    inheritAttrs?: boolean;
    emits?: (EmitsOptions & ThisType<void>) | undefined;
    expose?: string[];
    serverPrefetch?(): Promise<any>;
    compilerOptions?: RuntimeCompilerOptions;
    call?: (this: unknown, ...args: unknown[]) => never;
    __defaults?: {} | undefined;
    compatConfig?: Partial<Record<DeprecationTypes, boolean | "suppress-warning">> & {
        MODE?: 2 | 3 | ((comp: Component | null) => 2 | 3);
    };
    data?: ((this: CreateComponentPublicInstance<Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, ComponentOptionsMixin, ComponentOptionsMixin, {}, Readonly<ExtractPropTypes<{}>>, {}, false, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, {}>, vm: CreateComponentPublicInstance<Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, ComponentOptionsMixin, ComponentOptionsMixin, {}, Readonly<ExtractPropTypes<{}>>, {}, false, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, {}>) => {}) | undefined;
    computed?: {} | undefined;
    methods?: {} | undefined;
    watch?: {
        [x: string]: (string | WatchCallback<any, any> | ({
            handler: WatchCallback | string;
        } & WatchOptions<boolean>)) | (string | WatchCallback<any, any> | ({
            handler: WatchCallback | string;
        } & WatchOptions<boolean>))[];
    };
    provide?: ComponentProvideOptions;
    inject?: string[] | {
        [x: string]: string | symbol | {
            from?: string | symbol;
            default?: unknown;
        };
        [x: symbol]: string | symbol | {
            from?: string | symbol;
            default?: unknown;
        };
    };
    filters?: Record<string, Function>;
    mixins?: ComponentOptionsMixin[] | undefined;
    extends?: ComponentOptionsMixin | undefined;
    beforeCreate?(): void;
    created?(): void;
    beforeMount?(): void;
    mounted?(): void;
    beforeUpdate?(): void;
    updated?(): void;
    activated?(): void;
    deactivated?(): void;
    beforeDestroy?(): void;
    beforeUnmount?(): void;
    destroyed?(): void;
    unmounted?(): void;
    renderTracked?: (e: DebuggerEvent) => void;
    renderTriggered?: (e: DebuggerEvent) => void;
    errorCaptured?: (err: unknown, instance: ComponentPublicInstance | null, info: string) => boolean | void;
    delimiters?: [
        string,
        string
    ];
    __differentiator?: undefined;
    __isBuiltIn?: boolean;
    __file?: string;
    __name?: string;
    beforeRouteEnter?: NavigationGuardWithThis<undefined>;
    beforeRouteUpdate?: NavigationGuard;
    beforeRouteLeave?: NavigationGuard;
    key?: string | number | symbol;
    ref?: VNodeRef;
    ref_for?: boolean;
    ref_key?: string;
    onVnodeBeforeMount?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    onVnodeMounted?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    onVnodeBeforeUpdate?: ((vnode: VNode, oldVNode: VNode) => void) | ((vnode: VNode, oldVNode: VNode) => void)[];
    onVnodeUpdated?: ((vnode: VNode, oldVNode: VNode) => void) | ((vnode: VNode, oldVNode: VNode) => void)[];
    onVnodeBeforeUnmount?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    onVnodeUnmounted?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    class?: unknown;
    style?: unknown;
};
declare type ElCollectionInjectionContext = {
    itemMap: Map<HTMLElement, CollectionItem>;
    getItems: <T>() => CollectionItem<T>[];
    collectionRef: Ref<HTMLElement | undefined>;
};
export declare const ElCollectionItem: {
    name: string;
    setup(_: unknown, { attrs }: SetupContext): void;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
    template?: string | object;
    render?: Function;
    components?: Record<string, Component>;
    directives?: Record<string, Directive>;
    inheritAttrs?: boolean;
    emits?: (EmitsOptions & ThisType<void>) | undefined;
    expose?: string[];
    serverPrefetch?(): Promise<any>;
    compilerOptions?: RuntimeCompilerOptions;
    call?: (this: unknown, ...args: unknown[]) => never;
    __defaults?: {} | undefined;
    compatConfig?: Partial<Record<DeprecationTypes, boolean | "suppress-warning">> & {
        MODE?: 2 | 3 | ((comp: Component | null) => 2 | 3);
    };
    data?: ((this: CreateComponentPublicInstance<Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, ComponentOptionsMixin, ComponentOptionsMixin, {}, Readonly<ExtractPropTypes<{}>>, {}, false, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, {}>, vm: CreateComponentPublicInstance<Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, ComponentOptionsMixin, ComponentOptionsMixin, {}, Readonly<ExtractPropTypes<{}>>, {}, false, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, MethodOptions, {}>) => {}) | undefined;
    computed?: {} | undefined;
    methods?: {} | undefined;
    watch?: {
        [x: string]: (string | WatchCallback<any, any> | ({
            handler: WatchCallback | string;
        } & WatchOptions<boolean>)) | (string | WatchCallback<any, any> | ({
            handler: WatchCallback | string;
        } & WatchOptions<boolean>))[];
    };
    provide?: ComponentProvideOptions;
    inject?: string[] | {
        [x: string]: string | symbol | {
            from?: string | symbol;
            default?: unknown;
        };
        [x: symbol]: string | symbol | {
            from?: string | symbol;
            default?: unknown;
        };
    };
    filters?: Record<string, Function>;
    mixins?: ComponentOptionsMixin[] | undefined;
    extends?: ComponentOptionsMixin | undefined;
    beforeCreate?(): void;
    created?(): void;
    beforeMount?(): void;
    mounted?(): void;
    beforeUpdate?(): void;
    updated?(): void;
    activated?(): void;
    deactivated?(): void;
    beforeDestroy?(): void;
    beforeUnmount?(): void;
    destroyed?(): void;
    unmounted?(): void;
    renderTracked?: (e: DebuggerEvent) => void;
    renderTriggered?: (e: DebuggerEvent) => void;
    errorCaptured?: (err: unknown, instance: ComponentPublicInstance | null, info: string) => boolean | void;
    delimiters?: [
        string,
        string
    ];
    __differentiator?: undefined;
    __isBuiltIn?: boolean;
    __file?: string;
    __name?: string;
    beforeRouteEnter?: NavigationGuardWithThis<undefined>;
    beforeRouteUpdate?: NavigationGuard;
    beforeRouteLeave?: NavigationGuard;
    key?: string | number | symbol;
    ref?: VNodeRef;
    ref_for?: boolean;
    ref_key?: string;
    onVnodeBeforeMount?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    onVnodeMounted?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    onVnodeBeforeUpdate?: ((vnode: VNode, oldVNode: VNode) => void) | ((vnode: VNode, oldVNode: VNode) => void)[];
    onVnodeUpdated?: ((vnode: VNode, oldVNode: VNode) => void) | ((vnode: VNode, oldVNode: VNode) => void)[];
    onVnodeBeforeUnmount?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    onVnodeUnmounted?: ((vnode: VNode) => void) | ((vnode: VNode) => void)[];
    class?: unknown;
    style?: unknown;
};
declare type ElCollectionItemInjectionContext = {
    collectionItemRef: Ref<HTMLElement | undefined>;
};
export declare const ElColorPicker: SFCWithInstall<typeof _default_33>;
export declare const ElColorPickerPanel: SFCWithInstall<typeof _default_32>;
export declare const ElConfigProvider: SFCWithInstall<typeof ConfigProvider>;
export declare const ElContainer: SFCWithInstall<typeof _default_34> & {
    Aside: typeof _default_35;
    Footer: typeof _default_36;
    Header: typeof _default_37;
    Main: typeof _default_38;
};
export declare const ElCountdown: SFCWithInstall<typeof _default_39>;
export declare const ElDatePicker: SFCWithInstall<typeof _default_40>;
export declare const ElDatePickerPanel: SFCWithInstall<typeof _default_41>;
export declare const ElDescriptions: SFCWithInstall<typeof _default_42> & {
    DescriptionsItem: typeof DescriptionItem;
};
export declare const ElDescriptionsItem: SFCWithInstall<typeof DescriptionItem>;
export declare const ElDialog: SFCWithInstall<typeof _default_43>;
export declare const ElDivider: SFCWithInstall<typeof _default_44>;
export declare const ElDrawer: SFCWithInstall<typeof _default_45>;
export declare const ElDropdown: SFCWithInstall<typeof _default_46> & {
    DropdownItem: typeof _default_47;
    DropdownMenu: typeof _default_48;
};
export declare type ElDropdownInjectionContext = {
    contentRef: Ref<HTMLElement | undefined>;
    role: ComputedRef<PopperProps["role"]>;
    triggerId: ComputedRef<string>;
    isUsingKeyboard: Ref<boolean>;
    onItemLeave: (e: PointerEvent) => void;
    onItemEnter: (e: PointerEvent) => void;
};
export declare const ElDropdownItem: SFCWithInstall<typeof _default_47>;
export declare const ElDropdownMenu: SFCWithInstall<typeof _default_48>;
declare interface ElementLoading extends HTMLElement {
    [INSTANCE_KEY]?: {
        instance: LoadingInstance;
        options: LoadingOptions;
    };
}
declare type ElementType = HTMLElement | undefined;
export declare const ElEmpty: SFCWithInstall<typeof _default_49>;
export declare const ElFooter: SFCWithInstall<typeof _default_36>;
export declare const ElForm: SFCWithInstall<typeof _default_50> & {
    FormItem: typeof _default_51;
};
export declare const ElFormItem: SFCWithInstall<typeof _default_51>;
export declare const ElHeader: SFCWithInstall<typeof _default_37>;
export declare const ElIcon: SFCWithInstall<typeof _default_52>;
export declare type ElIdInjectionContext = {
    prefix: number;
    current: number;
};
export declare const ElImage: SFCWithInstall<typeof _default_53>;
export declare const ElImageViewer: SFCWithInstall<typeof _default_54>;
export declare const ElInfiniteScroll: SFCWithInstall<ObjectDirective<HTMLElement & {
    ElInfiniteScroll: {
        container: HTMLElement | Window;
        containerEl: HTMLElement;
        instance: ComponentPublicInstance;
        delay: number;
        lastScrollTop: number;
        cb: () => void;
        onScroll: () => void;
        observer?: MutationObserver;
    };
}, () => void>>;
export declare const ElInput: SFCWithInstall<typeof _default_5>;
export declare const ElInputNumber: SFCWithInstall<typeof _default_55>;
export declare const ElInputTag: SFCWithInstall<typeof _default_56>;
export declare const ElLink: SFCWithInstall<typeof _default_57>;
export declare const ElLoading: {
    install(app: App): void;
    directive: Directive<ElementLoading, LoadingBinding>;
    service: {
        (options?: LoadingOptions): LoadingInstance;
        _context: AppContext | null;
    };
};
export declare const ElLoadingService: {
    (options?: LoadingOptions): LoadingInstance;
    _context: AppContext | null;
};
export declare const ElMain: SFCWithInstall<typeof _default_38>;
export declare const ElMention: SFCWithInstall<typeof _default_109>;
export declare const ElMenu: SFCWithInstall<typeof _default_58> & {
    MenuItem: typeof _default_59;
    MenuItemGroup: typeof _default_60;
    SubMenu: typeof _default_61;
};
export declare const ElMenuItem: SFCWithInstall<typeof _default_59>;
export declare const ElMenuItemGroup: SFCWithInstall<typeof _default_60>;
export declare const ElMessage: SFCInstallWithContext<Message>;
export declare const ElMessageBox: SFCWithInstall<IElMessageBox>;
/** Options used in MessageBox */
export declare interface ElMessageBoxOptions {
    /**
     * auto focus when open message-box
     */
    autofocus?: boolean;
    /** Callback before MessageBox closes, and it will prevent MessageBox from closing */
    beforeClose?: (action: Action, instance: MessageBoxState, done: () => void) => void;
    /** Custom class name for MessageBox */
    customClass?: string;
    /** Custom inline style for MessageBox */
    customStyle?: CSSProperties;
    /** modal class name for MessageBox */
    modalClass?: string;
    /** MessageBox closing callback if you don't prefer Promise */
    callback?: Callback;
    /** Text content of cancel button */
    cancelButtonText?: string;
    /** Text content of confirm button */
    confirmButtonText?: string;
    /** Loading Icon content of cancel button */
    cancelButtonLoadingIcon?: string | Component;
    /** Loading Icon content of confirm button */
    confirmButtonLoadingIcon?: string | Component;
    /** Custom class name of cancel button */
    cancelButtonClass?: string;
    /** Custom class name of confirm button */
    confirmButtonClass?: string;
    /** Whether to align the content in center */
    center?: boolean;
    /** Whether MessageBox can be drag */
    draggable?: boolean;
    /** Draggable MessageBox can overflow the viewport */
    overflow?: boolean;
    /** Content of the MessageBox */
    message?: string | VNode | (() => VNode);
    /** Title of the MessageBox */
    title?: string | ElMessageBoxOptions;
    /** Message type, used for icon display */
    type?: MessageType_2;
    /** Message box type */
    boxType?: MessageBoxType;
    /** Custom icon component */
    icon?: string | Component;
    /** Custom close icon component */
    closeIcon?: string | Component;
    /** Whether message is treated as HTML string */
    dangerouslyUseHTMLString?: boolean;
    /** Whether to distinguish canceling and closing */
    distinguishCancelAndClose?: boolean;
    /** Whether to lock body scroll when MessageBox prompts */
    lockScroll?: boolean;
    /** Whether to show a cancel button */
    showCancelButton?: boolean;
    /** Whether to show a confirm button */
    showConfirmButton?: boolean;
    /** Whether to show a close button */
    showClose?: boolean;
    /** Whether to use round button */
    roundButton?: boolean;
    /** Whether MessageBox can be closed by clicking the mask */
    closeOnClickModal?: boolean;
    /** Whether MessageBox can be closed by pressing the ESC */
    closeOnPressEscape?: boolean;
    /** Whether to close MessageBox when hash changes */
    closeOnHashChange?: boolean;
    /** Whether to show an input */
    showInput?: boolean;
    /** Placeholder of input */
    inputPlaceholder?: string;
    /** Initial value of input */
    inputValue?: string;
    /** Regexp for the input */
    inputPattern?: RegExp;
    /** Input Type: text, textArea, password or number */
    inputType?: string;
    /** Validation function for the input. Should returns a boolean or string. If a string is returned, it will be assigned to inputErrorMessage */
    inputValidator?: MessageBoxInputValidator;
    /** Error message when validation fails */
    inputErrorMessage?: string;
    /** Custom size of confirm and cancel buttons */
    buttonSize?: ComponentSize;
    /** Custom element to append the message box to */
    appendTo?: HTMLElement | string;
}
export declare type ElMessageBoxShortcutMethod = ((message: ElMessageBoxOptions["message"], options?: ElMessageBoxOptions, appContext?: AppContext | null) => Promise<MessageBoxData>) & ((message: ElMessageBoxOptions["message"], title: ElMessageBoxOptions["title"], options?: ElMessageBoxOptions, appContext?: AppContext | null) => Promise<MessageBoxData>);
export declare const ElNotification: SFCInstallWithContext<Notify>;
export declare const ElOption: SFCWithInstall<typeof _default_75>;
export declare const ElOptionGroup: SFCWithInstall<typeof _default_76>;
export declare const ElOverlay: DefineComponent<{
    readonly mask: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly customMaskEvent: BooleanConstructor;
    readonly overlayClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[] | Record<string, boolean>) | (() => string | string[] | Record<string, boolean>) | ((new (...args: any[]) => string | string[] | Record<string, boolean>) | (() => string | string[] | Record<string, boolean>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    click: (evt: MouseEvent) => boolean;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly mask: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly customMaskEvent: BooleanConstructor;
    readonly overlayClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[] | Record<string, boolean>) | (() => string | string[] | Record<string, boolean>) | ((new (...args: any[]) => string | string[] | Record<string, boolean>) | (() => string | string[] | Record<string, boolean>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onClick?: ((evt: MouseEvent) => any) | undefined;
}, {
    readonly mask: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly customMaskEvent: boolean;
}>;
export declare const ElPageHeader: SFCWithInstall<typeof _default_62>;
export declare const ElPagination: SFCWithInstall<typeof _default_63>;
export declare interface ElPaginationContext {
    currentPage?: WritableComputedRef<number>;
    pageCount?: ComputedRef<number>;
    disabled?: ComputedRef<boolean>;
    changeEvent?: (val: number) => void;
    handleSizeChange?: (val: number) => void;
}
export declare const elPaginationKey: InjectionKey<ElPaginationContext>;
export declare const ElPopconfirm: SFCWithInstall<typeof _default_64>;
export declare const ElPopover: SFCWithInstall<typeof _default_115> & {
    directive: typeof ElPopoverDirective;
};
export declare const ElPopoverDirective: SFCWithInstall<typeof _default_114>;
export declare const ElPopper: SFCWithInstall<typeof _default_7>;
export declare const ElPopperArrow: DefineComponent<{}, {
    /**
    * @description Arrow element
    */
    arrowRef: Ref<HTMLElement | undefined>;
}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
/** @deprecated use `PopperContentInstance` instead, and it will be deprecated in the next major version */
export declare type ElPopperArrowContent = PopperContentInstance;
/** @deprecated use `PopperArrowInstance` instead, and it will be deprecated in the next major version */
export declare type ElPopperArrowInstance = PopperArrowInstance;
/** @deprecated use `PopperTriggerInstance` instead, and it will be deprecated in the next major version */
export declare type ElPopperArrowTrigger = PopperTriggerInstance;
export declare const ElPopperContent: __VLS_WithTemplateSlots_8<typeof __VLS_component_8, ReturnType<typeof __VLS_template_5>>;
export declare type ElPopperContentInjectionContext = {
    arrowRef: Ref<HTMLElement | undefined>;
    arrowStyle: ComputedRef<CSSProperties>;
};
/**
 * triggerRef indicates the element that triggers popper
 * contentRef indicates the element of popper content
 * referenceRef indicates the element that popper content relative with
 */
export declare type ElPopperInjectionContext = {
    triggerRef: Ref<Measurable | undefined>;
    contentRef: Ref<HTMLElement | undefined>;
    popperInstanceRef: Ref<Instance_2 | undefined>;
    referenceRef: Ref<Measurable | undefined>;
    role: ComputedRef<string>;
};
export declare const ElPopperTrigger: __VLS_WithTemplateSlots_56<typeof __VLS_component_56, ReturnType<typeof __VLS_template_56>>;
export declare const ElProgress: SFCWithInstall<typeof _default_65>;
export declare const ElRadio: SFCWithInstall<typeof _default_66> & {
    RadioButton: typeof _default_67;
    RadioGroup: typeof _default_68;
};
export declare const ElRadioButton: SFCWithInstall<typeof _default_67>;
export declare const ElRadioGroup: SFCWithInstall<typeof _default_68>;
export declare const ElRate: SFCWithInstall<typeof _default_69>;
export declare const ElResult: SFCWithInstall<typeof _default_70>;
export declare const ElRow: SFCWithInstall<typeof _default_71>;
export declare const ElScrollbar: SFCWithInstall<typeof _default_72>;
export declare const ElSegmented: SFCWithInstall<{
    new (...args: any[]): {
        $: ComponentInternalInstance;
        $data: {};
        $props: Partial<{
            disabled: boolean;
            direction: EpPropMergeType<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown>;
            block: boolean;
            props: Props;
            modelValue: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
            options: Option_3[];
            validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        }> & Omit<Readonly<ExtractPropTypes<{
            ariaLabel: StringConstructor;
            direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
            options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
            modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
            block: BooleanConstructor;
            size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            disabled: BooleanConstructor;
            validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
            id: StringConstructor;
            name: StringConstructor;
        }>> & {
            "onUpdate:modelValue"?: ((val: any) => any) | undefined;
            onChange?: ((val: any) => any) | undefined;
        } & VNodeProps & AllowedComponentProps & ComponentCustomProps, "disabled" | "direction" | "block" | "props" | "modelValue" | "options" | "validateEvent">;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Slots;
        $root: ComponentPublicInstance | null;
        $parent: ComponentPublicInstance | null;
        $emit: ((event: "update:modelValue", val: any) => void) & ((event: "change", val: any) => void);
        $el: any;
        $options: ComponentOptionsBase<Readonly<ExtractPropTypes<{
            ariaLabel: StringConstructor;
            direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
            options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
            modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
            block: BooleanConstructor;
            size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            disabled: BooleanConstructor;
            validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
            id: StringConstructor;
            name: StringConstructor;
        }>> & {
            "onUpdate:modelValue"?: ((val: any) => any) | undefined;
            onChange?: ((val: any) => any) | undefined;
        }, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
            "update:modelValue": (val: any) => void;
            change: (val: any) => void;
        }, string, {
            disabled: boolean;
            direction: EpPropMergeType<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown>;
            block: boolean;
            props: Props;
            modelValue: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
            options: Option_3[];
            validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        }> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: DebuggerEvent) => void) | ((e: DebuggerEvent) => void)[];
            renderTriggered?: ((e: DebuggerEvent) => void) | ((e: DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: ComponentPublicInstance | null, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: nextTick;
        $watch(source: string | Function, cb: Function, options?: WatchOptions): WatchStopHandle;
    } & Readonly<ExtractPropTypes<{
        ariaLabel: StringConstructor;
        direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
        options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
        modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
        block: BooleanConstructor;
        size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        disabled: BooleanConstructor;
        validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
        id: StringConstructor;
        name: StringConstructor;
    }>> & {
        "onUpdate:modelValue"?: ((val: any) => any) | undefined;
        onChange?: ((val: any) => any) | undefined;
    } & ShallowUnwrapRef<{}> & {} & ComponentCustomProperties;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & ComponentOptionsBase<Readonly<ExtractPropTypes<{
    ariaLabel: StringConstructor;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
    modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
    block: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    id: StringConstructor;
    name: StringConstructor;
}>> & {
    "onUpdate:modelValue"?: ((val: any) => any) | undefined;
    onChange?: ((val: any) => any) | undefined;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (val: any) => void;
    change: (val: any) => void;
}, string, {
    disabled: boolean;
    direction: EpPropMergeType<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown>;
    block: boolean;
    props: Props;
    modelValue: EpPropMergeType<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>;
    options: Option_3[];
    validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}> & VNodeProps & AllowedComponentProps & ComponentCustomProps & (new () => {
    $slots: {
        default?(_: {
            item: any;
        }): any;
    };
})> & Record<string, any>;
export declare const ElSelect: SFCWithInstall<typeof _default_74> & {
    Option: typeof _default_75;
    OptionGroup: typeof _default_76;
};
export declare const ElSelectV2: SFCWithInstall<typeof _default_77>;
export declare const ElSkeleton: SFCWithInstall<typeof _default_78> & {
    SkeletonItem: typeof _default_79;
};
export declare const ElSkeletonItem: SFCWithInstall<typeof _default_79>;
export declare const ElSlider: SFCWithInstall<typeof _default_80>;
export declare const ElSpace: SFCWithInstall<typeof Space>;
export declare const ElSplitter: SFCWithInstall<typeof _default_110> & {
    SplitPanel: typeof _default_111;
};
export declare const ElSplitterPanel: SFCWithInstall<typeof _default_111>;
export declare const ElStatistic: SFCWithInstall<typeof _default_81>;
export declare const ElStep: SFCWithInstall<typeof _default_83>;
export declare const ElSteps: SFCWithInstall<typeof _default_82> & {
    Step: typeof _default_83;
};
export declare const ElSubMenu: SFCWithInstall<typeof _default_61>;
export declare const ElSwitch: SFCWithInstall<typeof _default_84>;
export declare const ElTable: SFCWithInstall<typeof _default_85> & {
    TableColumn: typeof _default_86;
};
export declare const ElTableColumn: SFCWithInstall<typeof _default_86>;
export declare const ElTableV2: SFCWithInstall<typeof TableV2>;
export declare const ElTabPane: SFCWithInstall<typeof _default_87>;
export declare const ElTabs: SFCWithInstall<typeof Tabs> & {
    TabPane: typeof _default_87;
};
export declare const ElTag: SFCWithInstall<typeof _default_89>;
export declare const ElText: SFCWithInstall<typeof _default_90>;
export declare const ElTimeline: SFCWithInstall<typeof Timeline> & {
    TimelineItem: typeof _default_93;
};
export declare const ElTimelineItem: SFCWithInstall<typeof _default_93>;
export declare const ElTimePicker: SFCWithInstall<typeof _default_91>;
export declare const ElTimeSelect: SFCWithInstall<typeof _default_92>;
export declare const ElTooltip: SFCWithInstall<typeof _default_6>;
export declare type ElTooltipContentProps = ExtractPropTypes<typeof useTooltipContentProps>;
export declare type ElTooltipContentPropsPublic = __ExtractPublicPropTypes<typeof useTooltipContentProps>;
export declare type ElTooltipInjectionContext = {
    controlled: Ref<boolean>;
    id: Ref<string>;
    open: Ref<boolean>;
    trigger: Ref<Arrayable<TooltipTriggerType>>;
    onOpen: (e?: Event) => void;
    onClose: (e?: Event) => void;
    onToggle: (e: Event) => void;
    onShow: () => void;
    onHide: () => void;
    onBeforeShow: () => void;
    onBeforeHide: () => void;
    updatePopper: () => void;
};
export declare type ElTooltipProps = ExtractPropTypes<typeof useTooltipProps>;
export declare type ElTooltipPropsPublic = __ExtractPublicPropTypes<typeof useTooltipProps>;
export declare type ElTooltipTriggerProps = ExtractPropTypes<typeof useTooltipTriggerProps>;
export declare type ElTooltipTriggerPropsPublic = __ExtractPublicPropTypes<typeof useTooltipTriggerProps>;
export declare const ElTour: SFCWithInstall<typeof _default_104> & {
    TourStep: typeof _default_105;
};
export declare const ElTourStep: SFCWithInstall<typeof _default_105>;
export declare const ElTransfer: SFCWithInstall<typeof _default_94>;
export declare const ElTree: SFCWithInstall<typeof _default_96>;
export declare const ElTreeSelect: SFCWithInstall<typeof _default_97>;
export declare const ElTreeV2: SFCWithInstall<typeof _default_98>;
export declare const ElUpload: SFCWithInstall<typeof _default_99>;
export declare const ElWatermark: SFCWithInstall<typeof _default_103>;
export declare interface ElZIndexInjectionContext {
    current: number;
}
export declare const emitChangeFn: (value: CollapseModelValue) => value is string | number | CollapseActiveName[];
declare type EmitFn<E extends EmitsOptions> = SetupContext<E>["emit"];
export declare type EmptyInstance = InstanceType<typeof _default_49> & unknown;
export declare type EmptyProps = ExtractPropTypes<typeof emptyProps>;
export declare const emptyProps: {
    readonly image: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly imageSize: NumberConstructor;
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
};
export declare type EmptyPropsPublic = __ExtractPublicPropTypes<typeof emptyProps>;
declare type EmptyValuesContext = ExtractPropTypes<typeof useEmptyValuesProps>;
export declare const emptyValuesContextKey: InjectionKey<Ref<EmptyValuesContext>>;
/**
 * output prop `buildProp` or `buildProps`.
 *
 * prop 
 *
 * @example
 * EpProp<'a', 'b', true>
 * 
 * {
 readonly type: PropType<"a">;
 readonly required: true;
 readonly validator: ((val: unknown) => boolean) | undefined;
 readonly default: "b";
 __epPropKey: true;
 }
 */
declare type EpProp<Type, Default, Required> = {
    readonly type: PropType<Type>;
    readonly required: [
        Required
    ] extends [
        true
    ] ? true : false;
    readonly validator: ((val: unknown) => boolean) | undefined;
    [epPropKey]: true;
} & IfNever<Default, unknown, {
    readonly default: Default;
}>;
/**
 * Finalized conversion output
 *
 *  EpProp
 */
declare type EpPropFinalized<Type, Value, Validator, Default, Required> = EpProp<EpPropMergeType<Type, Value, Validator>, UnknownToNever<Default>, Required>;
declare const epPropKey = "__epPropKey";
/**
 * Merge Type, Value, Validator types
 *  TypeValueValidator 
 *
 * @example
 * EpPropMergeType<StringConstructor, '1', 1> =>  1 | "1" // ignores StringConstructor
 * EpPropMergeType<StringConstructor, never, number> =>  string | number
 */
declare type EpPropMergeType<Type, Value, Validator> = IfNever<UnknownToNever<Value>, ResolvePropType<Type>, never> | UnknownToNever<Value> | UnknownToNever<Validator>;
declare const _event: {
    readonly type: PropType<(val: boolean) => void>;
    readonly required: false;
    readonly validator: ((val: unknown) => boolean) | undefined;
    __epPropKey: true;
};
export declare const EVENT_CODE: {
    tab: string;
    enter: string;
    space: string;
    left: string;
    up: string;
    right: string;
    down: string;
    esc: string;
    delete: string;
    backspace: string;
    numpadEnter: string;
    pageUp: string;
    pageDown: string;
    home: string;
    end: string;
};
export declare type ExpandedRowsChangeHandler = (expandedRowKeys: KeyType_2[]) => void;
export declare type ExpandTrigger = "click" | "hover";
export declare type ExperimentalFeatures = {};
export declare type ExposesStates = {
    isScrolling: boolean;
    updateRequested: boolean;
};
/**
 * Renderer/Getter types
 */
export declare type ExtraCellPropGetter<T> = (params: ColumnCommonParams<T> & RowCommonParams & {
    cellData: T;
    rowData: any;
}) => any;
export declare const extractDateFormat: (format: string) => string;
export declare type ExtractHeaderCellPropGetter<T> = (params: ColumnCommonParams<T> & {
    headerIndex: number;
}) => any;
export declare type ExtractHeaderPropGetter<T> = (params: {
    columns: Column<T>[];
    headerIndex: number;
}) => any;
/**
 * Extract the type of a single prop
 *
 *  prop 
 *
 * @example
 * ExtractPropType<{ type: StringConstructor }> => string | undefined
 * ExtractPropType<{ type: StringConstructor, required: true }> => string
 * ExtractPropType<{ type: BooleanConstructor }> => boolean
 */
declare type ExtractPropType<T extends object> = Value<ExtractPropTypes<{
    key: T;
}>>;
export declare type ExtractRowPropGetter<T> = (params: {
    columns: Column<T>[];
} & RowCommonParams) => any;
export declare const extractTimeFormat: (format: string) => string;
export declare interface FakeNode {
    data: TreeNodeData;
}
/**
 * Type which collects all paths through a type
 *
 * 
 *
 * @example
 * FieldPath<{ 1: number; a: number; b: string; c: { d: number; e: string }; f: [{ value: string }]; g: { value: string }[]; h: Date; i: FileList; j: File; k: Blob; l: RegExp }> => '1' | 'a' | 'b' | 'c' | 'f' | 'g' | 'c.d' | 'c.e' | 'f.0' | 'f.0.value' | 'g.number' | 'g.number.value' | 'h' | 'i' | 'j' | 'k' | 'l'
 */
declare type FieldPath<T> = T extends object ? Path<T> : never;
export declare interface Filter<T extends DefaultRow> {
    column: TableColumnCtx<T>;
    values: string[];
    silent: any;
}
declare type FilterMethod = (query: string, data: TreeNodeData_2, node: TreeNode_2) => boolean;
declare type FilterMethods<T extends DefaultRow> = (value: string, row: T, column: TableColumnCtx<T>) => void;
export declare type FilterNodeMethodFunction = (value: FilterValue, data: TreeNodeData, child: Node_2) => boolean;
declare type Filters = {
    text: string;
    value: string;
}[];
export declare type FilterValue = any;
export declare const FIRST_KEYS: string[];
export declare const FIRST_LAST_KEYS: string[];
declare type FixedDirection = TableV2FixedDir;
export declare const FixedSizeGrid: DefineComponent<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("scroll" | "itemRendered")[], "scroll" | "itemRendered", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
}>> & {
    onScroll?: ((...args: any[]) => any) | undefined;
    onItemRendered?: ((...args: any[]) => any) | undefined;
}, {
    readonly data: any[];
    readonly direction: EpPropMergeType<StringConstructor, "ltr" | "rtl", never>;
    readonly className: string;
    readonly containerElement: EpPropMergeType<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown>;
    readonly innerElement: EpPropMergeType<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown>;
    readonly perfMode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly itemKey: GridItemKeyGetter;
    readonly columnCache: number;
    readonly initScrollLeft: number;
    readonly initScrollTop: number;
    readonly rowCache: number;
    readonly hScrollbarSize: number;
    readonly vScrollbarSize: number;
    readonly scrollbarStartGap: number;
    readonly scrollbarEndGap: number;
}>;
export declare const FixedSizeList: DefineComponent<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedItemSize: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", never, "vertical", false>;
    readonly initScrollOffset: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly total: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly itemSize: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    clientSize: ComputedRef<string | number | undefined>;
    estimatedTotalSize: ComputedRef<number>;
    windowStyle: ComputedRef<(string | CSSProperties | StyleValue[] | {
        [x: string]: string;
        position: string;
        WebkitOverflowScrolling: string;
        willChange: string;
    } | undefined)[]>;
    windowRef: Ref<HTMLElement | undefined>;
    innerRef: Ref<HTMLElement | undefined>;
    innerStyle: ComputedRef<{
        height: string;
        pointerEvents: string | undefined;
        width: string;
    }>;
    itemsToRender: ComputedRef<number[]>;
    scrollbarRef: Ref<any>;
    states: Ref<{
        isScrolling: boolean;
        scrollDir: string;
        scrollOffset: number;
        updateRequested: boolean;
        isScrollbarDragging: boolean;
        scrollbarAlwaysOn: boolean;
    }>;
    getItemStyle: (idx: number) => CSSProperties;
    onScroll: (e: Event) => void;
    onScrollbarScroll: (distanceToGo: number, totalSteps: number) => void;
    onWheel: (e: WheelEvent) => void;
    scrollTo: (offset: number) => void;
    scrollToItem: (idx: number, alignment?: Alignment) => void;
    resetScrollTop: () => void;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("scroll" | "itemRendered")[], "scroll" | "itemRendered", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedItemSize: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", never, "vertical", false>;
    readonly initScrollOffset: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly total: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly itemSize: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    onScroll?: ((...args: any[]) => any) | undefined;
    onItemRendered?: ((...args: any[]) => any) | undefined;
}, {
    readonly data: any[];
    readonly direction: EpPropMergeType<StringConstructor, "ltr" | "rtl", never>;
    readonly layout: EpPropMergeType<StringConstructor, "horizontal" | "vertical", never>;
    readonly className: string;
    readonly containerElement: EpPropMergeType<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown>;
    readonly innerElement: EpPropMergeType<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown>;
    readonly perfMode: EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly cache: number;
    readonly initScrollOffset: number;
}>;
export declare type FixedSizeListInstance = InstanceType<typeof FixedSizeList> & unknown;
declare function focus_2(): void;
export declare type FooterInstance = InstanceType<typeof _default_36> & unknown;
export declare const formatter: (date: string | number | Date | Dayjs, format: string | undefined, lang: string) => string | number | Date | dayjs_2.Dayjs;
export declare type FormContext = FormProps & UnwrapRef<FormLabelWidthContext> & {
    emit: SetupContext<FormEmits>["emit"];
    getField: (prop: FormItemProp) => FormItemContext | undefined;
    addField: (field: FormItemContext) => void;
    removeField: (field: FormItemContext) => void;
    resetFields: (props?: Arrayable<FormItemProp>) => void;
    clearValidate: (props?: Arrayable<FormItemProp>) => void;
    validateField: (props?: Arrayable<FormItemProp>, callback?: FormValidateCallback) => FormValidationResult;
};
export declare const formContextKey: InjectionKey<FormContext>;
export declare type FormEmits = typeof formEmits;
export declare const formEmits: {
    validate: (prop: FormItemProp, isValid: boolean, message: string) => boolean;
};
export declare type FormInstance = InstanceType<typeof _default_50> & unknown;
export declare interface FormItemContext extends FormItemProps {
    $el: HTMLDivElement | undefined;
    size: ComponentSize;
    validateMessage: string;
    validateState: FormItemValidateState;
    isGroup: boolean;
    labelId: string;
    inputIds: string[];
    hasLabel: boolean;
    fieldValue: any;
    propString: string;
    addInputId: (id: string) => void;
    removeInputId: (id: string) => void;
    validate: (trigger: string, callback?: FormValidateCallback) => FormValidationResult;
    resetField(): void;
    clearValidate(): void;
}
export declare const formItemContextKey: InjectionKey<FormItemContext>;
export declare type FormItemInstance = InstanceType<typeof _default_51> & unknown;
export declare type FormItemProp = Arrayable<string>;
export declare type FormItemProps = ExtractPropTypes<typeof formItemProps>;
export declare const formItemProps: {
    readonly label: StringConstructor;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly labelPosition: EpPropFinalized<StringConstructor, "" | "top" | "left" | "right", unknown, "", boolean>;
    readonly prop: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly rules: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly error: StringConstructor;
    readonly validateStatus: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "error" | "success" | "validating", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly for: StringConstructor;
    readonly inlineMessage: EpPropFinalized<readonly [
        StringConstructor,
        BooleanConstructor
    ], unknown, unknown, "", boolean>;
    readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type FormItemPropsPublic = __ExtractPublicPropTypes<typeof formItemProps>;
export declare interface FormItemRule extends RuleItem {
    trigger?: Arrayable<string>;
}
export declare type FormItemValidateState = typeof formItemValidateStates[number];
export declare const formItemValidateStates: readonly [
    "",
    "error",
    "validating",
    "success"
];
export declare type FormLabelWidthContext = ReturnType<typeof useFormLabelWidth>;
export declare type FormMetaProps = ExtractPropTypes<typeof formMetaProps>;
export declare const formMetaProps: {
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
};
export declare type FormMetaPropsPublic = __ExtractPublicPropTypes<typeof formMetaProps>;
export declare type FormProps = ExtractPropTypes<typeof formProps>;
export declare const formProps: {
    readonly model: ObjectConstructor;
    readonly rules: {
        readonly type: PropType<Partial<Record<string, Arrayable<FormItemRule>>>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly labelPosition: EpPropFinalized<StringConstructor, "top" | "left" | "right", unknown, "right", boolean>;
    readonly requireAsteriskPosition: EpPropFinalized<StringConstructor, "left" | "right", unknown, "left", boolean>;
    readonly labelWidth: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly labelSuffix: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly inline: BooleanConstructor;
    readonly inlineMessage: BooleanConstructor;
    readonly statusIcon: BooleanConstructor;
    readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly validateOnRuleChange: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly hideRequiredAsterisk: BooleanConstructor;
    readonly scrollToError: BooleanConstructor;
    readonly scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
};
export declare type FormPropsPublic = __ExtractPublicPropTypes<typeof formProps>;
export declare type FormRules<T extends MaybeRef<Record<string, any> | string> = string> = Partial<Record<UnwrapRef<T> extends string ? UnwrapRef<T> : FieldPath<UnwrapRef<T>>, Arrayable<FormItemRule>>>;
export declare type FormValidateCallback = (isValid: boolean, invalidFields?: ValidateFieldsError) => Promise<void> | void;
export declare interface FormValidateFailure {
    errors: ValidateError[] | null;
    fields: ValidateFieldsError;
}
export declare type FormValidationResult = Promise<boolean>;
declare const FORWARD = "forward";
export declare const FORWARD_REF_INJECTION_KEY: InjectionKey<ForwardRefInjectionContext>;
export declare type ForwardRefInjectionContext = {
    setForwardRef: ForwardRefSetter;
};
declare type ForwardRefSetter = <T>(el: T) => void;
export declare const GAP = 4;
export declare const genFileId: () => number;
export declare type GetDisabledHours = (role: string, comparingDate?: Dayjs) => number[];
export declare type GetDisabledMinutes = (hour: number, role: string, comparingDate?: Dayjs) => number[];
export declare type GetDisabledSeconds = (hour: number, minute: number, role: string, comparingDate?: Dayjs) => number[];
export declare type GetEstimatedTotalSize<T, P extends InitCacheFunc<T, GridCache | ListCache>> = (props: T, cache: ReturnType<P>) => number;
export declare type GetGridOffset<T, P extends InitGridCacheFunc<T>> = (props: T, index: number, alignment: Alignment, offset: number, cache: ReturnType<P>, scrollbarWidth: number) => number;
export declare type GetOffset<T, P extends InitListCacheFunc<T>> = (props: T, idx: number, alignment: Alignment, offset: number, cache: ReturnType<P>) => number;
export declare type GetPosition<T, P extends InitGridCacheFunc<T>> = (props: T, index: number, cache: ReturnType<P>) => [
    number,
    number
];
export declare const getPositionDataWithUnit: <T extends Record<string, number>>(record: T | undefined, key: keyof T) => string;
export declare type GetStartIndexForOffset<T, P extends InitCacheFunc<T, GridCache | ListCache>> = (props: T, offset: number, cache: ReturnType<P>) => number;
export declare type GetStopIndexForStartIndex<T, P extends InitCacheFunc<T, GridCache | ListCache>> = (props: T, startIndex: number, scrollOffset: number, cache: ReturnType<P>) => number;
export declare type GridCache = {
    column: Record<string, ListItem>;
    row: Record<string, ListItem>;
    estimatedColumnWidth: number;
    estimatedRowHeight: number;
    lastVisitedColumnIndex: number;
    lastVisitedRowIndex: number;
};
export declare type GridConstructorProps<T, P extends InitGridCacheFunc<T> = InitGridCacheFunc<T>> = {
    name?: string;
    getColumnOffset: GetGridOffset<T, P>;
    getColumnPosition: GetPosition<T, P>;
    getColumnStartIndexForOffset: GetStartIndexForOffset<T, P>;
    getColumnStopIndexForStartIndex: GetStopIndexForStartIndex<T, P>;
    getEstimatedTotalHeight: GetEstimatedTotalSize<T, P>;
    getEstimatedTotalWidth: GetEstimatedTotalSize<T, P>;
    getRowOffset: GetGridOffset<T, P>;
    getRowPosition: GetPosition<T, P>;
    getRowStartIndexForOffset: GetStartIndexForOffset<T, P>;
    getRowStopIndexForStartIndex: GetStopIndexForStartIndex<T, P>;
    initCache: P;
    injectToInstance?: (instance: Instance, cache: Ref<ReturnType<P>>) => void;
    clearCache: boolean;
    validateProps: PropValidator<T>;
};
/**
 * Instance methods and emits
 */
export declare type GridDefaultSlotParams = {
    columnIndex: number;
    rowIndex: number;
    data: any;
    key: number | string;
    isScrolling?: boolean;
    style: CSSProperties;
};
export declare type GridExposes = {
    states: {
        scrollLeft: number;
        scrollTop: number;
        xAxisScrollDir: Direction;
        yAxisScrollDir: Direction;
    } & ExposesStates;
    scrollTo: (props: {
        scrollLeft: number;
        scrollTop: number;
    }) => void;
    scrollToItem: (columnIndex?: number, rowIndex?: number, alignment?: Alignment) => void;
} & SharedExposes;
export declare type GridInstance = InstanceType<ReturnType<typeof createGrid>> & UnwrapRef<{
    windowRef: Ref<HTMLElement>;
    innerRef: Ref<HTMLElement>;
    getItemStyleCache: ReturnType<typeof useCache>;
    scrollTo: (scrollOptions: GridScrollOptions) => void;
    scrollToItem: (rowIndex: number, columnIndex: number, alignment: Alignment) => void;
    states: Ref<{
        isScrolling: boolean;
        scrollLeft: number;
        scrollTop: number;
        updateRequested: boolean;
        xAxisScrollDir: Dir;
        yAxisScrollDir: Dir;
    }>;
}>;
export declare type GridItemKeyGetter = <T extends {
    [key: string | number]: any;
}>(args: {
    columnIndex: number;
    data: T;
    rowIndex: number;
}) => string | number;
export declare type GridItemRenderedEvtParams = {
    columnCacheStart: number;
    columnCacheEnd: number;
    rowCacheStart: number;
    rowCacheEnd: number;
    columnVisibleStart: number;
    columnVisibleEnd: number;
    rowVisibleStart: number;
    rowVisibleEnd: number;
};
export declare type GridScrollOptions = {
    scrollLeft?: number;
    scrollTop?: number;
};
declare function handleActions(action: ImageViewerAction, options?: {}): void;
declare type HeaderCellRenderer<T> = (params: HeaderCellRendererParams<T>) => VNode;
declare type HeaderCellRendererParams<T> = {
    headerIndex: number;
} & ColumnCommonParams<T>;
declare type HeaderCellRendererProps = TableV2HeaderRowCellRendererParams & UnwrapNestedRefs<Pick<UseTableReturn, "onColumnSorted">> & Pick<TableV2Props, "sortBy" | "sortState" | "headerCellProps"> & {
    ns: UseNamespaceReturn;
};
export declare type HeaderCellSlotProps = HeaderCellRendererProps & {
    class: string;
};
declare type HeaderClassGetter<T> = (params: ColumnCommonParams<T> & {
    headerIndex: number;
}) => string;
export declare type HeaderClassNameGetter<T> = (params: {
    columns: Column<T>[];
    headerIndex: number;
}) => string;
export declare type HeaderInstance = InstanceType<typeof _default_37> & unknown;
declare class HelperStore<T extends DefaultRow> {
    Return: {
        mutations: {
            setData(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, data: T[]): void;
            insertColumn(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, column: TableColumnCtx<T>, parent: TableColumnCtx<T>, updateColumnOrder: () => void): void;
            updateColumnOrder(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, column: TableColumnCtx<T>): void;
            removeColumn(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, column: TableColumnCtx<T>, parent: TableColumnCtx<T>, updateColumnOrder: () => void): void;
            sort(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, options: Sort): void;
            changeSortCondition(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, options: Sort): void;
            filterChange(_states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, options: Filter<T>): void;
            toggleAllSelection(): void;
            rowSelectedChanged(_states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, row: T): void;
            setHoverRow(states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, row: T): void;
            setCurrentRow(_states: {
                _currentRowKey: Ref<string | null>;
                currentRow: Ref<T | null>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<Record<string, TreeData_2>>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<Record<string, T[]>>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string | null>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<((row: T, index: number) => boolean) | null>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<T[] | null>;
                sortingColumn: Ref<TableColumnCtx<T> | null>;
                sortProp: Ref<string | null>;
                sortOrder: Ref<string | number | null>;
                hoverRow: Ref<T | null>;
            }, row: T): void;
        };
        commit: (name: "sort" | "setData" | "insertColumn" | "updateColumnOrder" | "removeColumn" | "changeSortCondition" | "filterChange" | "toggleAllSelection" | "rowSelectedChanged" | "setHoverRow" | "setCurrentRow", ...args: any[]) => void;
        updateTableScrollY: () => void;
        assertRowKey: () => void;
        updateColumns: () => void;
        scheduleLayout: (needUpdateColumns?: boolean, immediate?: boolean) => void;
        isSelected: (row: T) => boolean;
        clearSelection: () => void;
        cleanSelection: () => void;
        getSelectionRows: () => T[];
        toggleRowSelection: (row: T, selected?: boolean, emitChange?: boolean, ignoreSelectable?: boolean) => void;
        _toggleAllSelection: () => void;
        toggleAllSelection: (() => void) | null;
        updateAllSelected: () => void;
        updateFilters: (column: TableColumnCtx<T>, values: string[]) => Record<string, string[]>;
        updateCurrentRow: (_currentRow: T) => void;
        updateSort: (column: TableColumnCtx<T> | null, prop: string | null, order: TableSortOrder | null) => void;
        execFilter: () => void;
        execSort: () => void;
        execQuery: (ignore?: {
            filter: boolean;
        } | undefined) => void;
        clearFilter: (columnKeys?: string[] | string) => void;
        clearSort: () => void;
        toggleRowExpansion: (row: T, expanded?: boolean) => void;
        setExpandRowKeysAdapter: (val: string[]) => void;
        setCurrentRowKey: (key: string) => void;
        toggleRowExpansionAdapter: (row: T, expanded?: boolean) => void;
        isRowExpanded: (row: T) => boolean;
        updateExpandRows: () => void;
        updateCurrentRowData: () => void;
        loadOrToggle: (row: T) => void;
        updateTreeData: (ifChangeExpandRowKeys?: boolean, ifExpandAll?: boolean) => void;
        updateKeyChildren: (key: string, data: T[]) => void;
        states: {
            _currentRowKey: Ref<string | null>;
            currentRow: Ref<T | null>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<Record<string, TreeData_2>>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<Record<string, T[]>>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string | null>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<((row: T, index: number) => boolean) | null>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<T[] | null>;
            sortingColumn: Ref<TableColumnCtx<T> | null>;
            sortProp: Ref<string | null>;
            sortOrder: Ref<string | number | null>;
            hoverRow: Ref<T | null>;
        };
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string) => string;
            e: (element?: string) => string;
            m: (modifier?: string) => string;
            be: (blockSuffix?: string, element?: string) => string;
            em: (element?: string, modifier?: string) => string;
            bm: (blockSuffix?: string, modifier?: string) => string;
            bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
    };
}
declare function hide(): void;
declare type HoverState<T extends DefaultRow> = Nullable<{
    cell: HTMLElement;
    column: TableColumnCtx<T>;
    row: T;
}>;
export declare type hType = typeof h;
export declare const IconComponentMap: Record<typeof IconMap[keyof typeof IconMap], Component>;
export declare type IconInstance = InstanceType<typeof _default_52> & unknown;
export declare const IconMap: {
    readonly primary: "icon-primary";
    readonly success: "icon-success";
    readonly warning: "icon-warning";
    readonly error: "icon-error";
    readonly info: "icon-info";
};
export declare type IconProps = ExtractPropTypes<typeof iconProps>;
export declare const iconProps: {
    readonly size: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly color: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type IconPropsPublic = __ExtractPublicPropTypes<typeof iconProps>;
export declare const ID_INJECTION_KEY: InjectionKey<ElIdInjectionContext>;
export declare interface IElDropdownInstance {
    instance?: ComponentInternalInstance;
    dropdownSize?: ComputedRef<string>;
    handleClick?: () => void;
    commandHandler?: (...arg: any[]) => void;
    show?: () => void;
    hide?: () => void;
    trigger?: ComputedRef<string>;
    hideOnClick?: ComputedRef<boolean>;
    triggerElm?: ComputedRef<Nullable<HTMLButtonElement>>;
}
export declare interface IElMessageBox {
    _context: AppContext | null;
    /** Show a message box */
    /** Show a message box */
    (options: ElMessageBoxOptions, appContext?: AppContext | null): Promise<MessageBoxData>;
    /** Show an alert message box */
    alert: ElMessageBoxShortcutMethod;
    /** Show a confirm message box */
    confirm: ElMessageBoxShortcutMethod;
    /** Show a prompt message box */
    prompt: ElMessageBoxShortcutMethod;
    /** Close current message box */
    close(): void;
}
declare type IfNever<T, Y = true, N = false> = [
    T
] extends [
    never
] ? Y : N;
declare type IfUnknown<T, Y, N> = [
    unknown
] extends [
    T
] ? Y : N;
export declare type ImageEmits = typeof imageEmits;
export declare const imageEmits: {
    load: (evt: Event) => boolean;
    error: (evt: Event) => boolean;
    switch: (val: number) => boolean;
    close: () => boolean;
    show: () => boolean;
};
export declare type ImageInstance = InstanceType<typeof _default_53> & unknown;
export declare type ImageProps = ExtractPropTypes<typeof imageProps>;
export declare const imageProps: {
    readonly hideOnClickModal: BooleanConstructor;
    readonly src: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fit: EpPropFinalized<StringConstructor, "" | "fill" | "contain" | "none" | "cover" | "scale-down", unknown, "", boolean>;
    readonly loading: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "lazy" | "eager", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly lazy: BooleanConstructor;
    readonly scrollContainer: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement | undefined) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement | undefined))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly previewSrcList: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly previewTeleported: BooleanConstructor;
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly infinite: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly zoomRate: EpPropFinalized<NumberConstructor, unknown, unknown, 1.2, boolean>;
    readonly minScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.2, boolean>;
    readonly maxScale: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly showProgress: BooleanConstructor;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type ImagePropsPublic = __ExtractPublicPropTypes<typeof imageProps>;
export declare type ImageViewerAction = "zoomIn" | "zoomOut" | "clockwise" | "anticlockwise";
export declare type ImageViewerEmits = typeof imageViewerEmits;
export declare const imageViewerEmits: {
    close: () => boolean;
    switch: (index: number) => boolean;
    rotate: (deg: number) => boolean;
};
export declare type ImageViewerInstance = InstanceType<typeof _default_54> & unknown;
export declare interface ImageViewerMode {
    name: string;
    icon: Component;
}
export declare type ImageViewerProps = ExtractPropTypes<typeof imageViewerProps>;
export declare const imageViewerProps: {
    readonly urlList: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initialIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly infinite: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly hideOnClickModal: BooleanConstructor;
    readonly teleported: BooleanConstructor;
    readonly closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly zoomRate: EpPropFinalized<NumberConstructor, unknown, unknown, 1.2, boolean>;
    readonly minScale: EpPropFinalized<NumberConstructor, unknown, unknown, 0.2, boolean>;
    readonly maxScale: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly showProgress: BooleanConstructor;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type ImageViewerPropsPublic = __ExtractPublicPropTypes<typeof imageViewerProps>;
declare type Indices = {
    columnIndex?: number;
    rowIndex?: number;
};
export declare type InitCacheFunc<T, P> = (props: T, cache: Instance) => P;
export declare type InitGridCacheFunc<T> = InitCacheFunc<T, GridCache>;
export declare type InitListCacheFunc<T> = InitCacheFunc<T, ListCache>;
export declare const INPUT_EVENT = "input";
export declare type InputAutoSize = {
    minRows?: number;
    maxRows?: number;
} | boolean;
export declare type InputEmits = typeof inputEmits;
export declare const inputEmits: {
    "update:modelValue": (value: string) => boolean;
    input: (value: string) => boolean;
    change: (value: string) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
    clear: () => boolean;
    mouseleave: (evt: MouseEvent) => boolean;
    mouseenter: (evt: MouseEvent) => boolean;
    keydown: (evt: KeyboardEvent | Event) => boolean;
    compositionstart: (evt: CompositionEvent) => boolean;
    compositionupdate: (evt: CompositionEvent) => boolean;
    compositionend: (evt: CompositionEvent) => boolean;
};
export declare type InputInstance = InstanceType<typeof _default_5> & unknown;
export declare type InputNumberEmits = typeof inputNumberEmits;
export declare const inputNumberEmits: {
    change: (cur: number | undefined, prev: number | undefined) => boolean;
    blur: (e: FocusEvent) => boolean;
    focus: (e: FocusEvent) => boolean;
    input: (val: number | null | undefined) => boolean;
    "update:modelValue": (val: number | undefined) => boolean;
};
export declare type InputNumberInstance = InstanceType<typeof _default_55> & unknown;
export declare type InputNumberProps = ExtractPropTypes<typeof inputNumberProps>;
export declare const inputNumberProps: {
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly align: EpPropFinalized<(new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right") | ((new (...args: any[]) => "center" | "left" | "right") | (() => "center" | "left" | "right"))[], unknown, unknown, "center", boolean>;
    readonly disabledScientific: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly step: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly stepStrictly: BooleanConstructor;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly min: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    readonly modelValue: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly controls: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly controlsPosition: EpPropFinalized<StringConstructor, "" | "right", unknown, "", boolean>;
    readonly valueOnClear: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor,
        null
    ], unknown, unknown, null, boolean>;
    readonly name: StringConstructor;
    readonly placeholder: StringConstructor;
    readonly precision: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare type InputNumberPropsPublic = __ExtractPublicPropTypes<typeof inputNumberProps>;
export declare type InputProps = ExtractPropTypes<typeof inputProps>;
export declare const inputProps: {
    readonly inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    readonly name: StringConstructor;
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number | null | undefined) | ((new (...args: any[]) => string | number) | (() => string | number | null | undefined))[], unknown, unknown, "", boolean>;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    readonly resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showPassword: BooleanConstructor;
    readonly showWordLimit: BooleanConstructor;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly autofocus: BooleanConstructor;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
};
export declare type InputPropsPublic = __ExtractPublicPropTypes<typeof inputProps>;
export declare type InputTagEmits = typeof inputTagEmits;
export declare const inputTagEmits: {
    "update:modelValue": (value?: string[]) => boolean;
    change: (value?: string[]) => boolean;
    input: (value: string) => boolean;
    "add-tag": (value: string | string[]) => boolean;
    "remove-tag": (value: string) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
    clear: () => boolean;
};
export declare type InputTagInstance = InstanceType<typeof _default_56> & unknown;
export declare type InputTagProps = ExtractPropTypes<typeof inputTagProps>;
export declare const inputTagProps: {
    readonly modelValue: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly max: NumberConstructor;
    readonly tagType: {
        readonly default: "info";
        readonly type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tagEffect: EpPropFinalized<StringConstructor, "dark" | "light" | "plain", unknown, "light", boolean>;
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space") | ((new (...args: any[]) => "Enter" | "Space") | (() => "Enter" | "Space"))[], unknown, unknown, string, boolean>;
    readonly draggable: BooleanConstructor;
    readonly delimiter: EpPropFinalized<readonly [
        StringConstructor,
        RegExpConstructor
    ], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly readonly: BooleanConstructor;
    readonly autofocus: BooleanConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    readonly saveOnBlur: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly collapseTags: BooleanConstructor;
    readonly collapseTagsTooltip: BooleanConstructor;
    readonly maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly ariaLabel: StringConstructor;
};
export declare type InputTagPropsPublic = __ExtractPublicPropTypes<typeof inputTagProps>;
export declare const install: (app: App, options?: ConfigProviderContext) => void;
export declare const INSTALLED_KEY: unique symbol;
export declare type Instance = ComponentInternalInstance;
declare const INSTANCE_KEY: unique symbol;
export declare type isDisabled = (data: CascaderOption, node: CascaderNode) => boolean;
declare type isDisabled_2 = (data: CascaderOption, node: CascaderNode) => boolean;
export declare type isLeaf = (data: CascaderOption, node: CascaderNode) => boolean;
declare type isLeaf_2 = (data: CascaderOption, node: CascaderNode) => boolean;
/**
 * Check whether it is tuple
 *
 * 
 *
 * @example
 * IsTuple<[1, 2, 3]> => true
 * IsTuple<Array[number]> => false
 */
declare type IsTuple<T extends ReadonlyArray<any>> = number extends T["length"] ? false : true;
export declare type ItemProps<T> = {
    data: T;
    style: CSSProperties;
    scrolling?: boolean;
    index: number;
};
export declare type ItemSize = (idx: number) => number;
export declare type IUseFormItemInputCommonProps = {
    id?: string;
    label?: string | number | boolean | Record<string, any>;
    ariaLabel?: string | number | boolean | Record<string, any>;
};
declare type KeyType_2 = string | number | symbol;
declare type Language = {
    name: string;
    el: TranslatePair;
};
export declare const LAST_KEYS: string[];
declare type Layout = "fixed" | "auto";
export declare type LayoutDirection = "horizontal" | "vertical";
export declare type LazyLoad = (node: CascaderNode, resolve: Resolve) => void;
declare type LazyLoad_2 = (node: CascaderNode, resolve: Resolve_2) => void;
export declare const LEFT_CHECK_CHANGE_EVENT = "left-check-change";
export declare interface LinkConfigContext {
    type?: string;
    underline?: string | boolean;
}
export declare type LinkEmits = typeof linkEmits;
export declare const linkEmits: {
    click: (evt: MouseEvent) => boolean;
};
export declare type LinkInstance = InstanceType<typeof _default_57> & unknown;
export declare type LinkProps = ExtractPropTypes<typeof linkProps>;
export declare const linkProps: {
    readonly type: EpPropFinalized<StringConstructor, "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, undefined, boolean>;
    readonly underline: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor
    ], boolean | "always" | "never" | "hover", unknown, undefined, boolean>;
    readonly disabled: BooleanConstructor;
    readonly href: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly target: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "_self", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type LinkPropsPublic = __ExtractPublicPropTypes<typeof linkProps>;
export declare type ListCache = {
    items: Record<string, ListItem>;
    estimatedItemSize: number;
    lastVisitedIndex: number;
    clearCacheAfterIndex: (idx: number, forceUpdate?: boolean) => void;
};
export declare type ListConstructorProps<T, P extends InitListCacheFunc<T> = InitListCacheFunc<T>> = {
    name?: string;
    getItemOffset: ListItemSizer<T, P>;
    getEstimatedTotalSize: GetEstimatedTotalSize<T, P>;
    getItemSize: ListItemSizer<T, P>;
    getOffset: GetOffset<T, P>;
    getStartIndexForOffset: GetStartIndexForOffset<T, P>;
    getStopIndexForStartIndex: GetStopIndexForStartIndex<T, P>;
    initCache: P;
    clearCache: boolean;
    validateProps: PropValidator<T>;
};
export declare type ListExposes = {
    scrollTo: (offset: number) => void;
    scrollToItem: (idx: number, alignment?: Alignment) => void;
    states: {
        scrollDir: Direction;
        scrollOffset: number;
    } & ExposesStates;
} & SharedExposes;
export declare type ListItem = {
    offset: number;
    size: number;
};
export declare type ListItemSizer<T, P extends InitListCacheFunc<T>> = (props: T, index: number, cache: ReturnType<P>) => number;
export declare type LoadFunction = (rootNode: Node_2, loadedCallback: (data: TreeData) => void, stopLoading: () => void) => void;
declare type LoadingBinding = boolean | UnwrapRef<LoadingOptions>;
declare type LoadingInstance = ReturnType<typeof createLoadingComponent>;
export declare type LoadingOptions = Partial<Omit<LoadingOptionsResolved, "parent" | "target"> & {
    /**
     * @description the DOM node Loading needs to cover. Accepts a DOM object or a string. If it's a string, it will be passed to `document.querySelector` to get the corresponding DOM node
     */
    target: HTMLElement | string;
    /**
     * @description same as the `body` modifier of `v-loading`
     */
    body: boolean;
}>;
export declare type LoadingOptionsResolved = {
    parent: LoadingParentElement;
    /**
     * @description background color of the mask
     */
    background: MaybeRef<string>;
    svg: MaybeRef<string>;
    svgViewBox: MaybeRef<string>;
    /**
     * @description class name of the custom spinner
     */
    spinner: MaybeRef<boolean | string>;
    /**
     * @description loading text that displays under the spinner
     */
    text: MaybeRef<string>;
    /**
     * @description same as the `fullscreen` modifier of `v-loading`
     */
    fullscreen: boolean;
    /**
     * @description same as the `lock` modifier of `v-loading`
     */
    lock: boolean;
    /**
     * @description custom class name for Loading
     */
    customClass: MaybeRef<string>;
    visible: boolean;
    target: HTMLElement;
    beforeClose?: () => boolean;
    closed?: () => void;
};
export declare interface LoadingParentElement extends HTMLElement {
    vLoadingAddClassList?: () => void;
}
export declare type LocaleContext = {
    locale: Ref<Language>;
    lang: Ref<string>;
    t: Translator;
};
export declare const localeContextKey: InjectionKey<Ref<Language | undefined>>;
export declare type MainInstance = InstanceType<typeof _default_38> & unknown;
export declare const makeInstaller: (components?: Plugin_2[]) => {
    version: string;
    install: (app: App, options?: ConfigProviderContext) => void;
};
export declare const makeList: (total: number, method?: () => number[]) => boolean[];
export declare type Measurable = {
    getBoundingClientRect: () => DOMRect;
};
export declare type MentionEmits = typeof mentionEmits;
export declare const mentionEmits: {
    "update:modelValue": (value: string) => boolean;
    "whole-remove": (pattern: string, prefix: string) => boolean;
    input: (value: string) => boolean;
    search: (pattern: string, prefix: string) => boolean;
    select: (option: MentionOption, prefix: string) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
};
export declare type MentionInstance = InstanceType<typeof _default_109> & unknown;
export declare type MentionOption = {
    value: string;
    label?: string;
    disabled?: boolean;
    [key: string]: any;
};
export declare type MentionProps = ExtractPropTypes<typeof mentionProps>;
export declare const mentionProps: {
    options: EpPropFinalized<(new (...args: any[]) => MentionOption[]) | (() => MentionOption[]) | ((new (...args: any[]) => MentionOption[]) | (() => MentionOption[]))[], unknown, unknown, () => never[], boolean>;
    prefix: EpPropFinalized<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown, string, boolean>;
    split: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    filterOption: EpPropFinalized<(new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)) | ((new (...args: any[]) => false | ((pattern: string, option: MentionOption) => boolean)) | (() => false | ((pattern: string, option: MentionOption) => boolean)))[], unknown, unknown, () => (pattern: string, option: MentionOption) => boolean, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom") | ((new (...args: any[]) => "top" | "bottom") | (() => "top" | "bottom"))[], unknown, unknown, string, boolean>;
    showArrow: BooleanConstructor;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    whole: BooleanConstructor;
    checkIsWhole: {
        readonly type: PropType<(pattern: string, prefix: string) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    modelValue: StringConstructor;
    loading: BooleanConstructor;
    popperClass: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    inputmode: EpPropFinalized<(new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined) | ((new (...args: any[]) => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal") | (() => "search" | "text" | "none" | "url" | "email" | "tel" | "numeric" | "decimal" | undefined))[], unknown, unknown, undefined, boolean>;
    name: StringConstructor;
    ariaLabel: StringConstructor;
    id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    maxlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    minlength: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    type: EpPropFinalized<StringConstructor, unknown, unknown, "text", boolean>;
    resize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "none" | "both" | "horizontal" | "vertical", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    autosize: EpPropFinalized<(new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize) | ((new (...args: any[]) => boolean | {
        minRows?: number;
        maxRows?: number;
    }) | (() => InputAutoSize))[], unknown, unknown, false, boolean>;
    autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, "off", boolean>;
    formatter: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    parser: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    form: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly: BooleanConstructor;
    clearable: BooleanConstructor;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    showPassword: BooleanConstructor;
    showWordLimit: BooleanConstructor;
    suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    prefixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    containerRole: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    inputStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, () => Mutable<{}>, boolean>;
    autofocus: BooleanConstructor;
    rows: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
};
export declare type MentionPropsPublic = __ExtractPublicPropTypes<typeof mentionProps>;
export declare const MENU_INJECTION_KEY = "rootMenu";
export declare type MenuEmits = typeof menuEmits;
export declare const menuEmits: {
    close: (index: string, indexPath: string[]) => boolean;
    open: (index: string, indexPath: string[]) => boolean;
    select: (index: string, indexPath: string[], item: MenuItemClicked, routerResult?: Promise<void | NavigationFailure>) => boolean;
};
export declare type MenuInstance = InstanceType<typeof _default_58> & {
    open: (index: string) => void;
    close: (index: string) => void;
    handleResize: () => void;
    updateActiveIndex: (index: string) => void;
};
export declare interface MenuItemClicked {
    index: string;
    indexPath: string[];
    route?: RouteLocationRaw;
}
export declare type MenuItemEmits = typeof menuItemEmits;
export declare const menuItemEmits: {
    click: (item: MenuItemRegistered) => boolean;
};
export declare type MenuItemGroupInstance = InstanceType<typeof _default_60> & unknown;
export declare type MenuItemGroupProps = ExtractPropTypes<typeof menuItemGroupProps>;
export declare const menuItemGroupProps: {
    /**
     * @description group title
     */
    readonly title: StringConstructor;
};
export declare type MenuItemGroupPropsPublic = __ExtractPublicPropTypes<typeof menuItemGroupProps>;
export declare type MenuItemInstance = InstanceType<typeof _default_59> & unknown;
export declare type MenuItemProps = ExtractPropTypes<typeof menuItemProps>;
export declare const menuItemProps: {
    readonly index: EpPropFinalized<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown, null, boolean>;
    readonly route: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw) | ((new (...args: any[]) => RouteLocationRaw & {}) | (() => RouteLocationRaw))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
};
export declare type MenuItemPropsPublic = __ExtractPublicPropTypes<typeof menuItemProps>;
export declare interface MenuItemRegistered {
    index: string;
    indexPath: string[];
    active: boolean;
}
export declare type MenuProps = ExtractPropTypes<typeof menuProps>;
export declare const menuProps: {
    readonly mode: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "vertical", boolean>;
    readonly defaultActive: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly defaultOpeneds: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly uniqueOpened: BooleanConstructor;
    readonly router: BooleanConstructor;
    readonly menuTrigger: EpPropFinalized<StringConstructor, "click" | "hover", unknown, "hover", boolean>;
    readonly collapse: BooleanConstructor;
    readonly backgroundColor: StringConstructor;
    readonly textColor: StringConstructor;
    readonly activeTextColor: StringConstructor;
    readonly closeOnClickOutside: BooleanConstructor;
    readonly collapseTransition: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly ellipsis: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly popperOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly ellipsisIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly popperEffect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly popperClass: StringConstructor;
    readonly showTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly hideTimeout: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare type MenuPropsPublic = __ExtractPublicPropTypes<typeof menuProps>;
export declare interface MenuProvider {
    openedMenus: string[];
    items: Record<string, MenuItemRegistered>;
    subMenus: Record<string, MenuItemRegistered>;
    activeIndex?: string;
    isMenuPopup: boolean;
    props: MenuProps;
    addMenuItem: (item: MenuItemRegistered) => void;
    removeMenuItem: (item: MenuItemRegistered) => void;
    addSubMenu: (item: MenuItemRegistered) => void;
    removeSubMenu: (item: MenuItemRegistered) => void;
    openMenu: (index: string, indexPath: string[]) => void;
    closeMenu: (index: string, indexPath: string[]) => void;
    handleMenuItemClick: (item: MenuItemClicked) => void;
    handleSubMenuClick: (subMenu: MenuItemRegistered) => void;
}
export declare type Message = MessageFn & {
    primary: MessageTypedFn;
    success: MessageTypedFn;
    warning: MessageTypedFn;
    info: MessageTypedFn;
    error: MessageTypedFn;
};
export declare const MESSAGE_DEFAULT_PLACEMENT = "top";
export declare type MessageBoxData = MessageBoxInputData & Action;
export declare interface MessageBoxInputData {
    value: string;
    action: Action;
}
export declare type MessageBoxInputValidator = ((value: string) => boolean | string) | undefined;
export declare interface MessageBoxState {
    autofocus: boolean;
    title: string | undefined;
    message: string;
    type: MessageType_2;
    icon: string | Component;
    closeIcon: string | Component;
    customClass: string;
    customStyle: CSSProperties;
    showInput: boolean;
    inputValue: string;
    inputPlaceholder: string;
    inputType: string;
    inputPattern: RegExp | null;
    inputValidator: MessageBoxInputValidator;
    inputErrorMessage: string;
    showConfirmButton: boolean;
    showCancelButton: boolean;
    action: Action;
    dangerouslyUseHTMLString: boolean;
    confirmButtonText: string;
    cancelButtonText: string;
    confirmButtonLoading: boolean;
    cancelButtonLoading: boolean;
    confirmButtonLoadingIcon: string | Component;
    cancelButtonLoadingIcon: string | Component;
    confirmButtonClass: string;
    confirmButtonDisabled: boolean;
    cancelButtonClass: string;
    editorErrorMessage: string;
    beforeClose: null | ((action: Action, instance: MessageBoxState, done: () => void) => void);
    callback: null | Callback;
    distinguishCancelAndClose: boolean;
    modalFade: boolean;
    modalClass: string;
    validateError: boolean;
    zIndex: number;
}
export declare type MessageBoxType = "" | "prompt" | "alert" | "confirm";
export declare const messageConfig: MessageConfigContext;
export declare interface MessageConfigContext {
    max?: number;
    grouping?: boolean;
    duration?: number;
    offset?: number;
    showClose?: boolean;
    plain?: boolean;
    placement?: string;
}
export declare const messageDefaults: Mutable<{
    readonly customClass: "";
    readonly dangerouslyUseHTMLString: false;
    readonly duration: 3000;
    readonly icon: undefined;
    readonly id: "";
    readonly message: "";
    readonly onClose: undefined;
    readonly showClose: false;
    readonly type: "info";
    readonly plain: false;
    readonly offset: 16;
    readonly placement: undefined;
    readonly zIndex: 0;
    readonly grouping: false;
    readonly repeatNum: 1;
    readonly appendTo: HTMLElement;
}>;
export declare type MessageEmits = typeof messageEmits;
export declare const messageEmits: {
    destroy: () => boolean;
};
export declare type MessageFn = {
    (options?: MessageParams, appContext?: null | AppContext): MessageHandler;
    closeAll(type?: MessageType): void;
    closeAllByPlacement(position: MessagePlacement): void;
};
export declare interface MessageHandler {
    /**
     * @description close the Message
     */
    close: () => void;
}
export declare type MessageInstance = InstanceType<typeof _default_112> & unknown;
export declare type MessageOptions = Partial<Mutable<Omit<MessageProps, "id"> & {
    appendTo?: HTMLElement | string;
}>>;
export declare type MessageOptionsWithType = Omit<MessageOptions, "type">;
export declare type MessageParams = MessageOptions | MessageOptions["message"];
export declare type MessageParamsNormalized = Omit<MessageProps, "id"> & {
    /**
     * @description set the root element for the message, default to `document.body`
     */
    appendTo: HTMLElement;
};
export declare type MessageParamsWithType = MessageOptionsWithType | MessageOptions["message"];
export declare type MessagePlacement = typeof messagePlacement[number];
export declare const messagePlacement: readonly [
    "top",
    "top-left",
    "top-right",
    "bottom",
    "bottom-left",
    "bottom-right"
];
export declare type MessageProps = ExtractPropTypes<typeof messageProps>;
export declare const messageProps: {
    readonly customClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly dangerouslyUseHTMLString: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 3000, boolean>;
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, undefined, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly message: EpPropFinalized<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown, "", boolean>;
    readonly onClose: EpPropFinalized<(new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly type: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
    readonly plain: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 16, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown, undefined, boolean>;
    readonly zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly grouping: EpPropFinalized<BooleanConstructor, unknown, unknown, false, boolean>;
    readonly repeatNum: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
};
export declare type MessagePropsPublic = __ExtractPublicPropTypes<typeof messageProps>;
export declare type MessageType = typeof messageTypes[number];
/** @deprecated please use `MessageType` instead */
export declare type messageType = MessageType;
declare type MessageType_2 = "" | "primary" | "success" | "warning" | "info" | "error";
export declare type MessageTypedFn = (options?: MessageParamsWithType, appContext?: null | AppContext) => MessageHandler;
export declare const messageTypes: readonly [
    "primary",
    "success",
    "info",
    "warning",
    "error"
];
export declare const MINIMUM_INPUT_WIDTH = 11;
declare type ModalInstance = {
    handleClose: () => void;
};
export declare type ModelToggleParams = {
    indicator: Ref<boolean>;
    toggleReason?: Ref<Event | undefined>;
    shouldHideWhenRouteChanges?: Ref<boolean>;
    shouldProceed?: () => boolean;
    onShow?: (event?: Event) => void;
    onHide?: (event?: Event) => void;
};
export declare type ModelValueType = SingleOrRange<DateModelType> | string[];
export declare const Mousewheel: ObjectDirective;
declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
export declare const namespaceContextKey: InjectionKey<Ref<string | undefined>>;
declare function next(): void;
declare class Node_2 {
    id: number;
    text: string | null;
    checked: boolean;
    indeterminate: boolean;
    data: TreeNodeData;
    expanded: boolean;
    parent: Node_2 | null;
    visible: boolean;
    isCurrent: boolean;
    store: TreeStore;
    isLeafByUser: boolean | undefined;
    isLeaf: boolean | undefined;
    canFocus: boolean;
    level: number;
    loaded: boolean;
    childNodes: Node_2[];
    loading: boolean;
    constructor(options: TreeNodeOptions);
    initialize(): void;
    setData(data: TreeNodeData): void;
    get label(): string;
    get key(): TreeKey | null | undefined;
    get disabled(): boolean;
    get nextSibling(): Nullable<Node_2>;
    get previousSibling(): Nullable<Node_2>;
    contains(target: Node_2, deep?: boolean): boolean;
    remove(): void;
    insertChild(child?: FakeNode | Node_2, index?: number, batch?: boolean): void;
    insertBefore(child: FakeNode | Node_2, ref: Node_2): void;
    insertAfter(child: FakeNode | Node_2, ref: Node_2): void;
    removeChild(child: Node_2): void;
    removeChildByData(data: TreeNodeData | null): void;
    expand(callback?: (() => void) | null, expandParent?: boolean): void;
    doCreateChildren(array: TreeNodeData[], defaultProps?: TreeNodeLoadedDefaultProps): void;
    collapse(): void;
    shouldLoadData(): boolean;
    updateLeafState(): void;
    setChecked(value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean): void;
    getChildren(forceInit?: boolean): TreeNodeData | TreeNodeData[] | null;
    updateChildren(): void;
    loadData(callback: (data?: TreeNodeData[]) => void, defaultProps?: TreeNodeLoadedDefaultProps): void;
    eachNode(callback: (node: Node_2) => void): void;
    reInitChecked(): void;
}
export declare const NODE_INSTANCE_INJECTION_KEY = "NodeInstance";
export declare type NodeDropType = "before" | "after" | "inner" | "none";
export declare type NotificationEmits = typeof notificationEmits;
export declare const notificationEmits: {
    destroy: () => boolean;
};
export declare interface NotificationHandle {
    close: () => void;
}
export declare type NotificationInstance = InstanceType<typeof _default_113> & unknown;
declare type NotificationOptions_2 = Omit<NotificationProps, "id" | "onClose"> & {
    /**
     * @description set the root element for the notification, default to `document.body`
     */
    appendTo?: HTMLElement | string;
    /**
     * @description callback function when closed
     */
    onClose?(vm: VNode): void;
};
export { NotificationOptions_2 as NotificationOptions };
export declare type NotificationOptionsTyped = Omit<NotificationOptions_2, "type">;
export declare type NotificationParams = Partial<NotificationOptions_2> | string | VNode;
export declare type NotificationParamsTyped = Partial<NotificationOptionsTyped> | string | VNode;
export declare type NotificationProps = ExtractPropTypes<typeof notificationProps>;
export declare const notificationProps: {
    readonly customClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly dangerouslyUseHTMLString: BooleanConstructor;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 4500, boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly message: EpPropFinalized<(new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | ((new (...args: any[]) => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)) | (() => string | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | (() => VNode)))[], unknown, unknown, "", boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly onClick: EpPropFinalized<(new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => () => void) | (() => () => void) | {
        (): () => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => undefined, boolean>;
    readonly onClose: {
        readonly type: PropType<() => void>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly position: EpPropFinalized<StringConstructor, "top-left" | "top-right" | "bottom-left" | "bottom-right", unknown, "top-right", boolean>;
    readonly showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "" | "error" | "primary" | "success" | "warning" | "info", unknown, "", boolean>;
    readonly zIndex: NumberConstructor;
    readonly closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type NotificationPropsPublic = __ExtractPublicPropTypes<typeof notificationProps>;
export declare type NotificationQueue = NotificationQueueItem[];
export declare interface NotificationQueueItem {
    vm: VNode;
}
export declare const notificationTypes: readonly [
    "primary",
    "success",
    "info",
    "warning",
    "error"
];
export declare interface Notify extends NotifyFn {
    primary: NotifyTypedFn;
    success: NotifyTypedFn;
    warning: NotifyTypedFn;
    error: NotifyTypedFn;
    info: NotifyTypedFn;
}
export declare interface NotifyFn {
    (options?: NotificationParams, appContext?: null | AppContext): NotificationHandle;
    closeAll(): void;
    updateOffsets(position?: NotificationOptions_2["position"]): void;
    _context: AppContext | null;
}
export declare type NotifyTypedFn = (options?: NotificationParamsTyped, appContext?: null | AppContext) => NotificationHandle;
/**
 * @deprecated stop to use null
 * @see {@link https://github.com/sindresorhus/meta/discussions/7}
 */
declare type Nullable<T> = T | null;
declare type onRowRenderedParams = {
    rowCacheStart: number;
    rowCacheEnd: number;
    rowVisibleStart: number;
    rowVisibleEnd: number;
};
declare type Option_2 = OptionCommon & {
    created?: boolean;
};
declare type Option_3 = Record<string, any> | string | number | boolean;
export declare type OptionBasic = {
    value: OptionValue;
    currentLabel: SelectOptionProxy["currentLabel"];
    isDisabled?: SelectOptionProxy["isDisabled"];
};
declare type OptionCommon = Record<string, any>;
declare interface OptionExposed {
    ns: unknown;
    id: unknown;
    containerKls: unknown;
    currentLabel: ComputedRef<string | number | boolean>;
    itemSelected: ComputedRef<boolean>;
    isDisabled: ComputedRef<boolean>;
    visible: Ref<boolean>;
    hover: Ref<boolean>;
    states: OptionStates;
    select: SelectContext;
    hoverItem: () => void;
    updateOption: (query: string) => void;
    selectOptionClick: () => void;
}
declare type OptionGroup = OptionCommon;
declare type OptionProps = ExtractPropTypes<typeof optionProps>;
declare const optionProps: {
    value: {
        readonly type: PropType<EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    label: {
        readonly type: PropType<EpPropMergeType<(NumberConstructor | StringConstructor)[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    created: BooleanConstructor;
    disabled: BooleanConstructor;
};
export { Options };
declare interface OptionStates {
    index: number;
    groupDisabled: boolean;
    visible: boolean;
    hover: boolean;
}
declare type OptionType = Option_2 | OptionGroup;
export declare type OptionV2Props = ExtractPropTypes<typeof optionV2Props>;
declare const optionV2Props: {
    readonly data: ArrayConstructor;
    readonly disabled: BooleanConstructor;
    readonly hovering: BooleanConstructor;
    readonly item: {
        readonly type: PropType<Option_2>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly index: NumberConstructor;
    readonly style: ObjectConstructor;
    readonly selected: BooleanConstructor;
    readonly created: BooleanConstructor;
};
declare type OptionValue = OptionProps["value"];
export declare type OverlayEmits = typeof overlayEmits;
export declare const overlayEmits: {
    click: (evt: MouseEvent) => boolean;
};
export declare type OverlayProps = ExtractPropTypes<typeof overlayProps>;
export declare const overlayProps: {
    readonly mask: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly customMaskEvent: BooleanConstructor;
    readonly overlayClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[] | Record<string, boolean>) | (() => string | string[] | Record<string, boolean>) | ((new (...args: any[]) => string | string[] | Record<string, boolean>) | (() => string | string[] | Record<string, boolean>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly zIndex: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty) | ((new (...args: any[]) => number | "-moz-initial" | "inherit" | "initial" | "revert" | "unset" | "auto") | (() => ZIndexProperty))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type OverlayPropsPublic = __ExtractPublicPropTypes<typeof overlayProps>;
export declare type PageHeaderEmits = typeof pageHeaderEmits;
export declare const pageHeaderEmits: {
    back: () => boolean;
};
export declare type PageHeaderInstance = InstanceType<typeof _default_62> & unknown;
export declare type PageHeaderProps = ExtractPropTypes<typeof pageHeaderProps>;
export declare const pageHeaderProps: {
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly title: StringConstructor;
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
};
export declare type PageHeaderPropsPublic = __ExtractPublicPropTypes<typeof pageHeaderProps>;
export declare type PaginationEmits = typeof paginationEmits;
export declare const paginationEmits: {
    "update:current-page": (val: number) => boolean;
    "update:page-size": (val: number) => boolean;
    "size-change": (val: number) => boolean;
    change: (currentPage: number, pageSize: number) => boolean;
    "current-change": (val: number) => boolean;
    "prev-click": (val: number) => boolean;
    "next-click": (val: number) => boolean;
};
export declare type PaginationProps = ExtractPropTypes<typeof paginationProps>;
export declare const paginationProps: {
    readonly pageSize: NumberConstructor;
    readonly defaultPageSize: NumberConstructor;
    readonly total: NumberConstructor;
    readonly pageCount: NumberConstructor;
    readonly pagerCount: EpPropFinalized<NumberConstructor, unknown, unknown, 7, boolean>;
    readonly currentPage: NumberConstructor;
    readonly defaultCurrentPage: NumberConstructor;
    readonly layout: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    readonly pageSizes: EpPropFinalized<(new (...args: any[]) => number[]) | (() => number[]) | ((new (...args: any[]) => number[]) | (() => number[]))[], unknown, unknown, () => [
        10,
        20,
        30,
        40,
        50,
        100
    ], boolean>;
    readonly popperClass: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly prevText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly prevIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly nextText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly nextIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly small: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly background: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly hideOnSinglePage: BooleanConstructor;
    readonly appendSizeTo: StringConstructor;
};
export declare type PaginationPropsPublic = __ExtractPublicPropTypes<typeof paginationProps>;
declare interface Params {
    excludeListeners?: boolean;
    excludeKeys?: ComputedRef<string[]>;
}
export declare const parseDate: (date: string | number | Date, format: string | undefined, lang: string) => dayjs_2.Dayjs | undefined;
export declare type PartialOptions = Partial<Options>;
/**
 * Type which collects all paths through a type
 *
 * 
 *
 * @see {@link FieldPath}
 */
declare type Path<T> = T extends ReadonlyArray<infer V> ? IsTuple<T> extends true ? {
    [K in TupleKey<T>]-?: PathImpl<Exclude<K, symbol>, T[K]>;
}[TupleKey<T>] : PathImpl<ArrayKey, V> : {
    [K in keyof T]-?: PathImpl<Exclude<K, symbol>, T[K]>;
}[keyof T];
/**
 * Helper type for recursively constructing paths through a type
 *
 * 
 */
declare type PathImpl<K extends string | number, V> = V extends Primitive | BrowserNativeObject ? `${K}` : `${K}` | `${K}.${Path<V>}`;
export declare const PICKER_BASE_INJECTION_KEY = "EP_PICKER_BASE";
export declare const PICKER_POPPER_OPTIONS_INJECTION_KEY = "ElPopperOptions";
export declare interface PickerOptions {
    isValidValue: (date: DayOrDays) => boolean;
    handleKeydownInput: (event: KeyboardEvent) => void;
    parseUserInput: (value: UserInput) => DayOrDays;
    formatToString: (value: DayOrDays) => UserInput;
    getRangeAvailableTime: (date: DayOrDays) => DayOrDays;
    getDefaultValue: () => DayOrDays;
    panelReady: boolean;
    handleClear: () => void;
    handleFocusPicker?: () => void;
}
export { Placement };
export declare type PopconfirmEmits = typeof popconfirmEmits;
export declare const popconfirmEmits: {
    /**
     * @description triggers when click confirm button
     */
    confirm: (e: MouseEvent) => boolean;
    /**
     * @description triggers when click cancel button
     */
    cancel: (e: MouseEvent) => boolean;
};
export declare type PopconfirmInstance = InstanceType<typeof _default_64> & unknown;
export declare type PopconfirmProps = ExtractPropTypes<typeof popconfirmProps>;
export declare const popconfirmProps: {
    readonly title: StringConstructor;
    readonly confirmButtonText: StringConstructor;
    readonly cancelButtonText: StringConstructor;
    readonly confirmButtonType: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
    readonly cancelButtonType: EpPropFinalized<StringConstructor, "" | "text" | "default" | "primary" | "success" | "warning" | "info" | "danger", unknown, "text", boolean>;
    readonly icon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly iconColor: EpPropFinalized<StringConstructor, unknown, unknown, "#f90", boolean>;
    readonly hideIcon: BooleanConstructor;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: BooleanConstructor;
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 150, boolean>;
};
export declare type PopconfirmPropsPublic = __ExtractPublicPropTypes<typeof popconfirmProps>;
export declare type PopoverEmits = typeof popoverEmits;
export declare const popoverEmits: {
    "update:visible": (value: boolean) => boolean;
    "before-enter": () => boolean;
    "before-leave": () => boolean;
    "after-enter": () => boolean;
    "after-leave": () => boolean;
};
export declare type PopoverInstance = InstanceType<typeof _default_115> & unknown;
export declare type PopoverProps = ExtractPropTypes<typeof popoverProps>;
export declare const popoverProps: {
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], unknown, unknown, "bottom", boolean>;
    readonly disabled: BooleanConstructor;
    readonly visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    readonly transition: StringConstructor;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly enterable: {
        readonly default: true;
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly effect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly title: StringConstructor;
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 150, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, undefined, boolean>;
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly "onUpdate:visible": {
        readonly type: PropType<(visible: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type PopoverPropsPublic = __ExtractPublicPropTypes<typeof popoverProps>;
export declare const POPPER_CONTENT_INJECTION_KEY: InjectionKey<ElPopperContentInjectionContext>;
export declare const POPPER_INJECTION_KEY: InjectionKey<ElPopperInjectionContext>;
export declare type PopperArrowInstance = InstanceType<typeof ElPopperArrow> & unknown;
export declare type PopperArrowProps = ExtractPropTypes<typeof popperArrowProps>;
export declare const popperArrowProps: {
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
};
export declare type PopperArrowPropsPublic = __ExtractPublicPropTypes<typeof popperArrowProps>;
export declare type PopperContentEmits = typeof popperContentEmits;
export declare const popperContentEmits: {
    mouseenter: (evt: MouseEvent) => boolean;
    mouseleave: (evt: MouseEvent) => boolean;
    focus: () => boolean;
    blur: () => boolean;
    close: () => boolean;
};
export declare type PopperContentInstance = InstanceType<typeof ElPopperContent> & unknown;
export declare type PopperContentProps = ExtractPropTypes<typeof popperContentProps>;
export declare const popperContentProps: {
    readonly ariaLabel: StringConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType) | ((new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly visible: BooleanConstructor;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType) | ((new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
};
export declare type PopperContentPropsPublic = __ExtractPublicPropTypes<typeof popperContentProps>;
export declare type PopperCoreConfigProps = ExtractPropTypes<typeof popperCoreConfigProps>;
export declare const popperCoreConfigProps: {
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
};
export declare type PopperCoreConfigPropsPublic = __ExtractPublicPropTypes<typeof popperCoreConfigProps>;
export declare type PopperEffect = typeof effects[number] | (string & NonNullable<unknown>);
export declare type PopperInstance = InstanceType<typeof _default_7> & unknown;
export declare type PopperProps = ExtractPropTypes<typeof popperProps>;
export declare const popperProps: {
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
};
export declare type PopperPropsPublic = __ExtractPublicPropTypes<typeof popperProps>;
export declare type PopperTrigger = typeof triggers[number];
export declare type PopperTriggerInstance = InstanceType<typeof ElPopperTrigger> & unknown;
export declare type PopperTriggerProps = typeof popperTriggerProps;
export declare const popperTriggerProps: {
    readonly virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly virtualTriggering: BooleanConstructor;
    readonly onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly open: BooleanConstructor;
};
declare function prev(): void;
declare type Primitive = null | undefined | string | number | boolean | symbol | bigint;
export declare type ProgressColor = {
    color: string;
    percentage: number;
};
export declare type ProgressFn = (percentage: number) => string;
export declare type ProgressInstance = InstanceType<typeof _default_65> & unknown;
export declare type ProgressProps = ExtractPropTypes<typeof progressProps>;
export declare const progressProps: {
    readonly type: EpPropFinalized<StringConstructor, "circle" | "line" | "dashboard", unknown, "line", boolean>;
    readonly percentage: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly status: EpPropFinalized<StringConstructor, "" | "success" | "warning" | "exception", unknown, "", boolean>;
    readonly indeterminate: BooleanConstructor;
    readonly duration: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly strokeWidth: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly strokeLinecap: EpPropFinalized<(new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>) | ((new (...args: any[]) => "inherit" | "round" | "butt" | "square") | (() => NonNullable<"inherit" | "round" | "butt" | "square" | undefined>))[], unknown, unknown, "round", boolean>;
    readonly textInside: BooleanConstructor;
    readonly width: EpPropFinalized<NumberConstructor, unknown, unknown, 126, boolean>;
    readonly showText: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly color: EpPropFinalized<(new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]) | ((new (...args: any[]) => string | ProgressFn | ProgressColor[]) | (() => string | ProgressFn | ProgressColor[]))[], unknown, unknown, "", boolean>;
    readonly striped: BooleanConstructor;
    readonly stripedFlow: BooleanConstructor;
    readonly format: EpPropFinalized<(new (...args: any[]) => ProgressFn) | (() => ProgressFn) | {
        (): ProgressFn;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => ProgressFn) | (() => ProgressFn) | {
        (): ProgressFn;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, (percentage: number) => string, boolean>;
};
export declare type ProgressPropsPublic = __ExtractPublicPropTypes<typeof progressProps>;
declare const _prop: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], never, never, null, false>;
export declare interface Props {
    label?: string;
    value?: string;
    disabled?: string;
}
declare const props: {
    loading: BooleanConstructor;
    data: {
        type: ArrayConstructor;
        required: true;
    };
    hoveringIndex: NumberConstructor;
    width: NumberConstructor;
};
declare interface Props_2 {
    label?: string;
    value?: string;
    disabled?: string;
    options?: string;
}
export declare type PropValidator<T> = (props: T) => void;
export declare const provideGlobalConfig: (config: MaybeRef<ConfigProviderContext>, app?: App, global?: boolean) => ComputedRef<Partial<ConfigProviderProps>> | undefined;
export declare type RadioButtonInstance = InstanceType<typeof _default_67> & unknown;
export declare type RadioButtonProps = ExtractPropTypes<typeof radioButtonProps>;
export declare const radioButtonProps: {
    readonly modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
};
export declare type RadioButtonPropsPublic = __ExtractPublicPropTypes<typeof radioButtonProps>;
export declare type RadioEmits = typeof radioEmits;
export declare const radioEmits: {
    "update:modelValue": (val: string | number | boolean | undefined) => val is string | number | boolean;
    change: (val: string | number | boolean | undefined) => val is string | number | boolean;
};
export declare interface RadioGroupContext extends RadioGroupProps {
    changeEvent: (val: RadioGroupProps["modelValue"]) => void;
}
export declare type RadioGroupEmits = typeof radioGroupEmits;
export declare const radioGroupEmits: {
    "update:modelValue": (val: string | number | boolean | undefined) => val is string | number | boolean;
    change: (val: string | number | boolean | undefined) => val is string | number | boolean;
};
export declare type RadioGroupInstance = InstanceType<typeof _default_68> & unknown;
export declare const radioGroupKey: InjectionKey<RadioGroupContext>;
export declare type RadioGroupProps = ExtractPropTypes<typeof radioGroupProps>;
export declare const radioGroupProps: {
    readonly ariaLabel: StringConstructor;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly modelValue: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor,
        BooleanConstructor
    ], unknown, unknown, undefined, boolean>;
    readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare type RadioGroupPropsPublic = __ExtractPublicPropTypes<typeof radioGroupProps>;
export declare type RadioInstance = InstanceType<typeof _default_66> & unknown;
export declare type RadioProps = ExtractPropTypes<typeof radioProps>;
export declare const radioProps: {
    readonly border: BooleanConstructor;
    readonly modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
};
export declare const radioPropsBase: {
    modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    label: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    value: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
};
export declare type RadioPropsPublic = __ExtractPublicPropTypes<typeof radioProps>;
export declare const rangeArr: (n: number) => number[];
export declare type RateEmits = typeof rateEmits;
export declare const rateEmits: {
    change: (value: number) => boolean;
    "update:modelValue": (value: number) => boolean;
};
export declare type RateInstance = InstanceType<typeof _default_69> & unknown;
export declare type RateProps = ExtractPropTypes<typeof rateProps>;
export declare const rateProps: {
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly lowThreshold: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly highThreshold: EpPropFinalized<NumberConstructor, unknown, unknown, 4, boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly colors: EpPropFinalized<(new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>) | ((new (...args: any[]) => string[] | Record<number, string>) | (() => string[] | Record<number, string>))[], unknown, unknown, () => [
        "",
        "",
        ""
    ], boolean>;
    readonly voidColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly disabledVoidColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icons: EpPropFinalized<(new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>) | ((new (...args: any[]) => (string | Component)[] | Record<number, string | Component>) | (() => (string | Component)[] | Record<number, string | Component>))[], unknown, unknown, () => [
        Component,
        Component,
        Component
    ], boolean>;
    readonly voidIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => Component, boolean>;
    readonly disabledVoidIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => Component, boolean>;
    readonly disabled: BooleanConstructor;
    readonly allowHalf: BooleanConstructor;
    readonly showText: BooleanConstructor;
    readonly showScore: BooleanConstructor;
    readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly texts: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => [
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
    ], boolean>;
    readonly scoreTemplate: EpPropFinalized<StringConstructor, unknown, unknown, "{value}", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clearable: BooleanConstructor;
};
export declare type RatePropsPublic = __ExtractPublicPropTypes<typeof rateProps>;
declare type ReferenceElement = ElementType | VirtualElement_2;
export declare type renderContent = (h: typeof h, option: TransferDataItem) => VNode | VNode[];
export declare interface RenderContentContext {
    _self: ComponentInternalInstance;
    node: Node_2;
    data: TreeNodeData;
    store: TreeStore;
}
export declare type RenderContentFunction = (h: hType, context: RenderContentContext) => VNode | VNode[];
declare type RenderExpanded<T extends DefaultRow> = ({ row, $index, store, expanded, }: RIS<T>) => VNode[] | undefined;
export declare type RenderLabel = (props: RenderLabelProps) => VNode | VNode[];
declare type RenderLabel_2 = (props: RenderLabelProps_2) => VNode | VNode[];
export declare interface RenderLabelProps {
    node: CascaderNode;
    data: CascaderOption;
}
declare interface RenderLabelProps_2 {
    node: CascaderNode;
    data: CascaderOption;
}
export declare interface RenderRowData<T extends DefaultRow> {
    store: Store<T>;
    _self: Table<T>;
    column: TableColumnCtx<T>;
    row: T;
    $index: number;
    cellIndex: number;
    treeNode?: TreeNode;
    expanded: boolean;
}
export declare const renderThumbStyle: ({ move, size, bar, }: Pick<ThumbProps, "move" | "size"> & {
    bar: (typeof BAR_MAP)[keyof typeof BAR_MAP];
}) => CSSProperties;
declare interface RepeatClickOptions {
    interval?: number;
    delay?: number;
    handler: (...args: unknown[]) => unknown;
}
export declare type ResetAfterIndex = (idx: number, forceUpdate: boolean) => void;
export declare type ResetAfterIndices = (indices: Indices, forceUpdate: boolean) => void;
declare function resetCurrentValue(): void;
export declare type Resolve = (dataList?: CascaderOption[]) => void;
declare type Resolve_2 = (dataList?: CascaderOption[]) => void;
/**
 * Extracts types via `ExtractPropTypes`, accepting `PropType<T>`, `XXXConstructor`, `never`...
 *
 *  `ExtractPropTypes`  `PropType<T>``XXXConstructor``never`...
 *
 * @example
 * ResolvePropType<BooleanConstructor> => boolean
 * ResolvePropType<PropType<T>> => T
 **/
declare type ResolvePropType<T> = IfNever<T, never, ExtractPropType<{
    type: WritableArray<T>;
    required: true;
}>>;
export declare type ResultInstance = InstanceType<typeof _default_70> & unknown;
export declare type ResultProps = ExtractPropTypes<typeof resultProps>;
export declare const resultProps: {
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly subTitle: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icon: EpPropFinalized<StringConstructor, "error" | "primary" | "success" | "warning" | "info", unknown, "info", boolean>;
};
export declare type ResultPropsPublic = __ExtractPublicPropTypes<typeof resultProps>;
export declare const RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
declare type RIS<T extends DefaultRow> = {
    row: T;
    $index: number;
    store: Store<T>;
    expanded: boolean;
};
export declare const roleTypes: readonly [
    "dialog",
    "grid",
    "group",
    "listbox",
    "menu",
    "navigation",
    "tooltip",
    "tree"
];
export declare const ROOT_COMMON_COLOR_INJECTION_KEY: InjectionKey<CommonColorContext>;
export declare const ROOT_COMMON_PICKER_INJECTION_KEY: InjectionKey<CommonPickerContext>;
export declare const ROOT_PICKER_INJECTION_KEY: InjectionKey<DatePickerContext>;
export declare const ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY = "ElIsDefaultFormat";
export declare const ROOT_TREE_INJECTION_KEY = "RootTree";
export declare interface RootTreeType {
    ctx: SetupContext<any>;
    props: TreeComponentProps;
    store: Ref<TreeStore>;
    root: Ref<Node_2>;
    currentNode: Ref<Node_2>;
    instance: ComponentInternalInstance;
}
export declare const RowAlign: readonly [
    "top",
    "middle",
    "bottom"
];
export declare type RowClassNameGetter<T> = (params: {
    columns: Column<T>[];
} & RowCommonParams) => string;
declare type RowCommonParams = {
    rowData: any;
    rowIndex: number;
};
declare interface RowContext {
    gutter: ComputedRef<number>;
}
export declare const rowContextKey: InjectionKey<RowContext>;
export declare type RowEventHandler = (params: RowEventHandlerParams) => void;
export declare type RowEventHandlerParams = {
    rowKey: KeyType_2;
    event: Event;
} & RowCommonParams;
export declare type RowEventHandlers = {
    onClick?: RowEventHandler;
    onContextmenu?: RowEventHandler;
    onDblclick?: RowEventHandler;
    onMouseenter?: RowEventHandler;
    onMouseleave?: RowEventHandler;
};
export declare type RowExpandHandler = (params: RowExpandParams) => void;
export declare type RowExpandParams = {
    expanded: boolean;
    rowKey: KeyType_2;
} & RowCommonParams;
export declare type RowHeightChangedParams = {
    rowKey: KeyType_2;
    height: number;
    rowIndex: number;
};
export declare type RowHeightChangeHandler = (row: RowHeightChangedParams, fixedDirection: boolean | FixedDirection | undefined) => void;
export declare type RowHoverHandler = (params: RowHoverParams) => void;
export declare type RowHoverParams = {
    event?: MouseEvent;
    hovered: boolean;
    rowKey: KeyType_2;
} & Partial<RowCommonParams>;
export declare type RowInstance = InstanceType<typeof _default_71> & unknown;
export declare const RowJustify: readonly [
    "start",
    "center",
    "end",
    "space-around",
    "space-between",
    "space-evenly"
];
export declare type RowProps = ExtractPropTypes<typeof rowProps>;
export declare const rowProps: {
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly gutter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly justify: EpPropFinalized<StringConstructor, "center" | "space-around" | "space-between" | "space-evenly" | "end" | "start", unknown, "start", boolean>;
    readonly align: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "top" | "bottom" | "middle", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type RowPropsPublic = __ExtractPublicPropTypes<typeof rowProps>;
export declare type RTLOffsetType = "negative" | "positive-descending" | "positive-ascending";
export declare const SCOPE = "use-empty-values";
export declare interface ScrollbarContext {
    scrollbarElement: HTMLDivElement;
    wrapElement: HTMLDivElement;
}
export declare const scrollbarContextKey: InjectionKey<ScrollbarContext>;
export declare type ScrollbarDirection = "top" | "bottom" | "left" | "right";
export declare type ScrollbarEmits = typeof scrollbarEmits;
export declare const scrollbarEmits: {
    "end-reached": (direction: ScrollbarDirection) => boolean;
    scroll: ({ scrollTop, scrollLeft, }: {
        scrollTop: number;
        scrollLeft: number;
    }) => boolean;
};
export declare type ScrollbarExpose = {
    onMouseUp: () => void;
};
export declare type ScrollbarInstance = InstanceType<typeof _default_72> & unknown;
export declare type ScrollbarProps = ExtractPropTypes<typeof scrollbarProps>;
export declare const scrollbarProps: {
    readonly ariaLabel: StringConstructor;
    readonly ariaOrientation: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly distance: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly height: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly maxHeight: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly native: BooleanConstructor;
    readonly wrapStyle: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly wrapClass: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown, "", boolean>;
    readonly viewClass: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor
    ], unknown, unknown, "", boolean>;
    readonly viewStyle: EpPropFinalized<readonly [
        StringConstructor,
        ArrayConstructor,
        ObjectConstructor
    ], unknown, unknown, "", boolean>;
    readonly noresize: BooleanConstructor;
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "div", boolean>;
    readonly always: BooleanConstructor;
    readonly minSize: EpPropFinalized<NumberConstructor, unknown, unknown, 20, boolean>;
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, undefined, boolean>;
    readonly id: StringConstructor;
    readonly role: StringConstructor;
};
export declare type ScrollbarPropsPublic = __ExtractPublicPropTypes<typeof scrollbarProps>;
export declare type ScrollDir = "forwards" | "backwards";
declare type ScrollPos = {
    scrollLeft: number;
    scrollTop: number;
};
declare function scrollTo_2(xCord: number, yCord?: number): void;
declare function scrollTo_2(options: ScrollToOptions): void;
export declare type SegmentedEmits = typeof segmentedEmits;
export declare const segmentedEmits: {
    "update:modelValue": (val: any) => val is string | number | boolean;
    change: (val: any) => val is string | number | boolean;
};
export declare type SegmentedInstance = InstanceType<typeof _default_108> & unknown;
export declare type SegmentedProps = ExtractPropTypes<typeof segmentedProps>;
export declare const segmentedProps: {
    ariaLabel: StringConstructor;
    direction: EpPropFinalized<(new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical") | ((new (...args: any[]) => "horizontal" | "vertical") | (() => "horizontal" | "vertical"))[], unknown, unknown, string, boolean>;
    options: EpPropFinalized<(new (...args: any[]) => Option_3[]) | (() => Option_3[]) | ((new (...args: any[]) => Option_3[]) | (() => Option_3[]))[], unknown, unknown, () => never[], boolean>;
    modelValue: EpPropFinalized<(BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
    props: EpPropFinalized<(new (...args: any[]) => Props) | (() => Props) | ((new (...args: any[]) => Props) | (() => Props))[], unknown, unknown, () => Required<Props>, boolean>;
    block: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    disabled: BooleanConstructor;
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    id: StringConstructor;
    name: StringConstructor;
};
export declare type SegmentedPropsPublic = __ExtractPublicPropTypes<typeof segmentedProps>;
export declare interface SelectContext {
    props: SelectProps;
    states: SelectStates;
    selectRef: HTMLElement | undefined;
    optionsArray: SelectOptionProxy[];
    setSelected(): void;
    onOptionCreate(vm: SelectOptionProxy): void;
    onOptionDestroy(key: OptionValue, vm: SelectOptionProxy): void;
    handleOptionSelect(vm: SelectOptionProxy): void;
}
declare interface SelectDropdownExposed {
    listRef: Ref<FixedSizeListInstance | DynamicSizeListInstance | undefined>;
    isSized: ComputedRef<boolean>;
    isItemDisabled: (modelValue: any[] | any, selected: boolean) => boolean;
    isItemHovering: (target: number) => boolean;
    isItemSelected: (modelValue: any[] | any, target: Option_2) => boolean;
    scrollToItem: (index: number) => void;
    resetScrollTop: () => void;
}
declare type SelectDropdownInstance = ComponentPublicInstance<ExtractPropTypes<typeof props>, SelectDropdownExposed>;
export declare type SelectEmits = EmitFn<typeof selectEmits>;
export declare const selectEmits: {
    "update:modelValue": (val: SelectProps["modelValue"]) => boolean;
    change: (val: SelectProps["modelValue"]) => boolean;
    "popup-scroll": ({ scrollTop, scrollLeft, }: {
        scrollTop: number;
        scrollLeft: number;
    }) => boolean;
    "remove-tag": (val: unknown) => boolean;
    "visible-change": (visible: boolean) => boolean;
    focus: (evt: FocusEvent) => boolean;
    blur: (evt: FocusEvent) => boolean;
    clear: () => boolean;
};
declare interface SelectGroupContext {
    disabled: boolean;
}
export declare const selectGroupKey: InjectionKey<SelectGroupContext>;
export declare type SelectInstance = InstanceType<typeof _default_74> & unknown;
export declare const selectKey: InjectionKey<SelectContext>;
export declare type SelectOptionProps = Props_2;
export declare type SelectOptionProxy = ComponentPublicInstance<OptionProps, OptionExposed>;
export declare type SelectProps = ExtractPropTypes<typeof selectProps>;
export declare const selectProps: {
    ariaLabel: StringConstructor;
    emptyValues: ArrayConstructor;
    valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    name: StringConstructor;
    id: StringConstructor;
    modelValue: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null) | ((new (...args: any[]) => string | number | boolean | Record<string, any> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[]) | (() => EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown> | EpPropMergeType<(ObjectConstructor | BooleanConstructor | NumberConstructor | StringConstructor)[], unknown, unknown>[] | null))[], unknown, unknown, undefined, boolean>;
    autocomplete: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    automaticDropdown: BooleanConstructor;
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, string, boolean>;
    disabled: BooleanConstructor;
    clearable: BooleanConstructor;
    filterable: BooleanConstructor;
    allowCreate: BooleanConstructor;
    loading: BooleanConstructor;
    popperClass: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties) | (() => string | CSSProperties) | ((new (...args: any[]) => string | CSSProperties) | (() => string | CSSProperties))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    remote: BooleanConstructor;
    loadingText: StringConstructor;
    noMatchText: StringConstructor;
    noDataText: StringConstructor;
    remoteMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    filterMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    multiple: BooleanConstructor;
    multipleLimit: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    defaultFirstOption: BooleanConstructor;
    reserveKeyword: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    valueKey: EpPropFinalized<StringConstructor, unknown, unknown, string, boolean>;
    collapseTags: BooleanConstructor;
    collapseTagsTooltip: BooleanConstructor;
    maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    fitInputWidth: BooleanConstructor;
    suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagType: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    tagEffect: {
        default: string;
        type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        required: false;
        validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    remoteShowSuffix: BooleanConstructor;
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, string, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, string[], boolean>;
    tabindex: EpPropFinalized<(NumberConstructor | StringConstructor)[], unknown, unknown, number, boolean>;
    appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    options: {
        readonly type: PropType<Record<string, any>[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    props: EpPropFinalized<(new (...args: any[]) => Props_2) | (() => Props_2) | ((new (...args: any[]) => Props_2) | (() => Props_2))[], unknown, unknown, () => Required<Props_2>, boolean>;
};
export declare type SelectPropsPublic = __ExtractPublicPropTypes<typeof selectProps>;
declare type SelectStates = {
    inputValue: string;
    options: Map<OptionValue, SelectOptionProxy>;
    cachedOptions: Map<OptionValue, SelectOptionProxy>;
    optionValues: OptionValue[];
    selected: OptionBasic[];
    hoveringIndex: number;
    inputHovering: boolean;
    selectionWidth: number;
    collapseItemWidth: number;
    previousQuery: string | null;
    selectedLabel: string;
    menuVisibleOnFocus: boolean;
    isBeforeHide: boolean;
};
declare type SelectStates_2 = {
    inputValue: string;
    cachedOptions: Option_2[];
    createdOptions: Option_2[];
    hoveringIndex: number;
    inputHovering: boolean;
    selectionWidth: number;
    collapseItemWidth: number;
    previousQuery: string | null;
    previousValue: unknown;
    selectedLabel: string;
    menuVisibleOnFocus: boolean;
    isBeforeHide: boolean;
};
export declare interface SelectV2Context {
    props: SelectV2Props;
    expanded: Ref<boolean>;
    tooltipRef: Ref<TooltipInstance | undefined>;
    onSelect: (option: Option_2) => void;
    onHover: (idx?: number) => void;
    onKeyboardNavigate: (direction: "forward" | "backward") => void;
    onKeyboardSelect: () => void;
}
export declare const selectV2InjectionKey: InjectionKey<SelectV2Context>;
export declare type SelectV2Instance = InstanceType<typeof _default_77> & unknown;
export declare type SelectV2Props = ExtractPropTypes<typeof selectV2Props>;
declare const selectV2Props: {
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly allowCreate: BooleanConstructor;
    readonly autocomplete: EpPropFinalized<(new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list") | ((new (...args: any[]) => "none" | "both" | "inline" | "list") | (() => "none" | "both" | "inline" | "list"))[], unknown, unknown, "none", boolean>;
    readonly automaticDropdown: BooleanConstructor;
    readonly clearable: BooleanConstructor;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "light", boolean>;
    readonly collapseTags: BooleanConstructor;
    readonly collapseTagsTooltip: BooleanConstructor;
    readonly maxCollapseTags: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly defaultFirstOption: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly estimatedOptionHeight: EpPropFinalized<NumberConstructor, unknown, unknown, undefined, boolean>;
    readonly filterable: BooleanConstructor;
    readonly filterMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: EpPropFinalized<NumberConstructor, unknown, unknown, 274, boolean>;
    readonly itemHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 34, boolean>;
    readonly id: StringConstructor;
    readonly loading: BooleanConstructor;
    readonly loadingText: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => any) | (() => any) | {
        (): any;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => any) | (() => any) | {
        (): any;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly multiple: BooleanConstructor;
    readonly multipleLimit: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly name: StringConstructor;
    readonly noDataText: StringConstructor;
    readonly noMatchText: StringConstructor;
    readonly remoteMethod: {
        readonly type: PropType<(query: string) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly reserveKeyword: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly options: {
        readonly type: PropType<OptionType[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => Partial<Options>, boolean>;
    readonly remote: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly props: EpPropFinalized<(new (...args: any[]) => Props_2) | (() => Props_2) | ((new (...args: any[]) => Props_2) | (() => Props_2))[], unknown, unknown, () => Required<Props_2>, boolean>;
    readonly valueKey: EpPropFinalized<StringConstructor, unknown, unknown, "value", boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom-start", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom-start",
        "top-start",
        "right",
        "left"
    ], boolean>;
    readonly tagType: {
        readonly default: "info";
        readonly type: PropType<EpPropMergeType<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tagEffect: {
        readonly default: "light";
        readonly type: PropType<EpPropMergeType<StringConstructor, "dark" | "light" | "plain", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly tabindex: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, 0, boolean>;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fitInputWidth: EpPropFinalized<readonly [
        BooleanConstructor,
        NumberConstructor
    ], unknown, number | boolean, true, boolean>;
    readonly suffixIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
declare function setActiveItem(index: number): void;
declare function setCurrentValue(value: number, event?: MouseEvent): void;
declare type SFCInstallWithContext<T> = SFCWithInstall<T> & {
    _context: AppContext | null;
};
declare type SFCWithInstall<T> = T & Plugin_2;
export declare type SharedExposes = {
    windowRef: Ref<HTMLElement>;
    innerRef: Ref<HTMLElement>;
    getItemStyleCache: (_: any, __: any, ___: any) => CSSProperties;
};
declare function show(): void;
export declare type SingleOrRange<T> = T | [
    T,
    T
];
export declare const SIZE_INJECTION_KEY: InjectionKey<SizeContext>;
export declare interface SizeContext {
    size: Ref<ComponentSize>;
}
export declare type SkeletonInstance = InstanceType<typeof _default_78> & unknown;
export declare type SkeletonItemInstance = InstanceType<typeof _default_79> & unknown;
export declare type SkeletonItemProps = ExtractPropTypes<typeof skeletonItemProps>;
export declare const skeletonItemProps: {
    readonly variant: EpPropFinalized<StringConstructor, "button" | "caption" | "h1" | "h3" | "p" | "circle" | "image" | "rect" | "text", unknown, "text", boolean>;
};
export declare type SkeletonItemPropsPublic = __ExtractPublicPropTypes<typeof skeletonItemProps>;
export declare type SkeletonProps = ExtractPropTypes<typeof skeletonProps>;
export declare const skeletonProps: {
    readonly animated: BooleanConstructor;
    readonly count: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly rows: EpPropFinalized<NumberConstructor, unknown, unknown, 3, boolean>;
    readonly loading: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly throttle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | {
            leading?: number;
            trailing?: number;
            initVal?: boolean;
        }) | (() => ThrottleType) | ((new (...args: any[]) => number | {
            leading?: number;
            trailing?: number;
            initVal?: boolean;
        }) | (() => ThrottleType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type SkeletonPropsPublic = __ExtractPublicPropTypes<typeof skeletonProps>;
export declare interface SliderContext extends ToRefs<SliderProps> {
    precision: ComputedRef<number>;
    sliderSize: Ref<number>;
    emitChange: () => void;
    resetSize: () => void;
    updateDragging: (val: boolean) => void;
}
export declare const sliderContextKey: InjectionKey<SliderContext>;
export declare type SliderEmits = typeof sliderEmits;
export declare const sliderEmits: {
    "update:modelValue": (value: Arrayable<number>) => value is number | number[];
    input: (value: Arrayable<number>) => value is number | number[];
    change: (value: Arrayable<number>) => value is number | number[];
};
export declare interface SliderInitData {
    firstValue: number;
    secondValue: number;
    oldValue?: Arrayable<number>;
    dragging: boolean;
    sliderSize: number;
}
export declare type SliderInstance = InstanceType<typeof _default_80> & unknown;
declare type SliderMarkerProps = ExtractPropTypes<typeof sliderMarkerProps>;
declare const sliderMarkerProps: {
    readonly mark: EpPropFinalized<(new (...args: any[]) => string | {
        style: CSSProperties;
        label: any;
    }) | (() => string | {
        style: CSSProperties;
        label: any;
    }) | ((new (...args: any[]) => string | {
        style: CSSProperties;
        label: any;
    }) | (() => string | {
        style: CSSProperties;
        label: any;
    }))[], unknown, unknown, undefined, boolean>;
};
declare type SliderMarks = Record<number, string | SliderMarkerProps["mark"]>;
export declare type SliderProps = ExtractPropTypes<typeof sliderProps>;
export declare const sliderProps: {
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => Arrayable<number>) | ((new (...args: any[]) => number | number[]) | (() => Arrayable<number>))[], unknown, unknown, 0, boolean>;
    readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly min: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly max: EpPropFinalized<NumberConstructor, unknown, unknown, 100, boolean>;
    readonly step: EpPropFinalized<NumberConstructor, unknown, unknown, 1, boolean>;
    readonly showInput: BooleanConstructor;
    readonly showInputControls: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly inputSize: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showStops: BooleanConstructor;
    readonly showTooltip: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly formatTooltip: EpPropFinalized<(new (...args: any[]) => (val: number) => number | string) | (() => (val: number) => number | string) | {
        (): (val: number) => number | string;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (val: number) => number | string) | (() => (val: number) => number | string) | {
        (): (val: number) => number | string;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly disabled: BooleanConstructor;
    readonly range: BooleanConstructor;
    readonly vertical: BooleanConstructor;
    readonly height: StringConstructor;
    readonly debounce: EpPropFinalized<NumberConstructor, unknown, unknown, 300, boolean>;
    readonly rangeStartLabel: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly rangeEndLabel: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly formatValueText: EpPropFinalized<(new (...args: any[]) => (val: number) => string) | (() => (val: number) => string) | {
        (): (val: number) => string;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (val: number) => string) | (() => (val: number) => string) | {
        (): (val: number) => string;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, undefined, boolean>;
    readonly tooltipClass: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "top", boolean>;
    readonly marks: {
        readonly type: PropType<SliderMarks>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly persistent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare type SliderPropsPublic = __ExtractPublicPropTypes<typeof sliderProps>;
export declare interface Sort {
    prop: string;
    order: TableSortOrder;
    init?: any;
    silent?: any;
}
export declare type SortBy = {
    key: KeyType_2;
    order: TableV2SortOrder;
};
export declare type SortState = {
    [key: KeyType_2]: TableV2SortOrder;
};
declare const Space: DefineComponent<{
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly class: EpPropFinalized<(new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>) | ((new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>))[], unknown, unknown, "", boolean>;
    readonly style: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly alignment: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "center", boolean>;
    readonly prefixCls: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly spacer: EpPropFinalized<(new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild) | ((new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild))[], unknown, string | number | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }>, null, boolean>;
    readonly wrap: BooleanConstructor;
    readonly fill: BooleanConstructor;
    readonly fillRatio: EpPropFinalized<NumberConstructor, unknown, unknown, 100, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            ArrayConstructor,
            NumberConstructor
        ], "" | "small" | "default" | "large", number | [
            number,
            number
        ]>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => string | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | {
    [name: string]: unknown;
    $stable?: boolean;
} | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly class: EpPropFinalized<(new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>) | ((new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>))[], unknown, unknown, "", boolean>;
    readonly style: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly alignment: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "center", boolean>;
    readonly prefixCls: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly spacer: EpPropFinalized<(new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild) | ((new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild))[], unknown, string | number | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }>, null, boolean>;
    readonly wrap: BooleanConstructor;
    readonly fill: BooleanConstructor;
    readonly fillRatio: EpPropFinalized<NumberConstructor, unknown, unknown, 100, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            ArrayConstructor,
            NumberConstructor
        ], "" | "small" | "default" | "large", number | [
            number,
            number
        ]>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly style: StyleValue;
    readonly spacer: EpPropMergeType<(new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild) | ((new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild))[], unknown, string | number | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }>>;
    readonly fill: boolean;
    readonly direction: EpPropMergeType<StringConstructor, "horizontal" | "vertical", unknown>;
    readonly wrap: boolean;
    readonly class: EpPropMergeType<(new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>) | ((new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>))[], unknown, unknown>;
    readonly alignment: string;
    readonly fillRatio: number;
}>;
export declare type SpaceInstance = InstanceType<typeof Space> & unknown;
declare const SpaceItem: DefineComponent<{
    readonly prefixCls: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly prefixCls: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {}>;
export declare type SpaceItemInstance = InstanceType<typeof SpaceItem> & unknown;
export declare type SpaceItemProps = ExtractPropTypes<typeof spaceItemProps>;
export declare const spaceItemProps: {
    readonly prefixCls: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type SpaceItemPropsPublic = __ExtractPublicPropTypes<typeof spaceItemProps>;
export declare type SpaceProps = ExtractPropTypes<typeof spaceProps>;
export declare const spaceProps: {
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly class: EpPropFinalized<(new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>) | ((new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>))[], unknown, unknown, "", boolean>;
    readonly style: EpPropFinalized<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown, "", boolean>;
    readonly alignment: EpPropFinalized<(new (...args: any[]) => string) | (() => string) | ((new (...args: any[]) => string) | (() => string))[], unknown, unknown, "center", boolean>;
    readonly prefixCls: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly spacer: EpPropFinalized<(new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild) | ((new (...args: any[]) => VNodeChild & {}) | (() => VNodeChild))[], unknown, string | number | VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }>, null, boolean>;
    readonly wrap: BooleanConstructor;
    readonly fill: BooleanConstructor;
    readonly fillRatio: EpPropFinalized<NumberConstructor, unknown, unknown, 100, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            ArrayConstructor,
            NumberConstructor
        ], "" | "small" | "default" | "large", number | [
            number,
            number
        ]>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type SpacePropsPublic = __ExtractPublicPropTypes<typeof spaceProps>;
export declare type SplitterInstance = InstanceType<typeof _default_110> & unknown;
export declare type SplitterPanelInstance = InstanceType<typeof _default_111> & unknown;
export declare type SplitterPanelProps = ExtractPropTypes<typeof splitterPanelProps>;
export declare const splitterPanelProps: {
    readonly min: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly max: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly size: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly resizable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly collapsible: BooleanConstructor;
};
export declare type SplitterPanelPropsPublic = __ExtractPublicPropTypes<typeof splitterPanelProps>;
export declare type SplitterProps = ExtractPropTypes<typeof splitterProps>;
export declare const splitterProps: {
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly lazy: BooleanConstructor;
};
export declare type SplitterPropsPublic = __ExtractPublicPropTypes<typeof splitterProps>;
export declare type StatisticInstance = InstanceType<typeof _default_81> & unknown;
export declare type StatisticProps = ExtractPropTypes<typeof statisticProps>;
export declare const statisticProps: {
    readonly decimalSeparator: EpPropFinalized<StringConstructor, unknown, unknown, ".", boolean>;
    readonly groupSeparator: EpPropFinalized<StringConstructor, unknown, unknown, ",", boolean>;
    readonly precision: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly formatter: FunctionConstructor;
    readonly value: EpPropFinalized<(new (...args: any[]) => number | Dayjs) | (() => number | Dayjs) | ((new (...args: any[]) => number | Dayjs) | (() => number | Dayjs))[], unknown, unknown, 0, boolean>;
    readonly prefix: StringConstructor;
    readonly suffix: StringConstructor;
    readonly title: StringConstructor;
    readonly valueStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type StatisticPropsPublic = __ExtractPublicPropTypes<typeof statisticProps>;
export declare type StepInstance = InstanceType<typeof _default_83> & unknown;
export declare type StepProps = ExtractPropTypes<typeof stepProps>;
export declare const stepProps: {
    readonly title: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly description: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly status: EpPropFinalized<StringConstructor, "" | "wait" | "error" | "finish" | "success" | "process", unknown, "", boolean>;
};
export declare type StepPropsPublic = __ExtractPublicPropTypes<typeof stepProps>;
export declare const STEPS_INJECTION_KEY = "ElSteps";
export declare type StepsEmits = typeof stepsEmits;
export declare const stepsEmits: {
    change: (newVal: number, oldVal: number) => boolean;
};
export declare type StepsInstance = InstanceType<typeof _default_82> & unknown;
export declare type StepsProps = ExtractPropTypes<typeof stepsProps>;
export declare const stepsProps: {
    readonly space: EpPropFinalized<readonly [
        NumberConstructor,
        StringConstructor
    ], unknown, unknown, "", boolean>;
    readonly active: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "horizontal" | "vertical", unknown, "horizontal", boolean>;
    readonly alignCenter: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly simple: {
        readonly type: PropType<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly finishStatus: EpPropFinalized<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown, "finish", boolean>;
    readonly processStatus: EpPropFinalized<StringConstructor, "wait" | "error" | "finish" | "success" | "process", unknown, "process", boolean>;
};
export declare type StepsPropsPublic = __ExtractPublicPropTypes<typeof stepsProps>;
declare type Store<T extends DefaultRow> = HelperStore<T>["Return"];
declare type StoreFilter = Record<string, string[]>;
export declare const SUB_MENU_INJECTION_KEY = "subMenu:";
export declare type SubMenuInstance = InstanceType<typeof _default_61> & unknown;
export declare type SubMenuProps = ExtractPropTypes<typeof subMenuProps>;
export declare const subMenuProps: {
    readonly index: {
        readonly type: PropType<string>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showTimeout: NumberConstructor;
    readonly hideTimeout: NumberConstructor;
    readonly popperClass: StringConstructor;
    readonly disabled: BooleanConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly popperOffset: NumberConstructor;
    readonly expandCloseIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandOpenIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly collapseCloseIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly collapseOpenIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type SubMenuPropsPublic = __ExtractPublicPropTypes<typeof subMenuProps>;
export declare interface SubMenuProvider {
    addSubMenu: (item: MenuItemRegistered) => void;
    removeSubMenu: (item: MenuItemRegistered) => void;
    handleMouseleave?: (deepDispatch: boolean) => void;
    mouseInChild: Ref<boolean>;
    level: number;
}
export declare type SummaryMethod<T extends DefaultRow> = (data: {
    columns: TableColumnCtx<T>[];
    data: T[];
}) => (string | VNode)[];
export declare type SwitchEmits = typeof switchEmits;
export declare const switchEmits: {
    "update:modelValue": (val: boolean | string | number) => boolean;
    change: (val: boolean | string | number) => boolean;
    input: (val: boolean | string | number) => boolean;
};
export declare type SwitchInstance = InstanceType<typeof _default_84> & unknown;
export declare type SwitchProps = ExtractPropTypes<typeof switchProps>;
export declare const switchProps: {
    readonly ariaLabel: StringConstructor;
    readonly modelValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, false, boolean>;
    readonly disabled: BooleanConstructor;
    readonly loading: BooleanConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "small" | "default" | "large") | (() => "" | "small" | "default" | "large") | ((new (...args: any[]) => "" | "small" | "default" | "large") | (() => "" | "small" | "default" | "large"))[], unknown, "" | "small" | "default" | "large">>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly width: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly inlinePrompt: BooleanConstructor;
    readonly inactiveActionIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeActionIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly inactiveIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly activeText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly inactiveText: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly activeValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, true, boolean>;
    readonly inactiveValue: EpPropFinalized<readonly [
        BooleanConstructor,
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, false, boolean>;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly beforeChange: {
        readonly type: PropType<() => Promise<boolean> | boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly tabindex: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type SwitchPropsPublic = __ExtractPublicPropTypes<typeof switchProps>;
export declare type TabBarInstance = InstanceType<typeof _default_88> & unknown;
export declare type TabBarProps = ExtractPropTypes<typeof tabBarProps>;
export declare const tabBarProps: {
    readonly tabs: EpPropFinalized<(new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | ((new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly tabRefs: EpPropFinalized<(new (...args: any[]) => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | (() => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | ((new (...args: any[]) => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }) | (() => {
        [key: string]: HTMLDivElement;
        [key: number]: HTMLDivElement;
    }))[], unknown, unknown, () => Mutable<{}>, boolean>;
};
export declare type TabBarPropsPublic = __ExtractPublicPropTypes<typeof tabBarProps>;
export declare interface Table<T extends DefaultRow = any> extends ComponentInternalInstance {
    $ready: boolean;
    hoverState?: HoverState<T> | null;
    renderExpanded: RenderExpanded<T>;
    store: Store<T>;
    layout: TableLayout<T>;
    refs: TableRefs;
    tableId: string;
    state: TableState;
}
export declare type TableColumnCtx<T extends DefaultRow = DefaultRow> = {
    id: string;
    realWidth: number | null;
    type: string;
    label: string;
    className: string;
    labelClassName: string;
    property: string;
    prop: string;
    width?: string | number;
    minWidth: string | number;
    renderHeader: (data: CI<T>) => VNode;
    sortable: boolean | string;
    sortMethod: (a: T, b: T) => number;
    sortBy: string | ((row: T, index: number, array?: T[]) => string) | string[];
    resizable: boolean;
    columnKey: string;
    rawColumnKey: string;
    align: string;
    headerAlign: string;
    showOverflowTooltip?: boolean | TableOverflowTooltipOptions;
    tooltipFormatter?: TableOverflowTooltipFormatter<T>;
    fixed: boolean | string;
    formatter: (row: T, column: TableColumnCtx<T>, cellValue: any, index: number) => VNode | string;
    selectable: (row: T, index: number) => boolean;
    reserveSelection: boolean;
    filterMethod: FilterMethods<T>;
    filteredValue: string[];
    filters: Filters;
    filterPlacement: string;
    filterMultiple: boolean;
    filterClassName: string;
    index: number | ((index: number) => number);
    sortOrders: (TableSortOrder | null)[];
    renderCell: (data: any) => VNode | VNode[];
    colSpan: number;
    rowSpan: number;
    children?: TableColumnCtx<T>[];
    level: number;
    filterable: boolean | FilterMethods<T> | Filters;
    order: TableSortOrder | null;
    isColumnGroup: boolean;
    isSubColumn: boolean;
    columns: TableColumnCtx<T>[];
    getColumnIndex: () => number;
    no: number;
    filterOpened?: boolean;
    renderFilterIcon?: (scope: any) => VNode;
    renderExpand?: (scope: any) => VNode;
};
export declare type TableColumnInstance = InstanceType<typeof _default_86> & unknown;
declare const TableGrid: DefineComponent<{
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly data: {
        readonly type: PropType<any[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fixedData: {
        readonly type: PropType<any[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly default: undefined;
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly width: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerWidth: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerHeight: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown, 50, boolean>;
    readonly bodyWidth: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowHeight: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly useIsScrolling: BooleanConstructor;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly class: StringConstructor;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly getRowHeight: {
        readonly type: PropType<ItemSize>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowKey: EpPropFinalized<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown, "id", boolean>;
    readonly onRowsRendered: {
        readonly type: PropType<(params: onRowRenderedParams) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onScroll: {
        readonly type: PropType<(...args: any[]) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly data: {
        readonly type: PropType<any[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fixedData: {
        readonly type: PropType<any[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly default: undefined;
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly width: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerWidth: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerHeight: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown, 50, boolean>;
    readonly bodyWidth: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowHeight: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly useIsScrolling: BooleanConstructor;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly class: StringConstructor;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly containerStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly getRowHeight: {
        readonly type: PropType<ItemSize>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowKey: EpPropFinalized<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown, "id", boolean>;
    readonly onRowsRendered: {
        readonly type: PropType<(params: onRowRenderedParams) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onScroll: {
        readonly type: PropType<(...args: any[]) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly rowKey: EpPropMergeType<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly cache: number;
    readonly estimatedRowHeight: number;
    readonly scrollbarStartGap: number;
    readonly scrollbarEndGap: number;
    readonly headerHeight: EpPropMergeType<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown>;
}>;
declare type TableGridInstance = InstanceType<typeof TableGrid> & UnwrapRef<{
    forceUpdate: () => void;
    /**
     * @description fetch total height
     */
    totalHeight: number;
    /**
     * @description scrollTo a position
     * @param { number | ScrollToOptions } arg1
     * @param { number } arg2
     */
    scrollTo(leftOrOptions: number | GridScrollOptions, top?: number): void;
    /**
     * @description scroll vertically to position y
     */
    scrollToTop(scrollTop: number): void;
    /**
     * @description scroll to a given row
     * @params row {Number} which row to scroll to
     * @params @optional strategy {ScrollStrategy} use what strategy to scroll to
     */
    scrollToRow(row: number, strategy: Alignment): void;
    /**
     * @description reset rendered state after row index
     * @param { number } rowIndex
     * @param { boolean } forceUpdate
     */
    resetAfterRowIndex: ResetAfterIndex;
}>;
declare interface TableHeader extends ComponentInternalInstance {
    state: {
        onColumnsChange: (layout: TableLayout<any>) => void;
        onScrollableChange: (layout: TableLayout<any>) => void;
    };
    filterPanels: Ref<DefaultRow>;
}
export declare type TableInstance = InstanceType<typeof _default_85> & unknown;
declare class TableLayout<T extends DefaultRow> {
    observers: TableHeader[];
    table: Table<T>;
    store: Store<T>;
    columns: TableColumnCtx<T>[];
    fit: boolean;
    showHeader: boolean;
    height: Ref<null | number>;
    scrollX: Ref<boolean>;
    scrollY: Ref<boolean>;
    bodyWidth: Ref<null | number>;
    fixedWidth: Ref<null | number>;
    rightFixedWidth: Ref<null | number>;
    tableHeight: Ref<null | number>;
    headerHeight: Ref<null | number>;
    appendHeight: Ref<null | number>;
    footerHeight: Ref<null | number>;
    gutterWidth: number;
    constructor(options: Record<string, any>);
    updateScrollY(): boolean;
    setHeight(value: string | number | null, prop?: string): void;
    setMaxHeight(value: string | number | null): void;
    getFlattenColumns(): TableColumnCtx<T>[];
    updateElsHeight(): void;
    headerDisplayNone(elm: HTMLElement): boolean;
    updateColumnsWidth(): void;
    addObserver(observer: TableHeader): void;
    removeObserver(observer: TableHeader): void;
    notifyObservers(event: string): void;
}
declare type TableOverflowTooltipFormatter<T extends DefaultRow> = (data: {
    row: T;
    column: TableColumnCtx<T>;
    cellValue: any;
}) => VNode | string;
declare type TableOverflowTooltipOptions = Partial<Pick<ElTooltipProps, "appendTo" | "effect" | "enterable" | "hideAfter" | "offset" | "placement" | "popperClass" | "popperOptions" | "showAfter" | "showArrow" | "transition">>;
export declare interface TableProps<T extends DefaultRow> {
    data: T[];
    size?: ComponentSize;
    width?: string | number;
    height?: string | number;
    maxHeight?: string | number;
    fit?: boolean;
    stripe?: boolean;
    border?: boolean;
    rowKey?: string | ((row: T) => string);
    context?: Table<T>;
    showHeader?: boolean;
    showSummary?: boolean;
    sumText?: string;
    summaryMethod?: SummaryMethod<T>;
    rowClassName?: ColumnCls<T>;
    rowStyle?: ColumnStyle<T>;
    cellClassName?: CellCls<T>;
    cellStyle?: CellStyle<T>;
    headerRowClassName?: ColumnCls<T>;
    headerRowStyle?: ColumnStyle<T>;
    headerCellClassName?: CellCls<T>;
    headerCellStyle?: CellStyle<T>;
    highlightCurrentRow?: boolean;
    currentRowKey?: string | number;
    emptyText?: string;
    expandRowKeys?: Array<string>;
    defaultExpandAll?: boolean;
    defaultSort?: Sort;
    tooltipEffect?: string;
    tooltipOptions?: TableOverflowTooltipOptions;
    spanMethod?: (data: {
        row: T;
        rowIndex: number;
        column: TableColumnCtx<T>;
        columnIndex: number;
    }) => number[] | {
        rowspan: number;
        colspan: number;
    } | undefined;
    selectOnIndeterminate?: boolean;
    indent?: number;
    treeProps?: TreeProps;
    lazy?: boolean;
    load?: (row: T, treeNode: TreeNode, resolve: (data: T[]) => void) => void;
    className?: string;
    style?: CSSProperties;
    tableLayout?: Layout;
    scrollbarAlwaysOn?: boolean;
    flexible?: boolean;
    showOverflowTooltip?: boolean | TableOverflowTooltipOptions;
    tooltipFormatter?: TableOverflowTooltipFormatter<T>;
    appendFilterPanelTo?: string;
    scrollbarTabindex?: number | string;
    nativeScrollbar?: boolean;
}
export declare interface TableRefs {
    tableWrapper: HTMLElement;
    headerWrapper: HTMLElement;
    footerWrapper: HTMLElement;
    fixedBodyWrapper: HTMLElement;
    rightFixedBodyWrapper: HTMLElement;
    bodyWrapper: HTMLElement;
    appendWrapper: HTMLElement;
    [key: string]: any;
}
declare type TableSortOrder = "ascending" | "descending";
declare interface TableState {
    isGroup: Ref<boolean>;
    resizeState: Ref<{
        width: any;
        height: any;
    }>;
    doLayout: () => void;
    debouncedUpdateLayout: () => void;
}
export declare type TableTooltipData<T extends DefaultRow> = Parameters<TableOverflowTooltipFormatter<T>>[0];
export declare const TableV2: DefineComponent<{
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedRowHeight: {
        readonly default: undefined;
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly rowKey: EpPropFinalized<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown, "id", boolean>;
    readonly headerClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HeaderClassNameGetter<any>) | (() => string | HeaderClassNameGetter<any>) | ((new (...args: any[]) => string | HeaderClassNameGetter<any>) | (() => string | HeaderClassNameGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerCellProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerHeight: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown, 50, boolean>;
    readonly footerHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly rowClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | RowClassNameGetter<any>) | (() => string | RowClassNameGetter<any>) | ((new (...args: any[]) => string | RowClassNameGetter<any>) | (() => string | RowClassNameGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 50, boolean>;
    readonly cellProps: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | ExtraCellPropGetter<any>) | (() => Record<string, any> | ExtraCellPropGetter<any>) | ((new (...args: any[]) => Record<string, any> | ExtraCellPropGetter<any>) | (() => Record<string, any> | ExtraCellPropGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly data: {
        readonly type: PropType<any[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly dataGetter: {
        readonly type: PropType<DataGetter<any>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fixedData: {
        readonly type: PropType<any[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandColumnKey: StringConstructor;
    readonly expandedRowKeys: EpPropFinalized<(new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]) | ((new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]))[], unknown, unknown, () => never[], boolean>;
    readonly defaultExpandedRowKeys: EpPropFinalized<(new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]) | ((new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]))[], unknown, unknown, () => never[], boolean>;
    readonly class: StringConstructor;
    readonly fixed: BooleanConstructor;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly width: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly maxHeight: NumberConstructor;
    readonly useIsScrolling: BooleanConstructor;
    readonly indentSize: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly iconSize: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly sortBy: EpPropFinalized<(new (...args: any[]) => SortBy) | (() => SortBy) | ((new (...args: any[]) => SortBy) | (() => SortBy))[], unknown, unknown, () => {
        key: KeyType_2;
        order: TableV2SortOrder;
    }, boolean>;
    readonly sortState: EpPropFinalized<(new (...args: any[]) => SortState) | (() => SortState) | ((new (...args: any[]) => SortState) | (() => SortState))[], unknown, unknown, undefined, boolean>;
    readonly onColumnSort: {
        readonly type: PropType<ColumnSortHandler<any>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onExpandedRowsChange: {
        readonly type: PropType<ExpandedRowsChangeHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onEndReached: {
        readonly type: PropType<(remainDistance: number) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowExpand: {
        readonly type: PropType<RowExpandHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onScroll: {
        readonly type: PropType<(...args: any[]) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowsRendered: {
        readonly type: PropType<(params: onRowRenderedParams) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowEventHandlers: {
        readonly type: PropType<RowEventHandlers>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedRowHeight: {
        readonly default: undefined;
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly rowKey: EpPropFinalized<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown, "id", boolean>;
    readonly headerClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HeaderClassNameGetter<any>) | (() => string | HeaderClassNameGetter<any>) | ((new (...args: any[]) => string | HeaderClassNameGetter<any>) | (() => string | HeaderClassNameGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerCellProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerHeight: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown, 50, boolean>;
    readonly footerHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly rowClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | RowClassNameGetter<any>) | (() => string | RowClassNameGetter<any>) | ((new (...args: any[]) => string | RowClassNameGetter<any>) | (() => string | RowClassNameGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 50, boolean>;
    readonly cellProps: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | ExtraCellPropGetter<any>) | (() => Record<string, any> | ExtraCellPropGetter<any>) | ((new (...args: any[]) => Record<string, any> | ExtraCellPropGetter<any>) | (() => Record<string, any> | ExtraCellPropGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly data: {
        readonly type: PropType<any[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly dataGetter: {
        readonly type: PropType<DataGetter<any>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fixedData: {
        readonly type: PropType<any[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandColumnKey: StringConstructor;
    readonly expandedRowKeys: EpPropFinalized<(new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]) | ((new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]))[], unknown, unknown, () => never[], boolean>;
    readonly defaultExpandedRowKeys: EpPropFinalized<(new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]) | ((new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]))[], unknown, unknown, () => never[], boolean>;
    readonly class: StringConstructor;
    readonly fixed: BooleanConstructor;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly width: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly maxHeight: NumberConstructor;
    readonly useIsScrolling: BooleanConstructor;
    readonly indentSize: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly iconSize: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly sortBy: EpPropFinalized<(new (...args: any[]) => SortBy) | (() => SortBy) | ((new (...args: any[]) => SortBy) | (() => SortBy))[], unknown, unknown, () => {
        key: KeyType_2;
        order: TableV2SortOrder;
    }, boolean>;
    readonly sortState: EpPropFinalized<(new (...args: any[]) => SortState) | (() => SortState) | ((new (...args: any[]) => SortState) | (() => SortState))[], unknown, unknown, undefined, boolean>;
    readonly onColumnSort: {
        readonly type: PropType<ColumnSortHandler<any>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onExpandedRowsChange: {
        readonly type: PropType<ExpandedRowsChangeHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onEndReached: {
        readonly type: PropType<(remainDistance: number) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowExpand: {
        readonly type: PropType<RowExpandHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onScroll: {
        readonly type: PropType<(...args: any[]) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowsRendered: {
        readonly type: PropType<(params: onRowRenderedParams) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowEventHandlers: {
        readonly type: PropType<RowEventHandlers>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>>, {
    readonly fixed: boolean;
    readonly rowKey: EpPropMergeType<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown>;
    readonly useIsScrolling: boolean;
    readonly scrollbarAlwaysOn: boolean;
    readonly cache: number;
    readonly estimatedRowHeight: number;
    readonly rowHeight: number;
    readonly hScrollbarSize: number;
    readonly vScrollbarSize: number;
    readonly sortBy: SortBy;
    readonly headerHeight: EpPropMergeType<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown>;
    readonly footerHeight: number;
    readonly indentSize: number;
    readonly iconSize: number;
    readonly sortState: SortState;
    readonly expandedRowKeys: KeyType_2[];
    readonly defaultExpandedRowKeys: KeyType_2[];
}>;
export declare enum TableV2Alignment {
    CENTER = "center",
    RIGHT = "right"
}
export declare type TableV2CustomizedHeaderSlotParam<T = any> = {
    cells: VNode[];
    columns: Columns<T>;
    headerIndex: number;
};
export declare enum TableV2FixedDir {
    LEFT = "left",
    RIGHT = "right"
}
declare type TableV2HeaderRowCellRendererParams = {
    columns: TableV2HeaderRowProps["columns"];
    column: TableV2HeaderRowProps["columns"][number];
    columnIndex: number;
    headerIndex: number;
    style: CSSProperties;
};
declare type TableV2HeaderRowProps = ExtractPropTypes<typeof tableV2HeaderRowProps>;
declare const tableV2HeaderRowProps: {
    readonly class: StringConstructor;
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly columnsStyles: {
        readonly type: PropType<Record<KeyType_2, CSSProperties>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerIndex: NumberConstructor;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type TableV2Instance = InstanceType<typeof TableV2> & {
    /**
     * @description scroll to a given position
     * @params params {{ scrollLeft?: number, scrollTop?: number }} where to scroll to.
     */
    scrollTo: (param: {
        scrollLeft?: number;
        scrollTop?: number;
    }) => void;
    /**
     * @description scroll to a given position horizontally
     * @params scrollLeft {Number} where to scroll to.
     */
    scrollToLeft: (scrollLeft: number) => void;
    /**
     * @description scroll to a given position vertically
     * @params scrollTop { Number } where to scroll to.
     */
    scrollToTop: (scrollTop: number) => void;
    /**
     * @description scroll to a given row
     * @params row {Number} which row to scroll to
     * @params strategy {ScrollStrategy} use what strategy to scroll to
     */
    scrollToRow(row: number, strategy?: Alignment): void;
};
export declare const TableV2Placeholder: unique symbol;
export declare type TableV2Props = ExtractPropTypes<typeof tableV2Props>;
export declare const tableV2Props: {
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedRowHeight: {
        readonly default: undefined;
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly rowKey: EpPropFinalized<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown, "id", boolean>;
    readonly headerClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HeaderClassNameGetter<any>) | (() => string | HeaderClassNameGetter<any>) | ((new (...args: any[]) => string | HeaderClassNameGetter<any>) | (() => string | HeaderClassNameGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerCellProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly headerHeight: EpPropFinalized<(new (...args: any[]) => number | number[]) | (() => number | number[]) | ((new (...args: any[]) => number | number[]) | (() => number | number[]))[], unknown, unknown, 50, boolean>;
    readonly footerHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly rowClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | RowClassNameGetter<any>) | (() => string | RowClassNameGetter<any>) | ((new (...args: any[]) => string | RowClassNameGetter<any>) | (() => string | RowClassNameGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowProps: {
        readonly type: PropType<any>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowHeight: EpPropFinalized<NumberConstructor, unknown, unknown, 50, boolean>;
    readonly cellProps: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | ExtraCellPropGetter<any>) | (() => Record<string, any> | ExtraCellPropGetter<any>) | ((new (...args: any[]) => Record<string, any> | ExtraCellPropGetter<any>) | (() => Record<string, any> | ExtraCellPropGetter<any>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly data: {
        readonly type: PropType<any[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly dataGetter: {
        readonly type: PropType<DataGetter<any>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly fixedData: {
        readonly type: PropType<any[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly expandColumnKey: StringConstructor;
    readonly expandedRowKeys: EpPropFinalized<(new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]) | ((new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]))[], unknown, unknown, () => never[], boolean>;
    readonly defaultExpandedRowKeys: EpPropFinalized<(new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]) | ((new (...args: any[]) => KeyType_2[]) | (() => KeyType_2[]))[], unknown, unknown, () => never[], boolean>;
    readonly class: StringConstructor;
    readonly fixed: BooleanConstructor;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly width: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly height: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly maxHeight: NumberConstructor;
    readonly useIsScrolling: BooleanConstructor;
    readonly indentSize: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly iconSize: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly sortBy: EpPropFinalized<(new (...args: any[]) => SortBy) | (() => SortBy) | ((new (...args: any[]) => SortBy) | (() => SortBy))[], unknown, unknown, () => {
        key: KeyType_2;
        order: TableV2SortOrder;
    }, boolean>;
    readonly sortState: EpPropFinalized<(new (...args: any[]) => SortState) | (() => SortState) | ((new (...args: any[]) => SortState) | (() => SortState))[], unknown, unknown, undefined, boolean>;
    readonly onColumnSort: {
        readonly type: PropType<ColumnSortHandler<any>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onExpandedRowsChange: {
        readonly type: PropType<ExpandedRowsChangeHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onEndReached: {
        readonly type: PropType<(remainDistance: number) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowExpand: {
        readonly type: PropType<RowExpandHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onScroll: {
        readonly type: PropType<(...args: any[]) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowsRendered: {
        readonly type: PropType<(params: onRowRenderedParams) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowEventHandlers: {
        readonly type: PropType<RowEventHandlers>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type TableV2PropsPublic = __ExtractPublicPropTypes<typeof tableV2Props>;
export declare type TableV2RowProps = ExtractPropTypes<typeof tableV2RowProps>;
export declare const tableV2RowProps: {
    readonly class: StringConstructor;
    readonly columns: {
        readonly type: PropType<AnyColumn[]>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly columnsStyles: {
        readonly type: PropType<Record<KeyType_2, CSSProperties>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly depth: NumberConstructor;
    readonly expandColumnKey: StringConstructor;
    readonly estimatedRowHeight: {
        readonly default: undefined;
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        readonly __epPropKey: true;
    };
    readonly isScrolling: BooleanConstructor;
    readonly onRowExpand: {
        readonly type: PropType<RowExpandHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowHover: {
        readonly type: PropType<RowHoverHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRowHeightChange: {
        readonly type: PropType<RowHeightChangeHandler>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowData: {
        readonly type: PropType<any>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowEventHandlers: {
        readonly type: PropType<RowEventHandlers>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowIndex: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly rowKey: EpPropFinalized<(new (...args: any[]) => string | number | symbol) | (() => KeyType_2) | ((new (...args: any[]) => string | number | symbol) | (() => KeyType_2))[], unknown, unknown, "id", boolean>;
    readonly style: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type TableV2RowPropsPublic = __ExtractPublicPropTypes<typeof tableV2RowProps>;
export declare enum TableV2SortOrder {
    ASC = "asc",
    DESC = "desc"
}
declare const TabNav: DefineComponent<{
    readonly panes: EpPropFinalized<(new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | ((new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly currentName: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly editable: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "" | "card" | "border-card", unknown, "", boolean>;
    readonly stretch: BooleanConstructor;
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    tabClick: (tab: TabsPaneContext, tabName: TabPaneName, ev: Event) => boolean;
    tabRemove: (tab: TabsPaneContext, ev: Event) => boolean;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly panes: EpPropFinalized<(new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | ((new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly currentName: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly editable: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "" | "card" | "border-card", unknown, "", boolean>;
    readonly stretch: BooleanConstructor;
}>> & {
    onTabClick?: ((tab: {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }, tabName: TabPaneName, ev: Event) => any) | undefined;
    onTabRemove?: ((tab: {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }, ev: Event) => any) | undefined;
}, {
    readonly stretch: boolean;
    readonly type: EpPropMergeType<StringConstructor, "" | "card" | "border-card", unknown>;
    readonly editable: boolean;
    readonly panes: {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[];
    readonly currentName: EpPropMergeType<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown>;
}>;
export declare type TabNavEmits = typeof tabNavEmits;
export declare const tabNavEmits: {
    tabClick: (tab: TabsPaneContext, tabName: TabPaneName, ev: Event) => boolean;
    tabRemove: (tab: TabsPaneContext, ev: Event) => boolean;
};
export declare type TabNavInstance = InstanceType<typeof TabNav> & {
    scrollToActiveTab: () => Promise<void>;
    removeFocus: () => void;
    focusActiveTab: () => void;
    scheduleRender: () => void;
    tabListRef: HTMLDivElement | undefined;
    tabBarRef: TabBarInstance | undefined;
};
export declare type TabNavProps = ExtractPropTypes<typeof tabNavProps>;
export declare const tabNavProps: {
    readonly panes: EpPropFinalized<(new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | ((new (...args: any[]) => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]) | (() => {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly currentName: EpPropFinalized<readonly [
        StringConstructor,
        NumberConstructor
    ], unknown, unknown, "", boolean>;
    readonly editable: BooleanConstructor;
    readonly type: EpPropFinalized<StringConstructor, "" | "card" | "border-card", unknown, "", boolean>;
    readonly stretch: BooleanConstructor;
};
export declare type TabNavPropsPublic = __ExtractPublicPropTypes<typeof tabNavProps>;
export declare type TabPaneInstance = InstanceType<typeof _default_87> & unknown;
export declare type TabPaneName = string | number;
export declare type TabPaneProps = ExtractPropTypes<typeof tabPaneProps>;
export declare const tabPaneProps: {
    readonly label: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly name: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly closable: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly lazy: BooleanConstructor;
};
export declare type TabPanePropsPublic = __ExtractPublicPropTypes<typeof tabPaneProps>;
declare const Tabs: DefineComponent<{
    readonly type: EpPropFinalized<StringConstructor, "" | "card" | "border-card", unknown, "", boolean>;
    readonly closable: BooleanConstructor;
    readonly addable: BooleanConstructor;
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: BooleanConstructor;
    readonly tabPosition: EpPropFinalized<StringConstructor, "top" | "bottom" | "left" | "right", unknown, "top", boolean>;
    readonly beforeLeave: EpPropFinalized<(new (...args: any[]) => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | (() => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | {
        (): (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | (() => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | {
        (): (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    readonly stretch: BooleanConstructor;
}, () => JSX.Element, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (name: TabPaneName) => name is string | number;
    tabClick: (pane: TabsPaneContext, ev: Event) => boolean;
    tabChange: (name: TabPaneName) => name is string | number;
    edit: (paneName: TabPaneName | undefined, action: "remove" | "add") => boolean;
    tabRemove: (name: TabPaneName) => name is string | number;
    tabAdd: () => boolean;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly type: EpPropFinalized<StringConstructor, "" | "card" | "border-card", unknown, "", boolean>;
    readonly closable: BooleanConstructor;
    readonly addable: BooleanConstructor;
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: BooleanConstructor;
    readonly tabPosition: EpPropFinalized<StringConstructor, "top" | "bottom" | "left" | "right", unknown, "top", boolean>;
    readonly beforeLeave: EpPropFinalized<(new (...args: any[]) => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | (() => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | {
        (): (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | (() => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | {
        (): (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    readonly stretch: BooleanConstructor;
}>> & {
    "onUpdate:modelValue"?: ((name: TabPaneName) => any) | undefined;
    onTabClick?: ((pane: {
        uid: number;
        getVnode: () => VNode;
        slots: Slots;
        props: {
            readonly label: string;
            readonly disabled: boolean;
            readonly closable: boolean;
            readonly lazy: boolean;
            readonly name?: EpPropMergeType<readonly [
                StringConstructor,
                NumberConstructor
            ], unknown, unknown> | undefined;
        };
        paneName: TabPaneName | undefined;
        active: boolean;
        index: string | undefined;
        isClosable: boolean;
        isFocusInsidePane: () => boolean | undefined;
    }, ev: Event) => any) | undefined;
    onTabRemove?: ((name: TabPaneName) => any) | undefined;
    onTabChange?: ((name: TabPaneName) => any) | undefined;
    onEdit?: ((paneName: TabPaneName | undefined, action: "add" | "remove") => any) | undefined;
    onTabAdd?: (() => any) | undefined;
}, {
    readonly stretch: boolean;
    readonly type: EpPropMergeType<StringConstructor, "" | "card" | "border-card", unknown>;
    readonly closable: boolean;
    readonly beforeLeave: (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
    readonly editable: boolean;
    readonly tabPosition: EpPropMergeType<StringConstructor, "top" | "bottom" | "left" | "right", unknown>;
    readonly addable: boolean;
}>;
export declare type TabsEmits = typeof tabsEmits;
export declare const tabsEmits: {
    "update:modelValue": (name: TabPaneName) => name is string | number;
    tabClick: (pane: TabsPaneContext, ev: Event) => boolean;
    tabChange: (name: TabPaneName) => name is string | number;
    edit: (paneName: TabPaneName | undefined, action: "remove" | "add") => boolean;
    tabRemove: (name: TabPaneName) => name is string | number;
    tabAdd: () => boolean;
};
export declare type TabsInstance = InstanceType<typeof Tabs> & {
    currentName: TabPaneName;
    tabNavRef: TabNavInstance | undefined;
};
export declare type TabsPaneContext = UnwrapRef<{
    uid: number;
    getVnode: () => VNode;
    slots: Slots;
    props: TabPaneProps;
    paneName: ComputedRef<TabPaneName | undefined>;
    active: ComputedRef<boolean>;
    index: Ref<string | undefined>;
    isClosable: ComputedRef<boolean>;
    isFocusInsidePane: () => boolean | undefined;
}>;
export declare type TabsPanes = Record<number, TabsPaneContext>;
export declare type TabsProps = ExtractPropTypes<typeof tabsProps>;
export declare const tabsProps: {
    readonly type: EpPropFinalized<StringConstructor, "" | "card" | "border-card", unknown, "", boolean>;
    readonly closable: BooleanConstructor;
    readonly addable: BooleanConstructor;
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: BooleanConstructor;
    readonly tabPosition: EpPropFinalized<StringConstructor, "top" | "bottom" | "left" | "right", unknown, "top", boolean>;
    readonly beforeLeave: EpPropFinalized<(new (...args: any[]) => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | (() => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | {
        (): (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | (() => (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>) | {
        (): (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => true, boolean>;
    readonly stretch: BooleanConstructor;
};
export declare type TabsPropsPublic = __ExtractPublicPropTypes<typeof tabsProps>;
export declare interface TabsRootContext {
    props: TabsProps;
    currentName: Ref<TabPaneName>;
    registerPane: (pane: TabsPaneContext) => void;
    unregisterPane: (pane: TabsPaneContext) => void;
    nav$: Ref<TabNavInstance | undefined>;
}
export declare const tabsRootContextKey: InjectionKey<TabsRootContext>;
export declare interface Tag {
    node?: CascaderNode;
    key: number;
    text: string;
    hitState?: boolean;
    closable: boolean;
    isCollapseTag: boolean;
}
export declare type TagEmits = typeof tagEmits;
export declare const tagEmits: {
    close: (evt: MouseEvent) => boolean;
    click: (evt: MouseEvent) => boolean;
};
export declare type TagInstance = InstanceType<typeof _default_89> & unknown;
export declare type TagProps = ExtractPropTypes<typeof tagProps>;
export declare const tagProps: {
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "primary", boolean>;
    readonly closable: BooleanConstructor;
    readonly disableTransitions: BooleanConstructor;
    readonly hit: BooleanConstructor;
    readonly color: StringConstructor;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<StringConstructor, "dark" | "light" | "plain", unknown, "light", boolean>;
    readonly round: BooleanConstructor;
};
export declare type TagPropsPublic = __ExtractPublicPropTypes<typeof tagProps>;
export declare type TextProps = ExtractPropTypes<typeof textProps>;
export declare const textProps: {
    readonly type: EpPropFinalized<StringConstructor, "" | "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly size: EpPropFinalized<StringConstructor, "" | "small" | "default" | "large", unknown, "", boolean>;
    readonly truncated: BooleanConstructor;
    readonly lineClamp: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly tag: EpPropFinalized<StringConstructor, unknown, unknown, "span", boolean>;
};
export declare type TextPropsPublic = __ExtractPublicPropTypes<typeof textProps>;
export declare type ThrottleType = {
    leading?: number;
    trailing?: number;
    initVal?: boolean;
} | number;
export declare type ThumbInstance = InstanceType<typeof _default_73> & unknown;
export declare type ThumbProps = ExtractPropTypes<typeof thumbProps>;
export declare const thumbProps: {
    readonly vertical: BooleanConstructor;
    readonly size: StringConstructor;
    readonly move: NumberConstructor;
    readonly ratio: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly always: BooleanConstructor;
};
export declare type ThumbPropsPublic = __ExtractPublicPropTypes<typeof thumbProps>;
declare const Timeline: DefineComponent<{}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
export declare const TIMELINE_INJECTION_KEY = "timeline";
export declare type TimelineInstance = InstanceType<typeof Timeline> & unknown;
export declare type TimelineItemInstance = InstanceType<typeof _default_93> & unknown;
export declare type TimelineItemProps = ExtractPropTypes<typeof timelineItemProps>;
export declare const timelineItemProps: {
    readonly timestamp: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly hideTimestamp: BooleanConstructor;
    readonly center: BooleanConstructor;
    readonly placement: EpPropFinalized<StringConstructor, "top" | "bottom", unknown, "bottom", boolean>;
    readonly type: EpPropFinalized<StringConstructor, "primary" | "success" | "warning" | "info" | "danger", unknown, "", boolean>;
    readonly color: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly size: EpPropFinalized<StringConstructor, "normal" | "large", unknown, "normal", boolean>;
    readonly icon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hollow: BooleanConstructor;
};
export declare type TimelineItemPropsPublic = __ExtractPublicPropTypes<typeof timelineItemProps>;
export declare type TimeList = [
    number | undefined,
    number,
    undefined | number
];
export declare type TimePickerDefaultProps = ExtractPropTypes<typeof timePickerDefaultProps>;
export declare const timePickerDefaultProps: {
    readonly showNow: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showConfirm: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showFooter: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly showWeekNumber: BooleanConstructor;
    readonly ariaLabel: StringConstructor;
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly disabledDate: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly cellClassName: {
        readonly type: PropType<Function>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly shortcuts: EpPropFinalized<ArrayConstructor, unknown, unknown, () => never[], boolean>;
    readonly arrowControl: BooleanConstructor;
    readonly tabindex: EpPropFinalized<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown, 0, boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly unlinkPanels: BooleanConstructor;
    readonly placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "auto" | "auto-start" | "auto-end" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement))[], Placement, unknown, "bottom", boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, readonly [
        "bottom",
        "top",
        "right",
        "left"
    ], boolean>;
    readonly disabledHours: {
        readonly type: PropType<GetDisabledHours>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledMinutes: {
        readonly type: PropType<GetDisabledMinutes>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabledSeconds: {
        readonly type: PropType<GetDisabledSeconds>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>) | ((new (...args: any[]) => string | [
            string,
            string
        ]) | (() => SingleOrRange<string>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly format: StringConstructor;
    readonly valueFormat: StringConstructor;
    readonly dateFormat: StringConstructor;
    readonly timeFormat: StringConstructor;
    readonly type: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly clearIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, "", boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly readonly: BooleanConstructor;
    readonly disabled: BooleanConstructor;
    readonly placeholder: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null) | ((new (...args: any[]) => string | number | Date | string[] | [
        DateModelType,
        DateModelType
    ]) | (() => ModelValueType | null))[], unknown, unknown, "", boolean>;
    readonly rangeSeparator: EpPropFinalized<StringConstructor, unknown, unknown, "-", boolean>;
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly defaultValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>) | ((new (...args: any[]) => Date | [
            Date,
            Date
        ]) | (() => SingleOrRange<Date>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly isRange: BooleanConstructor;
};
export declare type TimePickerDefaultPropsPublic = __ExtractPublicPropTypes<typeof timePickerDefaultProps>;
export declare const timePickerRangeTriggerProps: {
    readonly id: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string | null,
            string | null
        ]) | (() => UserInput) | ((new (...args: any[]) => string | [
            string | null,
            string | null
        ]) | (() => UserInput))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly disabled: BooleanConstructor;
};
/**
 * @deprecated Use `timePickerRangeTriggerProps` instead. This will be removed in future versions.
 */
export declare const timePickerRngeTriggerProps: {
    readonly id: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly name: {
        readonly type: PropType<string[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | [
            string | null,
            string | null
        ]) | (() => UserInput) | ((new (...args: any[]) => string | [
            string | null,
            string | null
        ]) | (() => UserInput))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly startPlaceholder: StringConstructor;
    readonly endPlaceholder: StringConstructor;
    readonly disabled: BooleanConstructor;
};
export declare const TimePickPanel: DefineComponent<{
    readonly datetimeRole: StringConstructor;
    readonly parsedValue: {
        readonly type: PropType<dayjs_2.Dayjs>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly visible: BooleanConstructor;
    readonly actualVisible: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
}, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "select-range": (...args: any[]) => void;
    pick: (...args: any[]) => void;
    "set-picker-option": (...args: any[]) => void;
}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    readonly datetimeRole: StringConstructor;
    readonly parsedValue: {
        readonly type: PropType<dayjs_2.Dayjs>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly visible: BooleanConstructor;
    readonly actualVisible: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
}>> & {
    onPick?: ((...args: any[]) => any) | undefined;
    "onSelect-range"?: ((...args: any[]) => any) | undefined;
    "onSet-picker-option"?: ((...args: any[]) => any) | undefined;
}, {
    readonly visible: boolean;
    readonly format: string;
    readonly actualVisible: EpPropMergeType<BooleanConstructor, unknown, unknown>;
}>;
export declare type TimeSelectInstance = InstanceType<typeof _default_92> & unknown;
export declare type TimeSelectProps = ExtractPropTypes<typeof timeSelectProps>;
export declare const timeSelectProps: {
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
    readonly format: EpPropFinalized<StringConstructor, unknown, unknown, "HH:mm", boolean>;
    readonly modelValue: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly disabled: BooleanConstructor;
    readonly editable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "light", boolean>;
    readonly clearable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly placeholder: StringConstructor;
    readonly start: EpPropFinalized<StringConstructor, unknown, unknown, "09:00", boolean>;
    readonly end: EpPropFinalized<StringConstructor, unknown, unknown, "18:00", boolean>;
    readonly step: EpPropFinalized<StringConstructor, unknown, unknown, "00:30", boolean>;
    readonly minTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly maxTime: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string) | (() => string | null) | ((new (...args: any[]) => string) | (() => string | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly includeEndTime: BooleanConstructor;
    readonly name: StringConstructor;
    readonly prefixIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
    readonly clearIcon: EpPropFinalized<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown, () => any, boolean>;
};
export declare type TimeSelectPropsPublic = __ExtractPublicPropTypes<typeof timeSelectProps>;
export declare type TimeUnit = typeof timeUnits[number];
export declare const timeUnits: readonly [
    "hours",
    "minutes",
    "seconds"
];
declare function toggleMode(): void;
export declare const TOOLTIP_INJECTION_KEY: InjectionKey<ElTooltipInjectionContext>;
export declare type TooltipContentInstance = InstanceType<typeof _default_8> & unknown;
export declare const tooltipEmits: string[];
export declare type TooltipInstance = InstanceType<typeof _default_6> & unknown;
export declare type TooltipTriggerType = "hover" | "focus" | "click" | "contextmenu";
export declare type TourBtnProps = {
    children?: VNode | string;
    onClick?: () => void;
} & Partial<ButtonProps> & Record<string, any>;
export declare type TourContentEmits = typeof tourContentEmits;
export declare const tourContentEmits: {
    close: () => boolean;
};
export declare type TourContentProps = ExtractPropTypes<typeof tourContentProps>;
export declare const tourContentProps: {
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_3) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_3))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    reference: EpPropFinalized<(new (...args: any[]) => HTMLElement | VirtualElement) | (() => HTMLElement | VirtualElement | null) | ((new (...args: any[]) => HTMLElement | VirtualElement) | (() => HTMLElement | VirtualElement | null))[], unknown, unknown, null, boolean>;
    strategy: EpPropFinalized<(new (...args: any[]) => "fixed" | "absolute") | (() => Strategy) | ((new (...args: any[]) => "fixed" | "absolute") | (() => Strategy))[], "fixed" | "absolute", unknown, string, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    showArrow: BooleanConstructor;
    zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
};
export declare type TourContentPropsPublic = __ExtractPublicPropTypes<typeof tourContentProps>;
export declare type TourEmits = typeof tourEmits;
export declare const tourEmits: {
    "update:modelValue": (value: boolean) => boolean;
    "update:current": (current: number) => boolean;
    close: (current: number) => boolean;
    finish: () => boolean;
    change: (current: number) => boolean;
};
export declare interface TourGap {
    offset?: number | [
        number,
        number
    ];
    radius?: number;
}
export declare type TourInstance = InstanceType<typeof _default_104> & unknown;
export declare type TourMask = boolean | {
    style?: CSSProperties;
    color?: string;
};
export declare const tourPlacements: readonly [
    "top-start",
    "top-end",
    "top",
    "bottom-start",
    "bottom-end",
    "bottom",
    "left-start",
    "left-end",
    "left",
    "right-start",
    "right-end",
    "right"
];
export declare type TourProps = ExtractPropTypes<typeof tourProps>;
export declare const tourProps: {
    modelValue: BooleanConstructor;
    current: EpPropFinalized<NumberConstructor, unknown, unknown, number, boolean>;
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    contentStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    mask: EpPropFinalized<(new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask) | ((new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask))[], unknown, unknown, boolean, boolean>;
    gap: EpPropFinalized<(new (...args: any[]) => TourGap) | (() => TourGap) | ((new (...args: any[]) => TourGap) | (() => TourGap))[], unknown, unknown, () => {
        offset: number;
        radius: number;
    }, boolean>;
    zIndex: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, () => {
        block: string;
    }, boolean>;
    type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "default" | "primary") | (() => "default" | "primary") | ((new (...args: any[]) => "default" | "primary") | (() => "default" | "primary"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    appendTo: EpPropFinalized<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown, string, boolean>;
    closeOnPressEscape: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    targetAreaClickable: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
};
export declare type TourPropsPublic = __ExtractPublicPropTypes<typeof tourProps>;
export declare type TourStepEmits = typeof tourStepEmits;
export declare const tourStepEmits: {
    close: () => boolean;
};
export declare type TourStepProps = ExtractPropTypes<typeof tourStepProps>;
export declare const tourStepProps: {
    target: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement | (() => HTMLElement | null)) | (() => string | HTMLElement | (() => HTMLElement | null) | null) | ((new (...args: any[]) => string | HTMLElement | (() => HTMLElement | null)) | (() => string | HTMLElement | (() => HTMLElement | null) | null))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    title: StringConstructor;
    description: StringConstructor;
    showClose: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    closeIcon: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => (string | Component) & {}) | (() => string | Component) | ((new (...args: any[]) => (string | Component) & {}) | (() => string | Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
    placement: EpPropFinalized<(new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2) | ((new (...args: any[]) => "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end") | (() => Placement_2))[], "top" | "bottom" | "left" | "right" | "top-start" | "top-end" | "bottom-start" | "bottom-end" | "right-start" | "right-end" | "left-start" | "left-end", unknown, string, boolean>;
    mask: EpPropFinalized<(new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask) | ((new (...args: any[]) => boolean | {
        style?: CSSProperties;
        color?: string;
    }) | (() => TourMask))[], unknown, unknown, undefined, boolean>;
    contentStyle: {
        readonly type: PropType<CSSProperties>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    prevButtonProps: {
        readonly type: PropType<TourBtnProps>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    nextButtonProps: {
        readonly type: PropType<TourBtnProps>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    scrollIntoViewOptions: EpPropFinalized<(new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions) | ((new (...args: any[]) => boolean | ScrollIntoViewOptions) | (() => boolean | ScrollIntoViewOptions))[], unknown, unknown, undefined, boolean>;
    type: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "default" | "primary") | (() => "default" | "primary") | ((new (...args: any[]) => "default" | "primary") | (() => "default" | "primary"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type TourStepPropsPublic = __ExtractPublicPropTypes<typeof tourStepProps>;
export declare const tourStrategies: readonly [
    "absolute",
    "fixed"
];
export declare const transferCheckedChangeFn: (value: TransferKey[], movedKeys?: TransferKey[]) => boolean;
export declare interface TransferCheckedState {
    leftChecked: TransferKey[];
    rightChecked: TransferKey[];
}
export declare type TransferDataItem = Record<string, any>;
export declare type TransferDirection = "left" | "right";
export declare type TransferEmits = typeof transferEmits;
export declare const transferEmits: {
    change: (value: TransferKey[], direction: TransferDirection, movedKeys: TransferKey[]) => boolean;
    "update:modelValue": (value: TransferKey[]) => boolean;
    "left-check-change": (value: TransferKey[], movedKeys?: TransferKey[]) => boolean;
    "right-check-change": (value: TransferKey[], movedKeys?: TransferKey[]) => boolean;
};
export declare interface TransferFormat {
    noChecked?: string;
    hasChecked?: string;
}
export declare type TransferInstance = InstanceType<typeof _default_94> & unknown;
export declare type TransferKey = string | number;
declare type TransferPanelInstance = InstanceType<typeof _default_95> & unknown;
export declare type TransferProps = ExtractPropTypes<typeof transferProps>;
export declare const transferProps: {
    readonly data: EpPropFinalized<(new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]) | ((new (...args: any[]) => TransferDataItem[]) | (() => TransferDataItem[]))[], unknown, unknown, () => never[], boolean>;
    readonly titles: EpPropFinalized<(new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]) | ((new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]))[], unknown, unknown, () => never[], boolean>;
    readonly buttonTexts: EpPropFinalized<(new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]) | ((new (...args: any[]) => [
        string,
        string
    ]) | (() => [
        string,
        string
    ]))[], unknown, unknown, () => never[], boolean>;
    readonly filterPlaceholder: StringConstructor;
    readonly filterMethod: {
        readonly type: PropType<(query: string, item: TransferDataItem) => boolean>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly leftDefaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly rightDefaultChecked: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly renderContent: {
        readonly type: PropType<renderContent>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly modelValue: EpPropFinalized<(new (...args: any[]) => TransferKey[]) | (() => TransferKey[]) | ((new (...args: any[]) => TransferKey[]) | (() => TransferKey[]))[], unknown, unknown, () => never[], boolean>;
    readonly format: EpPropFinalized<(new (...args: any[]) => TransferFormat) | (() => TransferFormat) | ((new (...args: any[]) => TransferFormat) | (() => TransferFormat))[], unknown, unknown, () => {}, boolean>;
    readonly filterable: BooleanConstructor;
    readonly props: EpPropFinalized<(new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias) | ((new (...args: any[]) => TransferPropsAlias) | (() => TransferPropsAlias))[], unknown, unknown, () => Mutable<{
        readonly label: "label";
        readonly key: "key";
        readonly disabled: "disabled";
    }>, boolean>;
    readonly targetOrder: EpPropFinalized<StringConstructor, "push" | "unshift" | "original", unknown, "original", boolean>;
    readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
};
export declare interface TransferPropsAlias {
    label?: string;
    key?: string;
    disabled?: string;
}
export declare type TransferPropsPublic = __ExtractPublicPropTypes<typeof transferProps>;
export declare const translate: (path: string, option: undefined | TranslatorOption, locale: Language) => string;
declare type TranslatePair = {
    [key: string]: string | string[] | TranslatePair;
};
export declare type Translator = (path: string, option?: TranslatorOption) => string;
export declare type TranslatorOption = Record<string, string | number>;
export declare const TrapFocus: ObjectDirective;
export declare const TREE_NODE_MAP_INJECTION_KEY = "TreeNodeMap";
export declare interface TreeComponentProps {
    data: TreeData;
    emptyText: string;
    renderAfterExpand: boolean;
    nodeKey: string;
    checkStrictly: boolean;
    expandOnClickNode: boolean;
    defaultExpandAll: boolean;
    checkOnClickNode: boolean;
    checkOnClickLeaf: boolean;
    checkDescendants: boolean;
    autoExpandParent: boolean;
    defaultCheckedKeys: TreeKey[];
    defaultExpandedKeys: TreeKey[];
    currentNodeKey: TreeKey;
    renderContent: RenderContentFunction;
    showCheckbox: boolean;
    draggable: boolean;
    allowDrag: AllowDragFunction;
    allowDrop: AllowDropFunction;
    props: TreeOptionProps;
    lazy: boolean;
    highlightCurrent: boolean;
    load: LoadFunction;
    filterNodeMethod: FilterNodeMethodFunction;
    accordion: boolean;
    indent: number;
    icon: string | Component;
}
export declare type TreeData = TreeNodeData[];
declare interface TreeData_2 extends TreeNode {
    children?: string[];
    lazy?: boolean;
    loaded?: boolean;
}
declare type TreeData_3 = TreeNodeData_2[];
export declare type TreeInstance = InstanceType<typeof _default_96> & unknown;
export declare type TreeKey = string | number;
declare type TreeKey_2 = string | number;
export declare interface TreeNode {
    expanded?: boolean;
    loading?: boolean;
    noLazyChildren?: boolean;
    indent?: number;
    level?: number;
    display?: boolean;
}
declare interface TreeNode_2 {
    key: TreeKey_2;
    level: number;
    parent?: TreeNode_2;
    children?: TreeNode_2[];
    data: TreeNodeData_2;
    disabled?: boolean;
    label?: string;
    isLeaf?: boolean;
    expanded?: boolean;
}
export declare interface TreeNodeChildState {
    all: boolean;
    none: boolean;
    allWithoutDisable: boolean;
    half: boolean;
}
export declare type TreeNodeData = Record<string, any>;
declare type TreeNodeData_2 = Record<string, any>;
export declare interface TreeNodeLoadedDefaultProps {
    checked?: boolean;
}
export declare interface TreeNodeOptions {
    data: TreeNodeData;
    store: TreeStore;
    parent?: Node_2;
}
export declare interface TreeOptionProps {
    children?: string;
    label?: string | ((data: TreeNodeData, node: Node_2) => string);
    disabled?: string | ((data: TreeNodeData, node: Node_2) => boolean);
    isLeaf?: string | ((data: TreeNodeData, node: Node_2) => boolean);
    class?: (data: TreeNodeData, node: Node_2) => string | {
        [key: string]: boolean;
    };
}
declare interface TreeOptionProps_2 {
    children?: string;
    label?: string;
    value?: string;
    disabled?: string;
    class?: (data: TreeNodeData_2, node: TreeNode_2) => string | {
        [key: string]: boolean;
    };
}
declare interface TreeProps {
    hasChildren?: string;
    children?: string;
    checkStrictly?: boolean;
}
declare class TreeStore {
    currentNode: Node_2 | null;
    currentNodeKey: TreeKey | null;
    nodesMap: TreeStoreNodesMap;
    root: Node_2;
    data: TreeData;
    lazy: boolean;
    load?: LoadFunction;
    filterNodeMethod?: FilterNodeMethodFunction;
    key: TreeKey;
    defaultCheckedKeys?: TreeKey[];
    checkStrictly: boolean;
    defaultExpandedKeys?: TreeKey[];
    autoExpandParent: boolean;
    defaultExpandAll: boolean;
    checkDescendants: boolean;
    props: TreeOptionProps;
    constructor(options: TreeStoreOptions);
    initialize(): void;
    filter(value: FilterValue): void;
    setData(newVal: TreeData): void;
    getNode(data: TreeKey | TreeNodeData | Node_2): Node_2;
    insertBefore(data: TreeNodeData, refData: TreeKey | TreeNodeData | Node_2): void;
    insertAfter(data: TreeNodeData, refData: TreeKey | TreeNodeData | Node_2): void;
    remove(data: TreeNodeData | Node_2): void;
    append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node_2): void;
    _initDefaultCheckedNodes(): void;
    _initDefaultCheckedNode(node: Node_2): void;
    setDefaultCheckedKey(newVal: TreeKey[]): void;
    registerNode(node: Node_2): void;
    deregisterNode(node: Node_2): void;
    getCheckedNodes(leafOnly?: boolean, includeHalfChecked?: boolean): TreeNodeData[];
    getCheckedKeys(leafOnly?: boolean): TreeKey[];
    getHalfCheckedNodes(): TreeNodeData[];
    getHalfCheckedKeys(): TreeKey[];
    _getAllNodes(): Node_2[];
    updateChildren(key: TreeKey, data: TreeData): void;
    _setCheckedKeys(key: TreeKey, leafOnly: boolean | undefined, checkedKeys: {
        [key: string]: boolean;
    }): void;
    setCheckedNodes(array: Node_2[], leafOnly?: boolean): void;
    setCheckedKeys(keys: TreeKey[], leafOnly?: boolean): void;
    setDefaultExpandedKeys(keys: TreeKey[]): void;
    setChecked(data: TreeKey | TreeNodeData, checked: boolean, deep: boolean): void;
    getCurrentNode(): Node_2 | null;
    setCurrentNode(currentNode: Node_2): void;
    setUserCurrentNode(node: Node_2, shouldAutoExpandParent?: boolean): void;
    setCurrentNodeKey(key: TreeKey | null, shouldAutoExpandParent?: boolean): void;
}
export declare interface TreeStoreNodesMap {
    [key: string]: Node_2;
}
export declare interface TreeStoreOptions {
    key?: TreeKey;
    data: TreeData;
    lazy: boolean;
    props: TreeOptionProps;
    load?: LoadFunction;
    currentNodeKey?: TreeKey;
    checkStrictly: boolean;
    checkDescendants: boolean;
    defaultCheckedKeys?: TreeKey[];
    defaultExpandedKeys?: TreeKey[];
    autoExpandParent: boolean;
    defaultExpandAll: boolean;
    filterNodeMethod?: FilterNodeMethodFunction;
}
export declare type TreeV2Instance = InstanceType<typeof _default_98> & unknown;
declare const triggers: readonly [
    "click",
    "contextmenu",
    "hover",
    "focus"
];
/**
 * Tuple index key
 *
 * 
 *
 * @example
 * TupleKey<[1, 2, 3]> => '0' | '1' | '2'
 */
declare type TupleKey<T extends ReadonlyArray<any>> = Exclude<keyof T, ArrayMethodKey>;
declare type UnknownToNever<T> = IfUnknown<T, never, T>;
export declare const UPDATE_MODEL_EVENT = "update:modelValue";
declare class UploadAjaxError extends Error {
    name: string;
    status: number;
    method: string;
    url: string;
    constructor(message: string, status: number, method: string, url: string);
}
export declare const uploadBaseProps: {
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
};
export declare type UploadContentInstance = InstanceType<typeof _default_100> & unknown;
export declare type UploadContentProps = ExtractPropTypes<typeof uploadContentProps>;
export declare const uploadContentProps: {
    readonly beforeUpload: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onRemove: EpPropFinalized<(new (...args: any[]) => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | (() => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | {
        (): (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | (() => (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void) | {
        (): (file: UploadFile | UploadRawFile, rawFile?: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onStart: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => void) | (() => (rawFile: UploadRawFile) => void) | {
        (): (rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => void) | (() => (rawFile: UploadRawFile) => void) | {
        (): (rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onSuccess: EpPropFinalized<(new (...args: any[]) => (response: any, rawFile: UploadRawFile) => unknown) | (() => (response: any, rawFile: UploadRawFile) => unknown) | {
        (): (response: any, rawFile: UploadRawFile) => unknown;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (response: any, rawFile: UploadRawFile) => unknown) | (() => (response: any, rawFile: UploadRawFile) => unknown) | {
        (): (response: any, rawFile: UploadRawFile) => unknown;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onProgress: EpPropFinalized<(new (...args: any[]) => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | (() => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | {
        (): (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | (() => (evt: UploadProgressEvent, rawFile: UploadRawFile) => void) | {
        (): (evt: UploadProgressEvent, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onError: EpPropFinalized<(new (...args: any[]) => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | (() => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | {
        (): (err: UploadAjaxError, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | (() => (err: UploadAjaxError, rawFile: UploadRawFile) => void) | {
        (): (err: UploadAjaxError, rawFile: UploadRawFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onExceed: EpPropFinalized<(new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
};
export declare type UploadContentPropsPublic = __ExtractPublicPropTypes<typeof uploadContentProps>;
export declare interface UploadContext {
    accept: ComputedRef<string>;
}
export declare const uploadContextKey: InjectionKey<UploadContext>;
export declare type UploadData = Mutable<Record<string, any>>;
export declare type UploadDraggerEmits = typeof uploadDraggerEmits;
export declare const uploadDraggerEmits: {
    file: (file: File[]) => boolean;
};
export declare type UploadDraggerInstance = InstanceType<typeof _default_102> & unknown;
export declare type UploadDraggerProps = ExtractPropTypes<typeof uploadDraggerProps>;
export declare const uploadDraggerProps: {
    readonly disabled: BooleanConstructor;
};
export declare type UploadDraggerPropsPublic = __ExtractPublicPropTypes<typeof uploadDraggerProps>;
export declare interface UploadFile {
    name: string;
    percentage?: number;
    status: UploadStatus;
    size?: number;
    response?: unknown;
    uid: number;
    url?: string;
    raw?: UploadRawFile;
}
export declare type UploadFiles = UploadFile[];
export declare interface UploadHooks {
    beforeUpload: (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
    beforeRemove: (uploadFile: UploadFile, uploadFiles: UploadFiles) => Awaitable<boolean>;
    onRemove: (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    onChange: (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    onPreview: (uploadFile: UploadFile) => void;
    onSuccess: (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    onProgress: (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    onError: (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
    onExceed: (files: File[], uploadFiles: UploadUserFile[]) => void;
}
export declare type UploadInstance = InstanceType<typeof _default_99> & unknown;
export declare type UploadListEmits = typeof uploadListEmits;
export declare const uploadListEmits: {
    remove: (file: UploadFile) => boolean;
};
export declare type UploadListInstance = InstanceType<typeof _default_101> & unknown;
export declare type UploadListProps = ExtractPropTypes<typeof uploadListProps>;
export declare const uploadListProps: {
    readonly files: EpPropFinalized<(new (...args: any[]) => UploadFiles) | (() => UploadFiles) | ((new (...args: any[]) => UploadFiles) | (() => UploadFiles))[], unknown, unknown, () => never[], boolean>;
    readonly disabled: BooleanConstructor;
    readonly handlePreview: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type UploadListPropsPublic = __ExtractPublicPropTypes<typeof uploadListProps>;
export declare const uploadListTypes: readonly [
    "text",
    "picture",
    "picture-card"
];
export declare interface UploadProgressEvent extends ProgressEvent {
    percent: number;
}
export declare type UploadProps = ExtractPropTypes<typeof uploadProps>;
export declare const uploadProps: {
    readonly beforeUpload: EpPropFinalized<(new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | (() => (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>) | {
        (): (rawFile: UploadRawFile) => Awaitable<void | undefined | null | boolean | File | Blob>;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly beforeRemove: {
        readonly type: PropType<(uploadFile: UploadFile, uploadFiles: UploadFiles) => Awaitable<boolean>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onRemove: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onChange: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onPreview: EpPropFinalized<(new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (uploadFile: UploadFile) => void) | (() => (uploadFile: UploadFile) => void) | {
        (): (uploadFile: UploadFile) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onSuccess: EpPropFinalized<(new (...args: any[]) => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onProgress: EpPropFinalized<(new (...args: any[]) => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (evt: UploadProgressEvent, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onError: EpPropFinalized<(new (...args: any[]) => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | (() => (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void) | {
        (): (error: Error, uploadFile: UploadFile, uploadFiles: UploadFiles) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly onExceed: EpPropFinalized<(new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => (files: File[], uploadFiles: UploadUserFile[]) => void) | (() => (files: File[], uploadFiles: UploadUserFile[]) => void) | {
        (): (files: File[], uploadFiles: UploadUserFile[]) => void;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, () => void, boolean>;
    readonly crossorigin: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials") | ((new (...args: any[]) => "" | "anonymous" | "use-credentials") | (() => "" | "anonymous" | "use-credentials"))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly action: EpPropFinalized<StringConstructor, unknown, unknown, "#", boolean>;
    readonly headers: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers) | ((new (...args: any[]) => Record<string, any> | Headers) | (() => Record<string, any> | Headers))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly method: EpPropFinalized<StringConstructor, unknown, unknown, "post", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | ((new (...args: any[]) => Mutable<Record<string, any>> | Promise<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)) | (() => Awaitable<Mutable<Record<string, any>>> | ((rawFile: UploadRawFile) => Awaitable<UploadData>)))[], unknown, unknown, () => Mutable<{}>, boolean>;
    readonly multiple: BooleanConstructor;
    readonly name: EpPropFinalized<StringConstructor, unknown, unknown, "file", boolean>;
    readonly drag: BooleanConstructor;
    readonly withCredentials: BooleanConstructor;
    readonly showFileList: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly accept: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly fileList: EpPropFinalized<(new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]) | ((new (...args: any[]) => UploadUserFile[]) | (() => UploadUserFile[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly autoUpload: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly listType: EpPropFinalized<StringConstructor, "picture" | "text" | "picture-card", unknown, "text", boolean>;
    readonly httpRequest: EpPropFinalized<(new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => UploadRequestHandler) | (() => UploadRequestHandler) | {
        (): UploadRequestHandler;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, UploadRequestHandler, boolean>;
    readonly disabled: BooleanConstructor;
    readonly limit: NumberConstructor;
};
export declare type UploadPropsPublic = __ExtractPublicPropTypes<typeof uploadProps>;
export declare interface UploadRawFile extends File {
    uid: number;
    isDirectory?: boolean;
}
export declare type UploadRequestHandler = (options: UploadRequestOptions) => XMLHttpRequest | Promise<unknown>;
export declare interface UploadRequestOptions {
    action: string;
    method: string;
    data: Record<string, string | Blob | [
        Blob,
        string
    ]>;
    filename: string;
    file: UploadRawFile;
    headers: Headers | Record<string, string | number | null | undefined>;
    onError: (evt: UploadAjaxError) => void;
    onProgress: (evt: UploadProgressEvent) => void;
    onSuccess: (response: any) => void;
    withCredentials: boolean;
}
export declare type UploadStatus = "ready" | "uploading" | "success" | "fail";
export declare type UploadUserFile = Omit<UploadFile, "status" | "uid"> & Partial<Pick<UploadFile, "status" | "uid">>;
export declare const useAriaProps: <T extends keyof typeof ariaProps>(arias: Array<T>) => Pick<{
    ariaLabel: StringConstructor;
    ariaOrientation: {
        readonly type: PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    ariaControls: StringConstructor;
}, T>;
export declare const useAttrs: (params?: Params) => ComputedRef<Record<string, unknown>>;
declare const useCache: <T>() => ComputedRef<(((_: any, __: any, ___: any) => Record<string, T>) & MemoizedFunction) | MemoizedFn<(_: any, __: any, ___: any) => Record<string, T>>>;
export declare function useCalcInputWidth(): {
    calculatorRef: ShallowRef<HTMLElement | undefined>;
    calculatorWidth: Ref<number>;
    inputStyle: ComputedRef<{
        minWidth: string;
    }>;
};
export declare const useCascaderConfig: (props: {
    props: CascaderProps;
}) => ComputedRef<{
    expandTrigger: ExpandTrigger;
    multiple: boolean;
    checkStrictly: boolean;
    emitPath: boolean;
    lazy: boolean;
    lazyLoad: LazyLoad_2;
    value: string;
    label: string;
    children: string;
    disabled: string | isDisabled_2;
    leaf: string | isLeaf_2;
    hoverThreshold: number;
    checkOnClickNode: boolean;
    checkOnClickLeaf: boolean;
    showPrefix: boolean;
}>;
declare const useCommonPicker: <P extends CommonPickerProps, E extends CommonPickerEmits>(props: P, emit: E) => {
    parsedValue: ComputedRef<DayOrDays>;
    pickerActualVisible: Ref<boolean>;
    pickerOptions: Ref<{
        isValidValue?: ((date: DayOrDays) => boolean) | undefined;
        handleKeydownInput?: ((event: KeyboardEvent) => void) | undefined;
        parseUserInput?: ((value: UserInput) => DayOrDays) | undefined;
        formatToString?: ((value: DayOrDays) => UserInput) | undefined;
        getRangeAvailableTime?: ((date: DayOrDays) => DayOrDays) | undefined;
        getDefaultValue?: (() => DayOrDays) | undefined;
        panelReady?: boolean | undefined;
        handleClear?: (() => void) | undefined;
        handleFocusPicker?: (() => void) | undefined;
    }>;
    pickerVisible: Ref<boolean>;
    userInput: Ref<UserInput>;
    valueIsEmpty: ComputedRef<boolean>;
    emitInput: (input: SingleOrRange<DateModelType> | null) => void;
    onCalendarChange: (e: [
        Date,
        null | Date
    ]) => void;
    onPanelChange: (value: [
        Dayjs,
        Dayjs
    ], mode: "month" | "year", view: unknown) => void;
    onPick: (date?: any, visible?: boolean) => void;
    onSetPickerOption: <T extends keyof PickerOptions>(e: [
        T,
        PickerOptions[T]
    ]) => void;
};
export declare function useComposition({ afterComposition, emit, }: UseCompositionOptions): {
    isComposing: Ref<boolean>;
    handleComposition: (event: CompositionEvent) => void;
    handleCompositionStart: (event: CompositionEvent) => void;
    handleCompositionUpdate: (event: CompositionEvent) => void;
    handleCompositionEnd: (event: CompositionEvent) => void;
};
declare interface UseCompositionOptions {
    afterComposition: (event: CompositionEvent) => void;
    emit?: ((event: "compositionstart", evt: CompositionEvent) => void) & ((event: "compositionupdate", evt: CompositionEvent) => void) & ((event: "compositionend", evt: CompositionEvent) => void);
}
export declare function useCursor(input: ShallowRef<HTMLInputElement | undefined>): [
    () => void,
    () => void
];
export declare const useDelayedRender: ({ indicator, intermediateIndicator, shouldSetIntermediate, beforeShow, afterShow, afterHide, beforeHide, }: UseDelayedRenderProps) => void;
export declare type UseDelayedRenderProps = {
    indicator: Ref<boolean>;
    intermediateIndicator: Ref<boolean>;
    shouldSetIntermediate?: (step: "show" | "hide") => boolean;
    beforeShow?: () => void;
    beforeHide?: () => void;
    afterShow?: () => void;
    afterHide?: () => void;
};
export declare const useDelayedToggle: ({ showAfter, hideAfter, autoClose, open, close, }: UseDelayedToggleProps) => {
    onOpen: (event?: Event) => void;
    onClose: (event?: Event) => void;
};
export declare type UseDelayedToggleProps = {
    open: (event?: Event) => void;
    close: (event?: Event) => void;
} & ToRefs<ExtractPropTypes<typeof useDelayedToggleProps>>;
export declare const useDelayedToggleProps: {
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
};
export declare const useDeprecated: ({ from, replacement, scope, version, ref, type }: DeprecationParam, condition: MaybeRef<boolean>) => void;
export declare const useDialog: (props: DialogProps, targetRef: Ref<HTMLElement | undefined>) => {
    afterEnter: () => void;
    afterLeave: () => void;
    beforeLeave: () => void;
    handleClose: () => void;
    onModalClick: () => void;
    close: () => void;
    doClose: () => void;
    onOpenAutoFocus: () => void;
    onCloseAutoFocus: () => void;
    onCloseRequested: () => void;
    onFocusoutPrevented: (event: CustomEvent) => void;
    titleId: Ref<string>;
    bodyId: Ref<string>;
    closed: Ref<boolean>;
    style: ComputedRef<CSSProperties>;
    overlayDialogStyle: ComputedRef<CSSProperties>;
    rendered: Ref<boolean>;
    visible: Ref<boolean>;
    zIndex: Ref<number>;
    transitionConfig: ComputedRef<TransitionProps | {
        name: string | TransitionProps;
        onAfterEnter: () => void;
        onBeforeLeave: () => void;
        onAfterLeave: () => void;
    }>;
    _draggable: ComputedRef<boolean>;
    _alignCenter: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
    _overflow: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
};
export declare const useDisabled: (fallback?: MaybeRef<boolean | undefined>) => ComputedRef<boolean>;
export declare const useDraggable: (targetRef: Ref<HTMLElement | undefined>, dragRef: Ref<HTMLElement | undefined>, draggable: ComputedRef<boolean>, overflow?: ComputedRef<boolean>) => {
    isDragging: Ref<boolean>;
    resetPosition: () => void;
    updatePosition: () => void;
};
export declare const useEmptyValues: (props: EmptyValuesContext, defaultValue?: null | undefined) => {
    emptyValues: ComputedRef<unknown[]>;
    valueOnClear: ComputedRef<any>;
    isEmptyValue: (value: unknown) => boolean;
};
export declare const useEmptyValuesProps: {
    readonly emptyValues: ArrayConstructor;
    readonly valueOnClear: EpPropFinalized<(new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null) | ((new (...args: any[]) => string | number | boolean | Function) | (() => string | number | boolean | Function | null))[], unknown, unknown, undefined, boolean>;
};
export declare const useEscapeKeydown: (handler: (e: KeyboardEvent) => void) => void;
export declare const useFloating: ({ middleware, placement, strategy, }: UseFloatingProps) => {
    update: () => Promise<void>;
    referenceRef: Ref<HTMLElement | VirtualElement | undefined>;
    contentRef: Ref<HTMLElement | undefined>;
    x: Ref<number | undefined>;
    y: Ref<number | undefined>;
    placement: Ref<Placement_3>;
    strategy: Ref<Strategy>;
    middlewareData: Ref<{
        [x: string]: any;
        arrow?: {
            x?: number | undefined;
            y?: number | undefined;
            centerOffset: number;
        } | undefined;
        autoPlacement?: {
            index?: number | undefined;
            overflows: {
                placement: Placement_3;
                overflows: Array<number>;
            }[];
        } | undefined;
        flip?: {
            index?: number | undefined;
            overflows: {
                placement: Placement_3;
                overflows: Array<number>;
            }[];
        } | undefined;
        hide?: {
            referenceHidden?: boolean | undefined;
            escaped?: boolean | undefined;
            referenceHiddenOffsets?: {
                top: number;
                bottom: number;
                left: number;
                right: number;
            } | undefined;
            escapedOffsets?: {
                top: number;
                bottom: number;
                left: number;
                right: number;
            } | undefined;
        } | undefined;
        offset?: {
            x: number;
            y: number;
        } | undefined;
        shift?: {
            x: number;
            y: number;
        } | undefined;
    }>;
};
export declare type UseFloatingProps = ToRefs<{
    middleware: Array<Middleware>;
    placement: Placement_3;
    strategy: Strategy;
}>;
export declare const useFloatingProps: {};
export declare const useFocus: (el: Ref<{
    focus: () => void;
} | null>) => {
    focus: () => void;
};
export declare function useFocusController<T extends {
    focus: () => void;
}>(target: ShallowRef<T | undefined>, { disabled, beforeFocus, afterFocus, beforeBlur, afterBlur, }?: UseFocusControllerOptions): {
    isFocused: Ref<boolean>;
    /** Avoid using wrapperRef and handleFocus/handleBlur together */
    wrapperRef: ShallowRef<HTMLElement | undefined>;
    handleFocus: (event: FocusEvent) => void;
    handleBlur: (event: FocusEvent) => void;
};
declare interface UseFocusControllerOptions {
    disabled?: MaybeRef<boolean>;
    /**
     * return true to cancel focus
     * @param event FocusEvent
     */
    beforeFocus?: (event: FocusEvent) => boolean | undefined;
    afterFocus?: () => void;
    /**
     * return true to cancel blur
     * @param event FocusEvent
     */
    beforeBlur?: (event: FocusEvent) => boolean | undefined;
    afterBlur?: () => void;
}
export declare const useFormDisabled: (fallback?: MaybeRef<boolean | undefined>) => ComputedRef<boolean>;
export declare const useFormItem: () => {
    form: FormContext | undefined;
    formItem: FormItemContext | undefined;
};
export declare const useFormItemInputId: (props: Partial<IUseFormItemInputCommonProps>, { formItemContext, disableIdGeneration, disableIdManagement, }: {
    formItemContext?: FormItemContext;
    disableIdGeneration?: ComputedRef<boolean> | Ref<boolean>;
    disableIdManagement?: ComputedRef<boolean> | Ref<boolean>;
}) => {
    isLabeledByFormItem: ComputedRef<boolean>;
    inputId: Ref<string | undefined>;
};
declare function useFormLabelWidth(): {
    autoLabelWidth: ComputedRef<string>;
    registerLabelWidth: (val: number, oldVal: number) => void;
    deregisterLabelWidth: (val: number) => void;
};
export declare const useFormSize: (fallback?: MaybeRef<ComponentSize | undefined>, ignore?: Partial<Record<"prop" | "form" | "formItem" | "global", boolean>>) => ComputedRef<"" | "small" | "default" | "large">;
export declare const useForwardRef: <T>(forwardRef: Ref<T | null>) => void;
export declare const useForwardRefDirective: (setForwardRef: ForwardRefSetter) => ObjectDirective;
export declare const useGetDerivedNamespace: (namespaceOverrides?: Ref<string | undefined>) => ComputedRef<string>;
export declare function useGlobalComponentSettings(block: string, sizeFallback?: MaybeRef<ConfigProviderContext["size"]>): {
    ns: {
        namespace: ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    locale: LocaleContext;
    zIndex: {
        initialZIndex: ComputedRef<number>;
        currentZIndex: ComputedRef<number>;
        nextZIndex: () => number;
    };
    size: ComputedRef<"small" | "" | "default" | "large">;
};
export declare function useGlobalConfig<K extends keyof ConfigProviderContext, D extends ConfigProviderContext[K]>(key: K, defaultValue?: D): Ref<Exclude<ConfigProviderContext[K], undefined> | D>;
export declare function useGlobalConfig(): Ref<ConfigProviderContext>;
export declare const useGlobalSize: () => ComputedRef<"" | "small" | "default" | "large">;
export declare const useId: (deterministicId?: MaybeRef<string>) => Ref<string>;
export declare const useIdInjection: () => ElIdInjectionContext;
export declare const useLocale: (localeOverrides?: Ref<Language | undefined>) => LocaleContext;
/**
 * Hook that monitoring the ref value to lock or unlock the screen.
 * When the trigger became true, it assumes modal is now opened and vice versa.
 * @param trigger {Ref<boolean>}
 */
export declare const useLockscreen: (trigger: Ref<boolean>, options?: UseLockScreenOptions) => void;
export declare type UseLockScreenOptions = {
    ns?: UseNamespaceReturn;
};
export declare const useModal: (instance: ModalInstance, visibleRef: Ref<boolean>) => void;
export declare const useModelToggle: ({ indicator, toggleReason, shouldHideWhenRouteChanges, shouldProceed, onShow, onHide, }: ModelToggleParams) => {
    hide: (event?: Event) => void;
    show: (event?: Event) => void;
    toggle: () => void;
    hasUpdateHandler: ComputedRef<boolean>;
};
export declare const useModelToggleEmits: "update:modelValue"[];
export declare type UseModelToggleProps = ExtractPropTypes<typeof useModelToggleProps>;
export declare const useModelToggleProps: UseModelTogglePropsRaw<"modelValue">;
export declare type UseModelTogglePropsGeneric<T extends string> = {
    [K in T]: ExtractPropType<typeof _prop>;
} & {
    [K in `onUpdate:${T}`]: ExtractPropType<typeof _event>;
};
export declare type UseModelTogglePropsPublic = __ExtractPublicPropTypes<typeof useModelToggleProps>;
export declare type UseModelTogglePropsRaw<T extends string> = {
    [K in T]: typeof _prop;
} & {
    [K in `onUpdate:${T}`]: typeof _event;
};
export declare const useNamespace: (block: string, namespaceOverrides?: Ref<string | undefined>) => {
    namespace: ComputedRef<string>;
    b: (blockSuffix?: string) => string;
    e: (element?: string) => string;
    m: (modifier?: string) => string;
    be: (blockSuffix?: string, element?: string) => string;
    em: (element?: string, modifier?: string) => string;
    bm: (blockSuffix?: string, modifier?: string) => string;
    bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
    is: {
        (name: string, state: boolean | undefined): string;
        (name: string): string;
    };
    cssVar: (object: Record<string, string>) => Record<string, string>;
    cssVarName: (name: string) => string;
    cssVarBlock: (object: Record<string, string>) => Record<string, string>;
    cssVarBlockName: (name: string) => string;
};
export declare type UseNamespaceReturn = ReturnType<typeof useNamespace>;
export declare const useOrderedChildren: <T extends ChildEssential>(vm: ComponentInternalInstance, childComponentName: string) => {
    children: ShallowRef<T[]>;
    addChild: (child: T) => void;
    removeChild: (child: T) => void;
    ChildrenSorter: DefineComponent<{}, () => VNode<RendererNode, RendererElement, {
        [key: string]: any;
    }> | null, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
};
export declare const usePopper: (referenceElementRef: Ref<ReferenceElement>, popperElementRef: Ref<ElementType>, opts?: Ref<PartialOptions> | PartialOptions) => {
    state: ComputedRef<{
        elements?: {
            reference: Element | VirtualElement_2;
            popper: HTMLElement;
            arrow?: HTMLElement;
        } | undefined;
        options?: OptionsGeneric<any> | undefined;
        placement?: Placement | undefined;
        strategy?: PositioningStrategy | undefined;
        orderedModifiers?: Modifier<any, any>[] | undefined;
        rects?: StateRects | undefined;
        scrollParents?: {
            reference: Array<Element | Window_2 | VisualViewport_2>;
            popper: Array<Element | Window_2 | VisualViewport_2>;
        } | undefined;
        styles?: {
            [key: string]: Partial<CSSStyleDeclaration>;
        } | undefined;
        attributes?: {
            [key: string]: {
                [key: string]: string | boolean;
            };
        } | undefined;
        modifiersData?: {
            [key: string]: any;
            arrow?: {
                x?: number;
                y?: number;
                centerOffset: number;
            };
            hide?: {
                isReferenceHidden: boolean;
                hasPopperEscaped: boolean;
                referenceClippingOffsets: SideObject;
                popperEscapeOffsets: SideObject;
            };
            offset?: {
                top?: Offsets | undefined;
                bottom?: Offsets | undefined;
                left?: Offsets | undefined;
                right?: Offsets | undefined;
                auto?: Offsets | undefined;
                "auto-start"?: Offsets | undefined;
                "auto-end"?: Offsets | undefined;
                "top-start"?: Offsets | undefined;
                "top-end"?: Offsets | undefined;
                "bottom-start"?: Offsets | undefined;
                "bottom-end"?: Offsets | undefined;
                "right-start"?: Offsets | undefined;
                "right-end"?: Offsets | undefined;
                "left-start"?: Offsets | undefined;
                "left-end"?: Offsets | undefined;
            };
            preventOverflow?: Offsets;
            popperOffsets?: Offsets;
        } | undefined;
        reset?: boolean | undefined;
    }>;
    styles: ComputedRef<{
        [key: string]: Partial<CSSStyleDeclaration>;
    }>;
    attributes: ComputedRef<{
        [key: string]: {
            [key: string]: string | boolean;
        };
    }>;
    update: () => Promise<Partial<State>> | undefined;
    forceUpdate: () => void | undefined;
    instanceRef: ComputedRef<Instance_2 | undefined>;
};
/** @deprecated use `PopperArrowProps` instead, and it will be deprecated in the next major version */
export declare type UsePopperArrowProps = PopperArrowProps;
/** @deprecated use `popperArrowProps` instead, and it will be deprecated in the next major version */
export declare const usePopperArrowProps: {
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
};
export declare const usePopperContainer: () => {
    id: ComputedRef<string>;
    selector: ComputedRef<string>;
};
export declare const usePopperContainerId: () => {
    id: ComputedRef<string>;
    selector: ComputedRef<string>;
};
/** @deprecated use `popperContentEmits` instead, and it will be deprecated in the next major version */
export declare const usePopperContentEmits: {
    mouseenter: (evt: MouseEvent) => boolean;
    mouseleave: (evt: MouseEvent) => boolean;
    focus: () => boolean;
    blur: () => boolean;
    close: () => boolean;
};
/** @deprecated use `PopperContentProps` instead, and it will be deprecated in the next major version */
export declare type UsePopperContentProps = PopperContentProps;
/** @deprecated use `popperContentProps` instead, and it will be deprecated in the next major version */
export declare const usePopperContentProps: {
    readonly ariaLabel: StringConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType) | ((new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly visible: BooleanConstructor;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType) | ((new (...args: any[]) => string | ClassObjectType | ClassType[]) | (() => ClassType))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
};
/** @deprecated use `PopperCoreConfigProps` instead, and it will be deprecated in the next major version */
export declare type UsePopperCoreConfigProps = PopperCoreConfigProps;
/** @deprecated use `popperCoreConfigProps` instead, and it will be deprecated in the next major version */
export declare const usePopperCoreConfigProps: {
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
};
/** @deprecated use `PopperProps` instead, and it will be deprecated in the next major version */
export declare type UsePopperProps = PopperProps;
/** @deprecated use `popperProps` instead, and it will be deprecated in the next major version */
export declare const usePopperProps: {
    readonly role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
};
export declare type UsePopperReturn = ReturnType<typeof usePopper>;
/** @deprecated use `popperTriggerProps` instead, and it will be deprecated in the next major version */
export declare const usePopperTriggerProps: {
    readonly virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly virtualTriggering: BooleanConstructor;
    readonly onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly open: BooleanConstructor;
};
export declare const usePreventGlobal: <E extends keyof DocumentEventMap>(indicator: Ref<boolean>, evt: E, cb: (e: DocumentEventMap[E]) => boolean) => void;
export declare const useProp: <T>(name: string) => ComputedRef<T | undefined>;
export declare type UserInput = SingleOrRange<string | null>;
export declare const useSameTarget: (handleClick?: (e: MouseEvent) => void) => {
    onClick: (e: MouseEvent) => void;
    onMousedown: (e: MouseEvent) => void;
    onMouseup: (e: MouseEvent) => void;
};
export declare const useSize: (fallback?: MaybeRef<ComponentSize | undefined>, ignore?: Partial<Record<"prop" | "form" | "formItem" | "global", boolean>>) => ComputedRef<"" | "small" | "default" | "large">;
export declare const useSizeProp: {
    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
    readonly required: false;
    readonly validator: ((val: unknown) => boolean) | undefined;
    __epPropKey: true;
};
export declare const useSizeProps: {
    size: {
        readonly type: PropType<EpPropMergeType<StringConstructor, "" | "small" | "default" | "large", never>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare function useSpace(props: SpaceProps): {
    classes: ComputedRef<EpPropMergeType<(new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>) | ((new (...args: any[]) => string | Record<string, boolean> | (string | Record<string, boolean>)[]) | (() => Arrayable<string | Record<string, boolean>>))[], unknown, unknown>[]>;
    containerStyle: ComputedRef<StyleValue>;
    itemStyle: ComputedRef<StyleValue>;
};
declare function useTable(props: TableV2Props): {
    columns: ComputedRef<{
        key: KeyType_2;
        align?: Alignment_2;
        class?: string | ClassNameGetter<any> | undefined;
        dataKey?: KeyType_2;
        fixed?: true | FixedDirection;
        flexGrow?: CSSProperties["flexGrow"];
        flexShrink?: CSSProperties["flexShrink"];
        title?: string;
        hidden?: boolean;
        headerClass?: string | HeaderClassGetter<any> | undefined;
        maxWidth?: number;
        minWidth?: number;
        style?: CSSProperties;
        sortable?: boolean;
        width: number;
        cellRenderer?: CellRenderer<any> | undefined;
        headerCellRenderer?: HeaderCellRenderer<any> | undefined;
    }[]>;
    containerRef: Ref<any>;
    mainTableRef: Ref<TableGridInstance | undefined>;
    leftTableRef: Ref<TableGridInstance | undefined>;
    rightTableRef: Ref<TableGridInstance | undefined>;
    isDynamic: ComputedRef<boolean>;
    isResetting: ShallowRef<boolean>;
    isScrolling: ShallowRef<boolean>;
    hasFixedColumns: ComputedRef<number>;
    columnsStyles: ComputedRef<Record<KeyType_2, CSSProperties>>;
    columnsTotalWidth: ComputedRef<number>;
    data: ComputedRef<any[]>;
    expandedRowKeys: Ref<KeyType_2[]>;
    depthMap: Ref<Record<KeyType_2, number>>;
    fixedColumnsOnLeft: ComputedRef<{
        key: KeyType_2;
        align?: Alignment_2;
        class?: string | ClassNameGetter<any> | undefined;
        dataKey?: KeyType_2;
        fixed?: true | FixedDirection;
        flexGrow?: CSSProperties["flexGrow"];
        flexShrink?: CSSProperties["flexShrink"];
        title?: string;
        hidden?: boolean;
        headerClass?: string | HeaderClassGetter<any> | undefined;
        maxWidth?: number;
        minWidth?: number;
        style?: CSSProperties;
        sortable?: boolean;
        width: number;
        cellRenderer?: CellRenderer<any> | undefined;
        headerCellRenderer?: HeaderCellRenderer<any> | undefined;
    }[]>;
    fixedColumnsOnRight: ComputedRef<{
        key: KeyType_2;
        align?: Alignment_2;
        class?: string | ClassNameGetter<any> | undefined;
        dataKey?: KeyType_2;
        fixed?: true | FixedDirection;
        flexGrow?: CSSProperties["flexGrow"];
        flexShrink?: CSSProperties["flexShrink"];
        title?: string;
        hidden?: boolean;
        headerClass?: string | HeaderClassGetter<any> | undefined;
        maxWidth?: number;
        minWidth?: number;
        style?: CSSProperties;
        sortable?: boolean;
        width: number;
        cellRenderer?: CellRenderer<any> | undefined;
        headerCellRenderer?: HeaderCellRenderer<any> | undefined;
    }[]>;
    mainColumns: ComputedRef<AnyColumns>;
    bodyWidth: ComputedRef<number>;
    emptyStyle: ComputedRef<CSSProperties>;
    rootStyle: ComputedRef<CSSProperties>;
    footerHeight: ComputedRef<CSSProperties>;
    mainTableHeight: ComputedRef<number>;
    fixedTableHeight: ComputedRef<number>;
    leftTableWidth: ComputedRef<number>;
    rightTableWidth: ComputedRef<number>;
    showEmpty: ComputedRef<boolean>;
    getRowHeight: (rowIndex: number) => number;
    onColumnSorted: (e: MouseEvent) => void;
    onRowHovered: ({ hovered, rowKey }: RowHoverParams) => void;
    onRowExpanded: ({ expanded, rowData, rowIndex, rowKey, }: RowExpandParams) => void;
    onRowsRendered: (params: onRowRenderedParams) => void;
    onRowHeightChange: ({ rowKey, height, rowIndex }: RowHeightChangedParams, fixedDir: FixedDirection) => void;
    scrollTo: (params: ScrollPos) => void;
    scrollToLeft: (scrollLeft: number) => void;
    scrollToTop: (scrollTop: number) => void;
    scrollToRow: (row: number, strategy?: Alignment) => void;
    onScroll: (params: ScrollPos) => void;
    onVerticalScroll: ({ scrollTop }: ScrollPos) => void;
};
declare type UseTableReturn = ReturnType<typeof useTable>;
export declare const useTeleport: (contentRenderer: () => VNode, appendToBody: Ref<boolean>) => {
    isTeleportVisible: Ref<boolean>;
    showTeleport: () => void;
    hideTeleport: () => void;
    renderTeleport: () => void;
};
export declare const useThrottleRender: (loading: Ref<boolean>, throttle?: ThrottleType) => Ref<boolean>;
export declare function useTimeout(): {
    registerTimeout: (fn: (...args: any[]) => any, delay: number) => void;
    cancelTimeout: () => void;
};
export declare const useTooltipContentProps: {
    readonly ariaLabel: StringConstructor;
    readonly appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly rawContent: BooleanConstructor;
    readonly persistent: BooleanConstructor;
    readonly visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    readonly transition: StringConstructor;
    readonly teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly disabled: BooleanConstructor;
    readonly id: StringConstructor;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    readonly enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly pure: BooleanConstructor;
    readonly focusOnShow: BooleanConstructor;
    readonly trapping: BooleanConstructor;
    readonly popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly virtualTriggering: BooleanConstructor;
    readonly zIndex: NumberConstructor;
    readonly arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    readonly boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    readonly gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    readonly placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    readonly popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    readonly strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
    readonly showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    readonly autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
};
export declare const useTooltipModelToggle: ({ indicator, toggleReason, shouldHideWhenRouteChanges, shouldProceed, onShow, onHide, }: ModelToggleParams) => {
    hide: (event?: Event) => void;
    show: (event?: Event) => void;
    toggle: () => void;
    hasUpdateHandler: ComputedRef<boolean>;
};
export declare const useTooltipModelToggleEmits: "update:visible"[];
export declare const useTooltipModelToggleProps: UseModelTogglePropsRaw<"visible">;
export declare const useTooltipProps: {
    showArrow: EpPropFinalized<BooleanConstructor, unknown, unknown, boolean, boolean>;
    arrowOffset: EpPropFinalized<NumberConstructor, unknown, unknown, 5, boolean>;
    disabled: BooleanConstructor;
    trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    virtualTriggering: BooleanConstructor;
    onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    id: StringConstructor;
    open: BooleanConstructor;
    ariaLabel: StringConstructor;
    appendTo: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>) | ((new (...args: any[]) => string | HTMLElement) | (() => EpPropMergeType<(new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement) | ((new (...args: any[]) => string | HTMLElement) | (() => string | HTMLElement))[], unknown, unknown>))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    content: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    rawContent: BooleanConstructor;
    persistent: BooleanConstructor;
    visible: EpPropFinalized<(new (...args: any[]) => boolean) | (() => boolean | null) | ((new (...args: any[]) => boolean) | (() => boolean | null))[], unknown, unknown, null, boolean>;
    transition: StringConstructor;
    teleported: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    className: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    effect: EpPropFinalized<(new (...args: any[]) => string) | (() => PopperEffect) | ((new (...args: any[]) => string) | (() => PopperEffect))[], unknown, unknown, "dark", boolean>;
    enterable: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    pure: BooleanConstructor;
    focusOnShow: BooleanConstructor;
    trapping: BooleanConstructor;
    popperClass: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | ((new (...args: any[]) => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]) | (() => string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | (string | {
            [x: string]: boolean;
        } | any)[])[])[])[])[])[])[])[])[])[])[]))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    popperStyle: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    referenceEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    triggerTargetEl: {
        readonly type: PropType<HTMLElement>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    stopPopperMouseEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    zIndex: NumberConstructor;
    boundariesPadding: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    fallbackPlacements: EpPropFinalized<(new (...args: any[]) => Placement[]) | (() => Placement[]) | ((new (...args: any[]) => Placement[]) | (() => Placement[]))[], unknown, unknown, undefined, boolean>;
    gpuAcceleration: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    offset: EpPropFinalized<NumberConstructor, unknown, unknown, 12, boolean>;
    placement: EpPropFinalized<StringConstructor, Placement, unknown, "bottom", boolean>;
    popperOptions: EpPropFinalized<(new (...args: any[]) => Partial<Options>) | (() => Partial<Options>) | ((new (...args: any[]) => Partial<Options>) | (() => Partial<Options>))[], unknown, unknown, () => {}, boolean>;
    strategy: EpPropFinalized<StringConstructor, "fixed" | "absolute", unknown, "absolute", boolean>;
    showAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    hideAfter: EpPropFinalized<NumberConstructor, unknown, unknown, 200, boolean>;
    autoClose: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    "onUpdate:visible": {
        readonly type: PropType<(val: boolean) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    role: EpPropFinalized<StringConstructor, "dialog" | "menu" | "grid" | "listbox" | "tooltip" | "tree" | "group" | "navigation", unknown, "tooltip", boolean>;
};
export declare const useTooltipTriggerProps: {
    readonly disabled: BooleanConstructor;
    readonly trigger: EpPropFinalized<(new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>) | ((new (...args: any[]) => "click" | "contextmenu" | "focus" | "hover" | TooltipTriggerType[]) | (() => Arrayable<TooltipTriggerType>))[], unknown, unknown, "hover", boolean>;
    readonly triggerKeys: EpPropFinalized<(new (...args: any[]) => string[]) | (() => string[]) | ((new (...args: any[]) => string[]) | (() => string[]))[], unknown, unknown, () => string[], boolean>;
    readonly virtualRef: {
        readonly type: PropType<Measurable>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly virtualTriggering: BooleanConstructor;
    readonly onMouseenter: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onMouseleave: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onClick: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onKeydown: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onFocus: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onBlur: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly onContextmenu: {
        readonly type: PropType<(e: Event) => void>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly id: StringConstructor;
    readonly open: BooleanConstructor;
};
/**
 * Simple usage
 *
 * In your setups:
 *
 * setup() {
 *   const fallthroughMethods = useTransitionFallthrough()
 *   return fallthrough
 * }
 *
 * In your template:
 *
 * <template>
 *  <transition name="whatever" v-bind="fallthrough">
 *    <slot />
 *  </transition>
 * </template>
 *
 */
export declare const useTransitionFallthrough: () => {
    onAfterAppear: () => void;
    onAfterEnter: () => void;
    onAfterLeave: () => void;
    onAppearCancelled: () => void;
    onBeforeEnter: () => void;
    onBeforeLeave: () => void;
    onEnter: () => void;
    onEnterCancelled: () => void;
    onLeave: () => void;
    onLeaveCancelled: () => void;
};
export declare const useTransitionFallthroughEmits: readonly [
    "after-appear",
    "after-enter",
    "after-leave",
    "appear",
    "appear-cancelled",
    "before-enter",
    "before-leave",
    "enter",
    "enter-cancelled",
    "leave",
    "leave-cancelled"
];
export declare const useZIndex: (zIndexOverrides?: Ref<number>) => {
    initialZIndex: ComputedRef<number>;
    currentZIndex: ComputedRef<number>;
    nextZIndex: () => number;
};
export declare type UseZIndexReturn = ReturnType<typeof useZIndex>;
declare type Value<T> = T[keyof T];
export declare const valueEquals: (a: Array<Date> | unknown, b: Array<Date> | unknown) => boolean;
export declare const version: string;
export declare type VirtualizedGridProps = ExtractPropTypes<typeof virtualizedGridProps>;
export declare const virtualizedGridProps: {
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly columnCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly columnWidth: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedColumnWidth: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly estimatedRowHeight: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly initScrollLeft: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly initScrollTop: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly itemKey: EpPropFinalized<(new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    } | ((new (...args: any[]) => GridItemKeyGetter) | (() => GridItemKeyGetter) | {
        (): GridItemKeyGetter;
        new (): any;
        readonly prototype: any;
    })[], unknown, unknown, ({ columnIndex, rowIndex, }: {
        columnIndex: number;
        rowIndex: number;
    }) => string, boolean>;
    readonly rowCache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly rowHeight: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalColumn: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly totalRow: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly hScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly vScrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly scrollbarStartGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly scrollbarEndGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly role: StringConstructor;
};
export declare type VirtualizedGridPropsPublic = __ExtractPublicPropTypes<typeof virtualizedGridProps>;
export declare type VirtualizedListProps = ExtractPropTypes<typeof virtualizedListProps>;
export declare const virtualizedListProps: {
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
    readonly cache: EpPropFinalized<NumberConstructor, never, never, 2, false>;
    readonly estimatedItemSize: {
        readonly type: PropType<number>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", never, "vertical", false>;
    readonly initScrollOffset: EpPropFinalized<NumberConstructor, never, never, 0, false>;
    readonly total: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly itemSize: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => number | ItemSize) | (() => number | ItemSize) | ((new (...args: any[]) => number | ItemSize) | (() => number | ItemSize))[], never, never>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type VirtualizedListPropsPublic = __ExtractPublicPropTypes<typeof virtualizedListProps>;
export declare type VirtualizedProps = ExtractPropTypes<typeof virtualizedProps>;
export declare const virtualizedProps: {
    readonly className: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
    readonly containerElement: EpPropFinalized<(new (...args: any[]) => string | Element) | (() => string | Element) | ((new (...args: any[]) => string | Element) | (() => string | Element))[], unknown, unknown, "div", boolean>;
    readonly data: EpPropFinalized<(new (...args: any[]) => any[]) | (() => any[]) | ((new (...args: any[]) => any[]) | (() => any[]))[], unknown, unknown, () => [
    ], boolean>;
    readonly direction: EpPropFinalized<StringConstructor, "ltr" | "rtl", never, "ltr", false>;
    readonly height: {
        readonly type: PropType<EpPropMergeType<readonly [
            StringConstructor,
            NumberConstructor
        ], unknown, unknown>>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly innerElement: EpPropFinalized<readonly [
        StringConstructor,
        ObjectConstructor
    ], unknown, unknown, "div", boolean>;
    readonly style: {
        readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue) | ((new (...args: any[]) => string | CSSProperties | StyleValue[]) | (() => StyleValue))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly useIsScrolling: BooleanConstructor;
    readonly width: {
        readonly type: PropType<EpPropMergeType<readonly [
            NumberConstructor,
            StringConstructor
        ], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly perfMode: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly scrollbarAlwaysOn: BooleanConstructor;
};
export declare type VirtualizedPropsPublic = __ExtractPublicPropTypes<typeof virtualizedProps>;
export declare type VirtualizedScrollbarProps = ExtractPropTypes<typeof virtualizedScrollbarProps>;
export declare const virtualizedScrollbarProps: {
    readonly alwaysOn: BooleanConstructor;
    readonly class: StringConstructor;
    readonly layout: EpPropFinalized<StringConstructor, "horizontal" | "vertical", never, "vertical", false>;
    readonly total: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly ratio: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly clientSize: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly scrollFrom: {
        readonly type: PropType<number>;
        readonly required: true;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly scrollbarSize: EpPropFinalized<NumberConstructor, unknown, unknown, 6, boolean>;
    readonly startGap: EpPropFinalized<NumberConstructor, unknown, unknown, 0, boolean>;
    readonly endGap: EpPropFinalized<NumberConstructor, unknown, unknown, 2, boolean>;
    readonly visible: BooleanConstructor;
};
export declare type VirtualizedScrollbarPropsPublic = __ExtractPublicPropTypes<typeof virtualizedScrollbarProps>;
declare const vLoading: Directive<ElementLoading, LoadingBinding>;
export { vLoading as ElLoadingDirective };
export { vLoading };
export declare const vRepeatClick: ObjectDirective<HTMLElement, RepeatClickOptions | RepeatClickOptions["handler"]>;
export declare interface WatermarkFontType {
    color?: string;
    fontSize?: number | string;
    fontWeight?: "normal" | "light" | "weight" | number;
    fontStyle?: "none" | "normal" | "italic" | "oblique";
    fontFamily?: string;
    textAlign?: "start" | "end" | "left" | "right" | "center";
    textBaseline?: "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";
}
export declare type WatermarkInstance = InstanceType<typeof _default_103> & unknown;
export declare type WatermarkProps = ExtractPropTypes<typeof watermarkProps>;
export declare const watermarkProps: {
    readonly zIndex: EpPropFinalized<NumberConstructor, unknown, unknown, 9, boolean>;
    readonly rotate: EpPropFinalized<NumberConstructor, unknown, unknown, -22, boolean>;
    readonly width: NumberConstructor;
    readonly height: NumberConstructor;
    readonly image: StringConstructor;
    readonly content: EpPropFinalized<(new (...args: any[]) => string | string[]) | (() => string | string[]) | ((new (...args: any[]) => string | string[]) | (() => string | string[]))[], unknown, unknown, "Element Plus", boolean>;
    readonly font: {
        readonly type: PropType<WatermarkFontType>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly gap: EpPropFinalized<(new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]) | ((new (...args: any[]) => [
        number,
        number
    ]) | (() => [
        number,
        number
    ]))[], unknown, unknown, () => number[], boolean>;
    readonly offset: {
        readonly type: PropType<[
            number,
            number
        ]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
};
export declare type WatermarkPropsPublic = __ExtractPublicPropTypes<typeof watermarkProps>;
export declare const WEEK_DAYS: readonly [
    "sun",
    "mon",
    "tue",
    "wed",
    "thu",
    "fri",
    "sat"
];
declare type Writable<T> = {
    -readonly [P in keyof T]: T[P];
};
declare type WritableArray<T> = T extends readonly any[] ? Writable<T> : T;
export declare const ZINDEX_INJECTION_KEY: InjectionKey<ElZIndexInjectionContext>;
export declare const zIndexContextKey: InjectionKey<Ref<number | undefined>>;
export {};
